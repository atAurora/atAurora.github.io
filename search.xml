<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java实现十大经典排序算法</title>
    <url>/2020/11/28/Java%E5%AE%9E%E7%8E%B0%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><ul>
<li><strong>内部排序</strong>：指在排序期间，元素全部存放在内存中的排序，常见的内部排序算法有：<strong>冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、基数排序等</strong>。</li>
<li><strong>外部排序</strong>：指在排序期间，元素无法完全全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。</li>
<li><strong>比较类排序</strong>：：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$\mathrm O({\mathrm{Nlog}}_2\mathrm N)$，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 常见的非比较类排序算法有：<strong>基数排序、计数排序、桶排序</strong>。</li>
</ul>
<p>一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。但是，并非所有的内部排序算法都要基于比较操作。</p>
<p>每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。<strong>通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类</strong>，内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。</p>
<p><img src="https://oss.gleaming.cn/Blog/Sort/Sorting-overview.png"></p>
<h2 id="一、冒泡排序-Bubble-Sort"><a href="#一、冒泡排序-Bubble-Sort" class="headerlink" title="一、冒泡排序 (Bubble Sort)"></a>一、<strong>冒泡排序 (Bubble Sort)</strong></h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h3><p>每次检查相邻的两个元素，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。当没有相邻元素需要交换时，排序就完成了。</p>
<p>经过$i$次扫面后，数列的末尾$i$项必然是最大的$i$项，因此冒泡排序最多需要扫描$n-1$遍数组就能完成扫描。</p>
<h3 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h3><ul>
<li><strong>①</strong> 比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li><strong>②</strong> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li><strong>③</strong> 针对所有的元素重复步骤 <strong>①</strong> ~ <strong>②</strong>，除了最后一个元素，直到排序完成。</li>
</ul>
<h3 id="3-动画演示"><a href="#3-动画演示" class="headerlink" title="3.动画演示"></a>3.动画演示</h3><p><img src="https://oss.gleaming.cn/Blog/Sort/Bubble-sort.gif" alt="Bubble-sort"></p>
<h3 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><blockquote>
<p>平均时间复杂度：$\mathrm O(\mathrm N^2)$<br><br>最佳时间复杂度：$\mathrm O(\mathrm N)$<br><br>最差时间复杂度：$\mathrm O(\mathrm N^2)$<br><br>空间复杂度：$\mathrm O(\mathrm 1)$<br><br>排序方式：In-place<br>稳定性：稳定</p>
</blockquote>
<h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp;</span><br><span class="line">                    temp = arr[j - <span class="number">1</span>];</span><br><span class="line">                    arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序还有一种优化算法，就是立一个 flag，当某一趟序列遍历中元素没有发生交换，则证明该序列已经有序，就不再进行后续的排序。动画演示里就是改进后的算法，改进后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp;</span><br><span class="line">                    temp = arr[j - <span class="number">1</span>];</span><br><span class="line">                    arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、选择排序-Selection-Sort"><a href="#二、选择排序-Selection-Sort" class="headerlink" title="二、选择排序 (Selection Sort)"></a>二、选择排序 (Selection Sort)</h2><h3 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1.原理"></a>1.原理</h3><p>每次找出第$i$小的元素 (也就是$A_{i..n}$中最小的元素)，然后将这个元素与数组第$i$个位置上的元素交换。</p>
<h3 id="2-步骤-1"><a href="#2-步骤-1" class="headerlink" title="2.步骤"></a>2.步骤</h3><ul>
<li><strong>①</strong> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</li>
<li><strong>②</strong> 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li>
<li><strong>③</strong> 重复步骤 <strong>②</strong>，直到所有元素均排序完毕。</li>
</ul>
<h3 id="3-动画演示-1"><a href="#3-动画演示-1" class="headerlink" title="3.动画演示"></a>3.动画演示</h3><p><img src="https://oss.gleaming.cn/Blog/Sort/Selection-Sort.gif"></p>
<h3 id="4-性能分析-1"><a href="#4-性能分析-1" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><blockquote>
<p>平均时间复杂度：$\mathrm O(\mathrm N^2)$<br><br>最佳时间复杂度：$\mathrm O(\mathrm N^2)$<br><br>最差时间复杂度：$\mathrm O(\mathrm N^2)$<br><br>空间复杂度：$\mathrm O(\mathrm 1)$<br><br>排序方式：In-place<br>稳定性：不稳定</p>
</blockquote>
<h3 id="5-代码-1"><a href="#5-代码-1" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)</span><br><span class="line">                <span class="keyword">if</span> (arr[min] &gt; arr[j])</span><br><span class="line">                    min = j;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[min];</span><br><span class="line">            arr[min] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、插入排序-Insertion-Sort"><a href="#三、插入排序-Insertion-Sort" class="headerlink" title="三、插入排序 (Insertion Sort)"></a>三、插入排序 (Insertion Sort)</h2><h3 id="1-原理-2"><a href="#1-原理-2" class="headerlink" title="1.原理"></a>1.原理</h3><p>将排列元素划分为“已排序”和”未排序”两部分，每次从”未排序的”元素中选择一个插入到”已排序”的元素中的正确位置。</p>
<p>一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌。按牌面大小插到手牌后，再抓下一张牌。</p>
<h3 id="2-步骤-2"><a href="#2-步骤-2" class="headerlink" title="2.步骤"></a>2.步骤</h3><ul>
<li><strong>①</strong> 从第一个元素开始，该元素可以认为已经被排序；</li>
<li><strong>②</strong> 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li><strong>③</strong> 如果该元素（已排序的）大于新元素，将该元素往右移到下一位置，重复该步骤，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li><strong>④</strong> 将新元素插入到步骤 <strong>③</strong> 找到的位置的后面；</li>
<li><strong>⑤</strong> 重复步骤 <strong>②</strong> ~ <strong>④</strong>。</li>
</ul>
<h3 id="3-动画演示-2"><a href="#3-动画演示-2" class="headerlink" title="3.动画演示"></a>3.动画演示</h3><p><img src="https://oss.gleaming.cn/Blog/Sort/Insertion-Sort.gif"></p>
<h3 id="4-性能分析-2"><a href="#4-性能分析-2" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><blockquote>
<p>平均时间复杂度：$\mathrm O(\mathrm N^2)$<br><br>最差时间复杂度：$\mathrm O(\mathrm N^2)$<br><br>空间复杂度：$\mathrm O(\mathrm 1)$<br><br>排序方式：In-place<br>稳定性：稳定</p>
</blockquote>
<h3 id="5-代码-2"><a href="#5-代码-2" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="comment">//如果比tmp大把值往后移动一位</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; tmp)&#123;</span><br><span class="line">                    arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、希尔排序-Shell-Sort"><a href="#四、希尔排序-Shell-Sort" class="headerlink" title="四、希尔排序 (Shell Sort)"></a>四、希尔排序 (Shell Sort)</h2><h3 id="1-原理-3"><a href="#1-原理-3" class="headerlink" title="1.原理"></a>1.原理</h3><p>排序对不相邻的记录进行比较和移动：</p>
<ol>
<li><p>将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同）</p>
</li>
<li><p>对这些子序列进行插入排序；</p>
</li>
<li><p>减小每个子序列中元素之间的间距，重复上述过程直至间距减少为 1。</p>
</li>
</ol>
<h3 id="2-步骤-3"><a href="#2-步骤-3" class="headerlink" title="2.步骤"></a>2.步骤</h3><ul>
<li><p><strong>①</strong> n 为数组长度，首先取一个整数$d1=n/2$，将元素分为$d1$ 个组，每组相邻量元素之间距离为$d1-1$，在各组内进行直接插入排序；</p>
</li>
<li><p><strong>②</strong> 取第二个整数$d2=d1/2$，重复步骤 <strong>①</strong> 分组排序过程，直到$di=1$，即所有元素在同一组内进行直接插入排序。</p>
</li>
</ul>
<p><strong>PS</strong>：希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</p>
<h3 id="3-动画演示-3"><a href="#3-动画演示-3" class="headerlink" title="3.动画演示"></a>3.动画演示</h3><p><img src="https://oss.gleaming.cn/Blog/Sort/Shell-Sort.gif"></p>
<h3 id="4-性能分析-3"><a href="#4-性能分析-3" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><blockquote>
<p>平均时间复杂度：$\mathrm O({\mathrm{Nlog}}_2\mathrm N)$<br><br>最佳时间复杂度：<br>最差时间复杂度：$\mathrm O(\mathrm N^2)$<br><br>空间复杂度：$\mathrm O(\mathrm 1)$<br><br>稳定性：不稳定<br>复杂性：较复杂</p>
</blockquote>
<h3 id="5-代码-3"><a href="#5-代码-3" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">while</span> (gap &lt; arr.length / <span class="number">3</span>)</span><br><span class="line">            gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                    arr[j + gap] = arr[j];</span><br><span class="line">                arr[j + gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、归并排序-Merge-Sort"><a href="#五、归并排序-Merge-Sort" class="headerlink" title="五、归并排序 (Merge Sort)"></a>五、归并排序 (Merge Sort)</h2><h3 id="1-原理-4"><a href="#1-原理-4" class="headerlink" title="1.原理"></a>1.原理</h3><p>归并排序分为三个步骤：</p>
<ol>
<li>将数列划分为两部分；</li>
<li>递归地分别对两个子序列进行归并排序；</li>
<li>合并两个子序列。</li>
</ol>
<p>不难发现，归并排序的前两步都很好实现，关键是如何合并两个子序列。注意到两个子序列在第二步中已经保证了都是有序的了，第三步中实际上是想要把两个 <strong>有序</strong> 的序列合并起来。</p>
<h3 id="2-步骤-4"><a href="#2-步骤-4" class="headerlink" title="2.步骤"></a>2.步骤</h3><ol>
<li><p><strong>归并的基本步骤</strong></p>
<ul>
<li><strong>①</strong> 申请空间，使其大小为<strong>两个已经排序序列之和</strong>，该空间用来存放合并后的序列；</li>
<li><strong>②</strong> 设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li><strong>③</strong> 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li><strong>④</strong> 重复步骤 <strong>③</strong> 直到某一指针达到序列尾；</li>
<li><strong>⑤</strong> 将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul>
</li>
<li><p><strong>归并排序的步骤</strong></p>
<ul>
<li><strong>①</strong> 分解：将列表越分越小，直至分成一个元素，终止条件：一个元素是有序的。</li>
<li><strong>②</strong> 合并：不断将两个有序列表进行归并，列表越来越大，直到所有序列归并完毕。</li>
</ul>
</li>
</ol>
<h3 id="3-动画演示-4"><a href="#3-动画演示-4" class="headerlink" title="3.动画演示"></a>3.动画演示</h3><p><img src="https://oss.gleaming.cn/Blog/Sort/Merge-Sort.gif"></p>
<h3 id="4-性能分析-4"><a href="#4-性能分析-4" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><blockquote>
<p>平均时间复杂度：$\mathrm O({\mathrm{Nlog}}_2\mathrm N)$<br><br>最佳时间复杂度：$\mathrm O(\mathrm N)$<br><br>最差时间复杂度：$\mathrm O({\mathrm{Nlog}}_2\mathrm N)$<br><br>空间复杂度：$\mathrm O(\mathrm N)$<br><br>排序方式：In-place<br>稳定性：稳定</p>
</blockquote>
<h3 id="5-代码-4"><a href="#5-代码-4" class="headerlink" title="5.代码"></a>5.代码</h3><p><strong>迭代法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> block, start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原版代码的迭代次数少了一次，没有考虑到奇数列数组的情况</span></span><br><span class="line">        <span class="keyword">for</span> (block = <span class="number">1</span>; block &lt; len * <span class="number">2</span>; block *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += <span class="number">2</span> * block) &#123;</span><br><span class="line">                <span class="keyword">int</span> low = start;</span><br><span class="line">                <span class="keyword">int</span> mid = (start + block) &lt; len ? (start + block) : len;</span><br><span class="line">                <span class="keyword">int</span> high = (start + <span class="number">2</span> * block) &lt; len ? (start + <span class="number">2</span> * block) : len;</span><br><span class="line">                <span class="comment">//两个块的起始下标及结束下标</span></span><br><span class="line">                <span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">                <span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">                <span class="comment">//开始对两个block进行归并排序</span></span><br><span class="line">                <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123;</span><br><span class="line">                    result[low++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (start1 &lt; end1) &#123;</span><br><span class="line">                    result[low++] = arr[start1++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (start2 &lt; end2) &#123;</span><br><span class="line">                    result[low++] = arr[start2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[] temp = arr;</span><br><span class="line">            arr = result;</span><br><span class="line">            result = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        result = arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortRecursive</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] result, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">        <span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">        <span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">        mergeSortRecursive(arr, result, start1, end1);</span><br><span class="line">        mergeSortRecursive(arr, result, start2, end2);</span><br><span class="line">        <span class="keyword">int</span> k = start;</span><br><span class="line">        <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">            result[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">        <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">            result[k++] = arr[start1++];</span><br><span class="line">        <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">            result[k++] = arr[start2++];</span><br><span class="line">        <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">            arr[k] = result[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        mergeSortRecursive(arr, result, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、快速排序-Quick-sort"><a href="#六、快速排序-Quick-sort" class="headerlink" title="六、快速排序 (Quick sort)"></a>六、快速排序 (Quick sort)</h2><h3 id="1-原理-5"><a href="#1-原理-5" class="headerlink" title="1.原理"></a>1.原理</h3><p>通过分治的方式来将一个数组排序。</p>
<p>快速分为三个过程：</p>
<ol>
<li>将数列划分为两部分 (要保证相对大小关系);</li>
<li>递归到连个子序列中分别进行快速排序;</li>
<li>不用合并，因为此时数列已经完全有序。</li>
</ol>
<p>和归并排序不同，第一步并不是直接分成前后两个序列，而是在分的过程中要保证相对大小关系。具体来说，第一步是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。为了保证平均时间复杂度，一般是随机选择一个数$m$来当作两个子数列的分界。</p>
<p>之后，维护一前一后两个指针$p$和$q$，依次考虑当前的数是否放在了应该放的位置 (前还是后)。如果当前的数没放对，比如说如果后面的指针$q$遇到了一个比$m$小的数，那么可以交换$p$和$q$位置上的数，再把$p$向后移一位。当前的数的位置全放对后，再移动指针继续处理，直到两个指针相遇。</p>
<h3 id="2-步骤-5"><a href="#2-步骤-5" class="headerlink" title="2.步骤"></a>2.步骤</h3><ul>
<li><strong>①</strong> 从数列中挑出一个元素，称为 “基准值”;</li>
<li><strong>②</strong> 重新排序数列，所有元素比基准值小的放在基准值的左边，比基准值大的放在基准值的右边（相同的数可以到任一边）。在这个分区退出之后，该基准值就处于数列的中间位置。这个称为分区（partition）操作，也可以称为一次归位操作，归位操作的过程见下动图；</li>
<li><strong>③</strong> 递归地把小于基准值元素的子数列和大于基准值元素的子数列按照步骤 <strong>① ②</strong> 排序。</li>
</ul>
<h3 id="3-动画演示-5"><a href="#3-动画演示-5" class="headerlink" title="3.动画演示"></a>3.动画演示</h3><p><img src="https://oss.gleaming.cn/Blog/Sort/QuickSrot.gif"></p>
<h3 id="4-性能分析-5"><a href="#4-性能分析-5" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><blockquote>
<p>平均时间复杂度：$\mathrm O({\mathrm{Nlog}}_2\mathrm N)$<br><br>最佳时间复杂度：$\mathrm O({\mathrm{Nlog}}_2\mathrm N)$<br><br>最差时间复杂度：$\mathrm O(\mathrm N^2)$<br><br>空间复杂度：根据实现方式的不同而不同</p>
</blockquote>
<h3 id="5-代码-5"><a href="#5-代码-5" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">quickSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">        arr[x] = arr[y];</span><br><span class="line">        arr[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = arr[end];</span><br><span class="line">        <span class="keyword">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">                right--;</span><br><span class="line">            swap(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">            swap(left, end);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left++;</span><br><span class="line">        quick_sort_recursive(start, left - <span class="number">1</span>);</span><br><span class="line">        quick_sort_recursive(left + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arrin)</span> </span>&#123;</span><br><span class="line">        arr = arrin;</span><br><span class="line">        quick_sort_recursive(<span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、堆排序-Heap-Sort"><a href="#七、堆排序-Heap-Sort" class="headerlink" title="七、堆排序 (Heap Sort)"></a>七、堆排序 (Heap Sort)</h2><h3 id="1-原理-6"><a href="#1-原理-6" class="headerlink" title="1.原理"></a>1.原理</h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<ul>
<li>堆：一种特殊的完全二叉树结构</li>
<li>大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li>
<li>小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li>
</ul>
<h3 id="2-步骤-6"><a href="#2-步骤-6" class="headerlink" title="2.步骤"></a>2.步骤</h3><ul>
<li>① 构建堆：将待排序序列构建成一个堆 H[0……n-1]，从最后一个非叶子结点开始，从左至右，从下至上进行调整。根据升序或降序需求选择大顶堆或小顶堆；</li>
<li>② 此时的堆顶元素，为最大或者最小元素；</li>
<li>③ 把堆顶元素和堆尾元素互换，调整堆，重新使堆有序；</li>
<li>④ 此时堆顶元素为第二大元素；</li>
<li>⑤ 重复以上步骤，直到堆变空。</li>
</ul>
<p><img src="https://oss.gleaming.cn/Blog/Sort/Heap.png"></p>
<h3 id="3-动画演示-6"><a href="#3-动画演示-6" class="headerlink" title="3.动画演示"></a>3.动画演示</h3><p><img src="https://oss.gleaming.cn/Blog/Sort/Heap-Sort.gif"></p>
<h3 id="4-性能分析-6"><a href="#4-性能分析-6" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><blockquote>
<p>平均时间复杂度：$\mathrm O({\mathrm{Nlog}}_2\mathrm N)$<br><br>最佳时间复杂度：$\mathrm O({\mathrm{Nlog}}_2\mathrm N)$<br><br>最差时间复杂度：$\mathrm O({\mathrm{Nlog}}_2\mathrm N)$<br><br>稳定性：不稳定</p>
</blockquote>
<h3 id="5-代码-6"><a href="#5-代码-6" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序的主要入口方法，共两步。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  第一步：将数组堆化</span></span><br><span class="line"><span class="comment">         *  beginIndex = 第一个非叶子节点。</span></span><br><span class="line"><span class="comment">         *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment">         *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> beginIndex = (len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = beginIndex; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            maxHeapify(i, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 第二步：对堆化数据排序</span></span><br><span class="line"><span class="comment">         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span></span><br><span class="line"><span class="comment">         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">         * 直至未排序的堆长度为 0。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            swap(<span class="number">0</span>, i);</span><br><span class="line">            maxHeapify(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整索引为 index 处的数据，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要堆化处理的数据的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len 未排序的堆（数组）的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> li = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">        <span class="keyword">int</span> ri = li + <span class="number">1</span>;           <span class="comment">// 右子节点索引</span></span><br><span class="line">        <span class="keyword">int</span> cMax = li;             <span class="comment">// 子节点值最大索引，默认左子节点。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(li &gt; len) <span class="keyword">return</span>;       <span class="comment">// 左子节点索引超出计算范围，直接返回。</span></span><br><span class="line">        <span class="keyword">if</span>(ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) <span class="comment">// 先判断左右子节点，哪个较大。</span></span><br><span class="line">            cMax = ri;</span><br><span class="line">        <span class="keyword">if</span>(arr[cMax] &gt; arr[index])&#123;</span><br><span class="line">            swap(cMax, index);      <span class="comment">// 如果父节点被子节点调换，</span></span><br><span class="line">            maxHeapify(cMax, len);  <span class="comment">// 则需要继续判断换下后的父节点是否符合堆的特性。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、计数排序-Counting-Sort"><a href="#八、计数排序-Counting-Sort" class="headerlink" title="八、计数排序 (Counting Sort)"></a>八、计数排序 (Counting Sort)</h2><h3 id="1-原理-7"><a href="#1-原理-7" class="headerlink" title="1.原理"></a>1.原理</h3><p>使用一个额外的数组 $C$，其中第$i$ 个元素是待排序数组$A$中值等于$i$的元素的个数，然后根据数组$C$来将$A$中的元素排到正确的位置。</p>
<p>他的工作过程分为三个步骤：</p>
<ol>
<li>计算每个数出现了几次；</li>
<li>求出每个数的前缀和；</li>
<li>利用出现次数的前缀和，从右至左计算每个数的排名。</li>
</ol>
<h3 id="2-步骤-7"><a href="#2-步骤-7" class="headerlink" title="2.步骤"></a>2.步骤</h3><ul>
<li><strong>①</strong> 找到待排序列表中的最大值 k，开辟一个长度为 k+1 的计数列表，计数列表中的值都为 0。</li>
<li><strong>②</strong> 遍历待排序列表，如果遍历到的元素值为 i，则计数列表中索引 i 的值加1。</li>
<li><strong>③</strong> 遍历完整个待排序列表，计数列表中索引 i 的值 j 表示 i 的个数为 j，统计出待排序列表中每个值的数量。</li>
<li><strong>④</strong> 创建一个新列表（也可以清空原列表，在原列表中添加），遍历计数列表，依次在新列表中添加 j 个 i，新列表就是排好序后的列表，整个过程没有比较待排序列表中的数据大小。</li>
</ul>
<h3 id="3-动画演示-7"><a href="#3-动画演示-7" class="headerlink" title="3.动画演示"></a>3.动画演示</h3><p><img src="https://oss.gleaming.cn/Blog/Sort/Counting-Sort.gif"></p>
<h3 id="4-性能分析-7"><a href="#4-性能分析-7" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><blockquote>
<p>平均时间复杂度：$\mathrm O(\mathrm N+\mathrm K)$<br><br>最佳时间复杂度：$\mathrm O(\mathrm N+\mathrm K)$<br><br>最差时间复杂度：$\mathrm O(\mathrm N+\mathrm K)$<br><br>空间复杂度：$\mathrm O(\mathrm N+\mathrm K)$</p>
</blockquote>
<h3 id="5-代码-7"><a href="#5-代码-7" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] A = CountingSort.countingSort(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">16</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        Utils.print(A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countingSort(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="comment">// 假设A中的数据a&#x27;有，0&lt;=a&#x27; &amp;&amp; a&#x27; &lt; k并且k=100</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">100</span>;</span><br><span class="line">        countingSort(A, B, k);</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] C = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="comment">// 计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = A[j];</span><br><span class="line">            C[a] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Utils.print(C);</span><br><span class="line">        <span class="comment">// 求计数和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Utils.print(C);</span><br><span class="line">        <span class="comment">// 整理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = A.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = A[j];</span><br><span class="line">            B[C[a] - <span class="number">1</span>] = a;</span><br><span class="line">            C[a] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、桶排序-Bucket-Sort"><a href="#九、桶排序-Bucket-Sort" class="headerlink" title="九、桶排序 (Bucket Sort)"></a>九、桶排序 (Bucket Sort)</h2><h3 id="1-原理-8"><a href="#1-原理-8" class="headerlink" title="1.原理"></a>1.原理</h3><p>桶排序又叫箱排序，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。</p>
<p>桶排序也是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ul>
<li>在额外空间充足的情况下，尽量增大桶的数量；</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。</li>
</ul>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<ul>
<li>最快情况：当输入的数据可以均匀的分配到每一个桶中；</li>
<li>最慢情况：当输入的数据被分配到了同一个桶中。</li>
</ul>
<h3 id="2-步骤-8"><a href="#2-步骤-8" class="headerlink" title="2.步骤"></a>2.步骤</h3><ul>
<li><strong>①</strong> 创建一个定量的数组当作空桶子；</li>
<li><strong>②</strong> 遍历序列，把元素一个一个放到对应的桶子去；</li>
<li><strong>③</strong> 对每个不是空的桶子进行排序；</li>
<li><strong>④</strong> 从不是空的桶子里把元素再放回原来的序列中。</li>
</ul>
<h3 id="3-动画演示-8"><a href="#3-动画演示-8" class="headerlink" title="3.动画演示"></a>3.动画演示</h3><p><img src="https://oss.gleaming.cn/Blog/Sort/Bucket-Sort.gif"></p>
<h3 id="4-性能分析-8"><a href="#4-性能分析-8" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><blockquote>
<p>平均时间复杂度：$\mathrm O(\mathrm N+\mathrm K)$<br><br>最佳时间复杂度：$\mathrm O(\mathrm N+\mathrm K)$<br><br>最差时间复杂度：$\mathrm O(\mathrm N^2)$<br><br>空间复杂度：$\mathrm O(\mathrm N\ast\mathrm K)$<br><br>稳定性：稳定</p>
</blockquote>
<h3 id="5-代码-8"><a href="#5-代码-8" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] bucketSort(<span class="keyword">double</span>[] arr)&#123;</span><br><span class="line">        <span class="comment">//1.计算出最大值和最小值，求出两者的差值</span></span><br><span class="line">        <span class="keyword">double</span> min = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; arr[i])&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; min)&#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> d = max - min;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.初始化桶</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = arr.length;</span><br><span class="line">        List&lt;LinkedList&lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            bucketList.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历数组中的元素，把所有元素都放入对应的桶当中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//计算当前元素应该放在哪个桶里面</span></span><br><span class="line">            <span class="keyword">int</span> num = (<span class="keyword">int</span>)((arr[i] - min) / (d / (bucketNum - <span class="number">1</span>)));</span><br><span class="line">            bucketList.get(num).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.对每个桶里面的元素进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            Collections.sort(bucketList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.输出全部元素</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(LinkedList&lt;Double&gt; doubles : bucketList)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Double aDouble : doubles) &#123;</span><br><span class="line">                arr[k] = aDouble;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="十、基数排序-Radix-Sort"><a href="#十、基数排序-Radix-Sort" class="headerlink" title="十、基数排序 (Radix Sort)"></a>十、基数排序 (Radix Sort)</h2><h3 id="1-原理-9"><a href="#1-原理-9" class="headerlink" title="1.原理"></a>1.原理</h3><p>基数排序属于分配式排序，是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>基数排序、计数排序、桶排序三种排序算法都利用了桶的概念，但对桶的使用方法上是有明显差异的：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值。</li>
</ul>
<h3 id="2-步骤-9"><a href="#2-步骤-9" class="headerlink" title="2.步骤"></a>2.步骤</h3><ul>
<li><strong>①</strong> 取数组中的最大数，并取得位数；</li>
<li><strong>②</strong> 从最低位开始，依次进行一次排序；</li>
<li><strong>③</strong> 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>
</ul>
<h3 id="3-动画演示-9"><a href="#3-动画演示-9" class="headerlink" title="3.动画演示"></a>3.动画演示</h3><p><img src="https://oss.gleaming.cn/Blog/Sort/Redix-Sort.gif"></p>
<h3 id="4-性能分析-9"><a href="#4-性能分析-9" class="headerlink" title="4.性能分析"></a>4.性能分析</h3><blockquote>
<p>时间复杂度：$\mathrm O(\mathrm N\ast\mathrm K)$<br><br>空间复杂度：$\mathrm O(\mathrm N+\mathrm K)$<br><br>稳定性：稳定</p>
</blockquote>
<h3 id="5-代码-9"><a href="#5-代码-9" class="headerlink" title="5.代码"></a>5.代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//待排序列最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> exp;<span class="comment">//指数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anArr &gt; max) &#123;</span><br><span class="line">                max = anArr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从个位开始，对数组进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (exp = <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">//存储待排元素的临时数组</span></span><br><span class="line">            <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">            <span class="comment">//分桶个数</span></span><br><span class="line">            <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将数据出现的次数存储在buckets中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">                <span class="comment">//(value / exp) % 10 :value的最底位(个位)</span></span><br><span class="line">                buckets[(value / exp) % <span class="number">10</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更改buckets[i]，</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将数据存储到临时数组temp中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                temp[buckets[(arr[i] / exp) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">                buckets[(arr[i] / exp) % <span class="number">10</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将有序元素temp赋给arr</span></span><br><span class="line">            System.arraycopy(temp, <span class="number">0</span>, arr, <span class="number">0</span>, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
