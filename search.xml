<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>html语义化理解及SEO</title>
    <url>/2021/11/22/html-semantic-seo/</url>
    <content><![CDATA[<h2 id="1-语义化"><a href="#1-语义化" class="headerlink" title="1. 语义化"></a>1. 语义化</h2><h3 id="1-1-含义"><a href="#1-1-含义" class="headerlink" title="1.1 含义"></a>1.1 含义</h3><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗的来讲就是正确的标签做正确的事情。</p>
<h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul>
<li>  对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li>
<li>  对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li>
</ul>
<h3 id="1-3-常见的语义化标签"><a href="#1-3-常见的语义化标签" class="headerlink" title="1.3 常见的语义化标签"></a>1.3 常见的语义化标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span>  头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>  导航栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  区块（有语义化的div）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span>  主要区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span>  主要内容</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span>  侧边栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure>

<h3 id="1-4-写语义化代码应该注意什么"><a href="#1-4-写语义化代码应该注意什么" class="headerlink" title="1.4 写语义化代码应该注意什么"></a>1.4 写语义化代码应该注意什么</h3><ul>
<li>  尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li>
<li>  不要使用纯样式标签，如：b、font、u等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li>
<li>  使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li>
<li>  表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来</li>
</ul>
<h2 id="2-SEO"><a href="#2-SEO" class="headerlink" title="2. SEO"></a>2. SEO</h2><h3 id="2-1-TKD-设置"><a href="#2-1-TKD-设置" class="headerlink" title="2.1 TKD 设置"></a>2.1 TKD 设置</h3><ul>
<li><p>  页面 TKD 要包含品牌词及业务词，提升页面排名</p>
</li>
<li><p>例如：掘金的 TKD</p>
<ul>
<li>  Title：掘金 - 代码不止，掘金不停</li>
<li>  Keywords：掘金,稀土,Vue.js,前端面试题,nginx配置,Kotlin,RxJava,React Native,敏捷开发,Python</li>
<li>  Description：掘金是一个帮助开发者成长的社区,是给开发者用的 <code>Hacker News</code>,给设计师用的 <code>Designer News</code>,和给产品经理用的 <code>Medium</code>。掘金的技术文章由稀土上聚集的技术大牛和极客共同编辑为你筛选出最优质的干货,其中包括：<code>Android、iOS</code>、前端、后端等方面的内容。用户每天都可以在这里找到技术世界的头条内容。与此同时,掘金内还有沸点、掘金翻译计划、线下活动、专栏文章等内容。即使你是 <code>GitHub、StackOverflow、</code>开源中国的用户,我们相信你也可以在这里有所收获。</li>
</ul>
</li>
</ul>
<h3 id="2-2-页面内容优化"><a href="#2-2-页面内容优化" class="headerlink" title="2.2 页面内容优化"></a>2.2 页面内容优化</h3><ol>
<li> 网页代码语义化调整：多使用语义化标签，便于爬虫搜索。</li>
<li> 页面内容关键词强化：在页面大小标题和文案中重复关键词，以达到内容强化目的；关键词汇避免使用图片，便于爬虫检索，收录。</li>
<li> img 添加 alt 属性，用 h1 标签写内容关键字。</li>
</ol>
<p>引导链接</p>
<ul>
<li>  网站底部推荐部分保留产品介绍、常见问题汇总等降低跳出率的引导，提高页面留存与转化；或者与所推荐页面形成互链形式，以稳定页面流量权重。</li>
</ul>
<h3 id="2-3-移动端优化"><a href="#2-3-移动端优化" class="headerlink" title="2.3 移动端优化"></a>2.3 移动端优化</h3><ul>
<li>  设置移动页面，或者将 pc 页面设置为自适应，增加移动端搜索的体验和留存转化</li>
<li>移动页面设计需注意以下原则：<ol>
<li> 页面字体、字符大小、文本行间距等设计，应适合手机用户阅读，不可明显过大过小，正文文本字号不小于 10pt（pt：绝对单位，等于1/72英寸）。</li>
<li> 首屏主体内容必须占屏幕的 50% 以上。</li>
<li> 主体内容应与其它板块有明显区分，且位于屏幕的中心位置，使用户获取信息是不受任何干扰。</li>
<li> 导航的功能与位置明确，避免用户使用过程中被误导</li>
<li> 除以上提到的内容外，网站还应避免其他影响页面内容辨识的情况，例如页面出现大面积空白、文本无任何排版、段落/图片排版错乱不整齐、主体内容展示不全等。</li>
</ol>
</li>
</ul>
<h3 id="2-4-站外优化"><a href="#2-4-站外优化" class="headerlink" title="2.4 站外优化"></a>2.4 站外优化</h3><ol>
<li> 在搜索引擎排名较高的公众平台发布正面网站信息，以建设良好口碑；负面信息排名较高的需删除或者屏蔽处理。</li>
<li> 百度，互动，搜狗等百科的创建更新与维护，(互动百科在今日头条有着较高的排名，现在今日头条也在发展搜素引擎)，百科对树立品牌形象较为重要。</li>
<li> 公关舆情传播，宣传新闻源发布。</li>
<li> 站外推广与外链建设。</li>
<li> 根据竞争对手及品牌业务分析，拓展高质量、高权重的外链渠道、科技论坛、自媒体平台、分类信息网等，发布高质量锚文本外链，另进行友情链接交换，以提高关键词排名及自然流量。</li>
</ol>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>script标签defer和async的区别，还有哪些属性？</title>
    <url>/2021/11/21/script-attribute/</url>
    <content><![CDATA[<h2 id="1-defer-和-async-属性出现的意义"><a href="#1-defer-和-async-属性出现的意义" class="headerlink" title="1. defer 和 async 属性出现的意义"></a>1. defer 和 async 属性出现的意义</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>
<h3 id="1-1-defer-属性"><a href="#1-1-defer-属性" class="headerlink" title="1.1 defer 属性"></a>1.1 defer 属性</h3><p>推迟执行脚本。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</p>
<ul>
<li>  在 &lt;script&gt; 标签上设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。</li>
<li>  HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，并且会在 DOMContentLoaded 事件之前执行。不过在实际当中，不一定总会按照顺序或者在 DOMContentLoaded 事件之前执行。</li>
</ul>
<h3 id="1-2-async-属性（HTML5）"><a href="#1-2-async-属性（HTML5）" class="headerlink" title="1.2 async 属性（HTML5）"></a>1.2 async 属性（<strong>HTML5</strong>）</h3><p>异步执行脚本。表示应该立即请求脚本，并尽快解析和执行，但不能阻止其它页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</p>
<ul>
<li>  告诉浏览器立即下载，但不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行完后在加载其它脚本。（因此，异步脚本不应该在加载期间修改 DOM）</li>
<li>  标记为 async 的脚本并不保证能按照它们出现的次序执行。异步脚本保证会在页面的的 <strong>load</strong> 事件前执行，但可能会在 <strong>DOMContentLoaded</strong> 之前或之后。</li>
</ul>
<h2 id="2-lt-script-gt-标签其它属性"><a href="#2-lt-script-gt-标签其它属性" class="headerlink" title="2. &lt;script&gt; 标签其它属性"></a>2. &lt;script&gt; 标签其它属性</h2><h3 id="2-1-charset-属性"><a href="#2-1-charset-属性" class="headerlink" title="2.1 charset 属性"></a>2.1 charset 属性</h3><p>使用 src 属性指定的代码字符集。很少使用，因为大多数浏览器不在乎它的值。</p>
<h3 id="2-2-crossorigin-属性"><a href="#2-2-crossorigin-属性" class="headerlink" title="2.2 crossorigin 属性"></a>2.2 crossorigin 属性</h3><p>那些没有通过标准CORS (跨域资源共享)检查的正常script 元素传递最少的信息到 window.onerror。可以使用本属性来使那些将静态资源放在另外一个域名的站点打印错误信息。默认不使用 CORS，“” 相当于 “anonymous” ，对此元素的 CORS 请求不设置凭据标志；“use-credentials”，对此元素的 CORS 请求将设置凭证标志，这意味着请求将提供凭据。</p>
<h3 id="2-3-integrity-属性"><a href="#2-3-integrity-属性" class="headerlink" title="2.3 integrity 属性"></a>2.3 integrity 属性</h3><p>允许对比接收到的资源和指定的加密签名以验证子资源完整性（SRI）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN）不会提供恶意内容。</p>
<h3 id="2-4-nomodule-属性"><a href="#2-4-nomodule-属性" class="headerlink" title="2.4 nomodule 属性"></a>2.4 nomodule 属性</h3><p>这个布尔属性被设置来标明这个脚本在支持 ES2015 modules 的浏览器中不执行。实际上，这可用于在不支持模块化 JavaScript 的旧浏览器中提供回退脚本。</p>
<h3 id="2-5-language-属性"><a href="#2-5-language-属性" class="headerlink" title="2.5 language 属性"></a>2.5 language 属性</h3><p>废弃。最初用于表示代码块中的脚本语言。大多数浏览器都会忽略这个属性，不应该再使用它。</p>
<h3 id="2-6-src-属性"><a href="#2-6-src-属性" class="headerlink" title="2.6 src 属性"></a>2.6 src 属性</h3><p>定义引用外部脚本的URI，这可以用来代替直接在文档中嵌入脚本。指定了 src 属性的script元素标签内不应该再有嵌入的脚本。</p>
<h3 id="2-7-type-属性"><a href="#2-7-type-属性" class="headerlink" title="2.7 type 属性"></a>2.7 type 属性</h3><p>代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型：<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></strong>）。支持的MIME类型包括text/javascript, text/ecmascript, application/javascript（非IE支持）, 和application/ecmascript（非IE支持）。如果没有定义这个属性，脚本会被视作JavaScript。如果MIME类型不是JavaScript类型（上述支持的类型），则该元素所包含的内容会被当作数据块而不会被浏览器执行。JS 文件中的MIME 类型通常是 “application/x-javascript” 。如果type属性为module，代码会被当作JavaScript模块 。</p>
<h3 id="2-8-text-属性"><a href="#2-8-text-属性" class="headerlink" title="2.8 text 属性"></a>2.8 text 属性</h3><p>和 textContent 属性类似，本属性用于设置元素的文本内容。但和 textContent 不一样的是，本属性在节点插入到DOM之后，此属性被解析为可执行代码。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>十大经典排序算法</title>
    <url>/2021/11/25/sort-algorithm/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><p>十大常见排序算法可以分为两大类：</p>
<ul>
<li>  比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$O(nlogn)$，因此也称为非线性时间比较类排序</li>
<li>  非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序</li>
</ul>
<span id="more"></span>

<p><img src="/2021/11/25/sort-algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li>  稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li>  不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li>  时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li>  空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>
<li>  In-place：占用常数内存，不占用额外内存。</li>
<li>  Out-place：占用额外内存。</li>
<li>  内排序：所有排序操作都在内存中完成，常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</li>
<li>  外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li>
</ul>
<h2 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h2><h3 id="1-1-思想"><a href="#1-1-思想" class="headerlink" title="1.1 思想"></a>1.1 思想</h3><ul>
<li>  比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>  对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>  针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>  持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
<li>  因此最多重复 n - 1 次，就完成了 n 个数据的排序工作。</li>
</ul>
<h3 id="1-2-动画演示"><a href="#1-2-动画演示" class="headerlink" title="1.2 动画演示"></a>1.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/bubbleSort.gif"></p>
<h3 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;  <span class="comment">// 扫描 n - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123; </span><br><span class="line">      <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;  <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">        <span class="keyword">const</span> temp = arr[j + <span class="number">1</span>]  <span class="comment">// 元素交换</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong>：上述代码不论什么情况下都会对数组扫描 n  - 1次，但是当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。下面是优化后的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSortPlus = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> hasChange = <span class="literal">false</span>  <span class="comment">// 增加一个标记位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">        hasChange = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!hasChange) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-性能分析"><a href="#1-4-性能分析" class="headerlink" title="1.4 性能分析"></a>1.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(N^2)$<br></li>
<li>  最佳时间复杂度：$O(N)$<br></li>
<li>  最差时间复杂度：$O(N^2)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2. 选择排序（Selection Sort）"></a>2. 选择排序（Selection Sort）</h2><h3 id="2-1-思想"><a href="#2-1-思想" class="headerlink" title="2.1 思想"></a>2.1 思想</h3><ul>
<li>  首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>  再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>  重复第二步，直到所有元素均排序完毕。</li>
</ul>
<h3 id="2-2-动画演示"><a href="#2-2-动画演示" class="headerlink" title="2.2 动画演示"></a>2.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/selectionSort.gif"></p>
<h3 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">let</span> minIndex, temp</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    minIndex = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">        minIndex = j  <span class="comment">// 将最小的索引保存</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minIndex !== i) &#123;</span><br><span class="line">      temp = arr[i]</span><br><span class="line">      arr[i] = arr[minIndex]</span><br><span class="line">      arr[minIndex] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-性能分析"><a href="#2-4-性能分析" class="headerlink" title="2.4 性能分析"></a>2.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(N^2)$<br></li>
<li>  最佳时间复杂度：$O(N^2)$<br></li>
<li>  最差时间复杂度：$O(N^2)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：不稳定</li>
</ul>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. 插入排序（Insertion Sort）</h2><h3 id="3-1-思想"><a href="#3-1-思想" class="headerlink" title="3.1 思想"></a>3.1 思想</h3><ul>
<li>  将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>  从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ul>
<h3 id="3-2-动画演示"><a href="#3-2-动画演示" class="headerlink" title="3.2 动画演示"></a>3.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/insertionSort.gif"></p>
<h3 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a>3.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i], j</span><br><span class="line">    <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;  <span class="comment">// 将当前元素和有序序列元素一一比较，寻找何时的插入位置</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; temp) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-性能分析"><a href="#3-4-性能分析" class="headerlink" title="3.4 性能分析"></a>3.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(N^2)$<br></li>
<li>  最佳时间复杂度：$O(N)$<br></li>
<li>  最差时间复杂度：$O(N^2)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h2><h2 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5. 归并排序（Merge Sort）"></a>5. 归并排序（Merge Sort）</h2><h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6. 快速排序（Quick Sort）"></a>6. 快速排序（Quick Sort）</h2><h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7. 堆排序（Heap Sort）"></a>7. 堆排序（Heap Sort）</h2><h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8. 计数排序（Counting Sort）"></a>8. 计数排序（Counting Sort）</h2><h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9. 桶排序（Bucket Sort）"></a>9. 桶排序（Bucket Sort）</h2><h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10. 基数排序（Radix Sort）"></a>10. 基数排序（Radix Sort）</h2><h2 id="11-复杂度对比"><a href="#11-复杂度对比" class="headerlink" title="11. 复杂度对比"></a>11. 复杂度对比</h2><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
<th align="center">排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlog^2n)$</td>
<td align="center">$O(nlog^2n)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(n)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(logn)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="12-练习地址"><a href="#12-练习地址" class="headerlink" title="12. 练习地址"></a>12. 练习地址</h2><p>可以在力扣912测试代码：<a href="https://leetcode-cn.com/problems/sort-an-array/">https://leetcode-cn.com/problems/sort-an-array/</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML面试题</title>
    <url>/2021/11/24/html/</url>
    <content><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2021/11/24/html/01.HTML%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="01.HTML面试题"></p>
<h2 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h2><p>src 和 href 都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p>
<ul>
<li>  <strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。常在 img、script、iframe 等元素上使用。</li>
<li>  <strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。这也是为什么建议使用 link 方式加载 css，而不是使用 @import 方式。</li>
</ul>
<h2 id="2-对HTML语义化的理解，SEO优化"><a href="#2-对HTML语义化的理解，SEO优化" class="headerlink" title="2. 对HTML语义化的理解，SEO优化"></a>2. 对HTML语义化的理解，SEO优化</h2><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗的来讲就是正确的标签做正确的事情。</p>
<p>语义化的优点如下：</p>
<ul>
<li>  对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li>
<li>  对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li>
</ul>
<p>常见的语义化标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span>  头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>  导航栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  区块（有语义化的div）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span>  主要区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span>  主要内容</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span>  侧边栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure>

<p>写语义化代码应该注意什么：</p>
<ul>
<li>  尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li>
<li>  不要使用纯样式标签，如：b、font、u等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li>
<li>  使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li>
<li>  表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来</li>
</ul>
<p>SEO：</p>
<ol>
<li><p>TKD 设置</p>
<ul>
<li><p>  页面 TKD 要包含品牌词及业务词，提升页面排名</p>
</li>
<li><p>例如：掘金的 TKD</p>
<ul>
<li>  Title：掘金 - 代码不止，掘金不停</li>
<li>  Keywords：掘金,稀土,Vue.js,前端面试题,nginx配置,Kotlin,RxJava,React Native,敏捷开发,Python</li>
<li>  Description：掘金是一个帮助开发者成长的社区,是给开发者用的 <code>Hacker News</code>,给设计师用的 <code>Designer News</code>,和给产品经理用的 <code>Medium</code>。掘金的技术文章由稀土上聚集的技术大牛和极客共同编辑为你筛选出最优质的干货,其中包括：<code>Android、iOS</code>、前端、后端等方面的内容。用户每天都可以在这里找到技术世界的头条内容。与此同时,掘金内还有沸点、掘金翻译计划、线下活动、专栏文章等内容。即使你是 <code>GitHub、StackOverflow、</code>开源中国的用户,我们相信你也可以在这里有所收获。</li>
</ul>
</li>
</ul>
</li>
<li><p>页面内容优化</p>
<ol>
<li> 网页代码语义化调整：多使用语义化标签，便于爬虫搜索。</li>
<li> 页面内容关键词强化：在页面大小标题和文案中重复关键词，以达到内容强化目的；关键词汇避免使用图片，便于爬虫检索，收录。</li>
<li> img 添加 alt 属性，用 h1 标签写内容关键字。</li>
</ol>
</li>
<li><p>引导链接</p>
<ul>
<li>  网站底部推荐部分保留产品介绍、常见问题汇总等降低跳出率的引导，提高页面留存与转化；或者与所推荐页面形成互链形式，以稳定页面流量权重。</li>
</ul>
</li>
<li><p>移动端优化</p>
<ul>
<li>  设置移动页面，或者将 pc 页面设置为自适应，增加移动端搜索的体验和留存转化</li>
<li>移动页面设计需注意以下原则：<ol>
<li> 页面字体、字符大小、文本行间距等设计，应适合手机用户阅读，不可明显过大过小，正文文本字号不小于 10pt（pt：绝对单位，等于1/72英寸）。</li>
<li> 首屏主体内容必须占屏幕的 50% 以上。</li>
<li> 主体内容应与其它板块有明显区分，且位于屏幕的中心位置，使用户获取信息是不受任何干扰。</li>
<li> 导航的功能与位置明确，避免用户使用过程中被误导</li>
<li> 除以上提到的内容外，网站还应避免其他影响页面内容辨识的情况，例如页面出现大面积空白、文本无任何排版、段落/图片排版错乱不整齐、主体内容展示不全等。</li>
</ol>
</li>
</ul>
</li>
<li><p>站外优化</p>
<ol>
<li> 在搜索引擎排名较高的公众平台发布正面网站信息，以建设良好口碑；负面信息排名较高的需删除或者屏蔽处理。</li>
<li> 百度，互动，搜狗等百科的创建更新与维护，(互动百科在今日头条有着较高的排名，现在今日头条也在发展搜素引擎)，百科对树立品牌形象较为重要。</li>
<li> 公关舆情传播，宣传新闻源发布。</li>
<li> 站外推广与外链建设。</li>
<li> 根据竞争对手及品牌业务分析，拓展高质量、高权重的外链渠道、科技论坛、自媒体平台、分类信息网等，发布高质量锚文本外链，另进行友情链接交换，以提高关键词排名及自然流量。</li>
</ol>
</li>
</ol>
<h2 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h2><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p>
<p>浏览器渲染页面的两种模式（可通过<strong>document.compatMode</strong>获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p>
<ul>
<li>  <strong>CSS1Compat：标准模式（Standards mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li>
<li>  **BackCompat：怪异模式(混杂模式)(Quicks mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li>
</ul>
<blockquote>
<p>  MDN：在 HTML5 中，DOCTYPE 唯一的作用是启用标准模式。更早期的 HTML 标准中，DOCTYPE 会附加其他意义，但没有任何浏览器会将 DOCTYPE 用于怪异模式和标准模式之间互换以外的用途。</p>
<p>  《JavaScript高级程序设计》：</p>
<p>  ​    IE5.5 发明了文档模式的概念，即可以使用 doctype 切换文档模式。最初的文档模式有两种：混杂模式和标准模式。前者让 IE 像 IE5 一样（支持一些非标准的特性），后者让 IE 具有兼容标准的行为。</p>
<p>  ​    IE 初次支持文档模式切换以后，其它浏览器用也跟着实现了。随着浏览器的普遍出现，又出现了第三种文档模式：准标准模式。这种模式下的浏览器支持很多标准的特性，但是没有标准规定的那么严格。主要区别在于如何对待图片元素周围的空白（在表格中使用图片最为明显）。</p>
</blockquote>
<h2 id="4-script标签中defer和async的区别，还有哪些属性？"><a href="#4-script标签中defer和async的区别，还有哪些属性？" class="headerlink" title="4. script标签中defer和async的区别，还有哪些属性？"></a>4. script标签中defer和async的区别，还有哪些属性？</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>
<p>下图可以直观的看出三者之间的区别:</p>
<p><img src="/2021/11/24/html/01-4.png" alt="01-4"></p>
<ul>
<li>defer 属性：推迟执行脚本。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。<ul>
<li>  在 &lt;script&gt; 标签上设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。</li>
<li>  HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，并且会在 DOMContentLoaded 事件之前执行。不过在实际当中，不一定总会按照顺序或者在 DOMContentLoaded 事件之前执行。</li>
</ul>
</li>
<li>async 属性（<strong>HTML5</strong>）：异步执行脚本。表示应该立即请求脚本，并尽快解析和执行，但不能阻止其它页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。<ul>
<li>  告诉浏览器立即下载，但不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行完后在加载其它脚本。（因此，异步脚本不应该在加载期间修改 DOM）</li>
<li>  标记为 async 的脚本并不保证能按照它们出现的次序执行。异步脚本保证会在页面的的 <strong>load</strong> 事件前执行，但可能会在 <strong>DOMContentLoaded</strong> 之前或之后。</li>
</ul>
</li>
</ul>
<p>除上述外，&lt;script&gt; 标签还有以下属性：</p>
<ul>
<li>  charset：使用 src 属性指定的代码字符集。很少使用，因为大多数浏览器不在乎它的值。</li>
<li>  crossorigin：那些没有通过标准CORS (跨域资源共享)检查的正常script 元素传递最少的信息到 window.onerror。可以使用本属性来使那些将静态资源放在另外一个域名的站点打印错误信息。默认不使用 CORS，“” 相当于 “anonymous” ，对此元素的 CORS 请求不设置凭据标志；“use-credentials”，对此元素的 CORS 请求将设置凭证标志，这意味着请求将提供凭据。</li>
<li>  integrity：允许对比接收到的资源和指定的加密签名以验证子资源完整性（SRI）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN）不会提供恶意内容。</li>
<li>  nomodule：这个布尔属性被设置来标明这个脚本在支持 ES2015 modules 的浏览器中不执行。实际上，这可用于在不支持模块化 JavaScript 的旧浏览器中提供回退脚本。</li>
<li>  language：废弃。最初用于表示代码块中的脚本语言。大多数浏览器都会忽略这个属性，不应该再使用它。</li>
<li>  src：定义引用外部脚本的URI，这可以用来代替直接在文档中嵌入脚本。指定了 src 属性的script元素标签内不应该再有嵌入的脚本。</li>
<li>  type：代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型：<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></strong>）。支持的MIME类型包括text/javascript, text/ecmascript, application/javascript（非IE支持）, 和application/ecmascript（非IE支持）。如果没有定义这个属性，脚本会被视作JavaScript。如果MIME类型不是JavaScript类型（上述支持的类型），则该元素所包含的内容会被当作数据块而不会被浏览器执行。JS 文件中的MIME 类型通常是 “application/x-javascript” 。如果type属性为module，代码会被当作JavaScript模块 。</li>
<li>  text：和 textContent 属性类似，本属性用于设置元素的文本内容。但和 textContent 不一样的是，本属性在节点插入到DOM之后，此属性被解析为可执行代码。</li>
</ul>
<h2 id="5-meta，常⽤的meta（元数据）标签有哪些"><a href="#5-meta，常⽤的meta（元数据）标签有哪些" class="headerlink" title="5. meta，常⽤的meta（元数据）标签有哪些"></a>5. meta，常⽤的meta（元数据）标签有哪些</h2><blockquote>
<p>  每个 meta 只能用于一种用途。如果在这些特性中想要使用的不值一个，那就应该在 head 元素中添加多个 meta 元素。</p>
</blockquote>
<p><code>meta</code> <strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。放在 head 元素中。</p>
<p><code>meta</code> 元素定义的元数据的类型包括以下几种：</p>
<ul>
<li>  如果设置了 <code>name</code> 属性，<code>meta</code> 元素提供的是文档级别（<em>document-level</em>）的元数据，应用于整个页面。</li>
<li>  如果设置了 <code>http-equiv</code> 属性，<code>meta</code> 元素则是编译指令，提供的信息与类似命名的HTTP头部相同。</li>
<li>  如果设置了 <code>charset </code> 属性（<strong>HTML5</strong>），<code>meta</code> 元素是一个字符集声明，告诉文档使用哪种字符编码。</li>
<li>  如果设置了 <code>itemprop</code> 属性，<code>meta</code> 元素提供用户定义的元数据。</li>
</ul>
<p><code>meta</code> 包含的属性：</p>
<blockquote>
<p>  注意: 全局属性 <code>name</code> 在 &lt;meta&gt; 元素中具有特殊的语义；另外， 在同一个 &lt;meta&gt; 标签中，<code>name</code>, <code>http-equiv</code> 或者 <code>charset</code> 三者中任何一个属性存在时，<code>itemprop</code> 属性不能被使用。</p>
</blockquote>
<ul>
<li><p>  <code>charset</code>：这个属性声明了文档的字符编码。如果使用了这个属性，其值必须是与ASCII大小写无关（ASCII case-insensitive）的”<code>utf-8</code>“。</p>
</li>
<li><p>  <code>content</code>：此属性包含 <code>http-equiv</code> 或 <code>name</code> 属性的值，具体取决于所使用的值。</p>
</li>
<li><p><code>http-equiv</code>：属性定义了一个编译指示指令。这个属性叫做 <code>http-equiv(alent)</code> 是因为所有允许的值都是特定HTTP头部的名称，如下：</p>
<ul>
<li><p><code>content-security-policy</code><br>  它允许页面作者定义当前页的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">内容策略</a>。 内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。</p>
</li>
<li><p><code>content-type</code><br>  如果使用这个属性，其值必须是”<code>text/html; charset=utf-8</code>“。注意：该属性只能用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a> 为 <code>text/html</code> 的文档，不能用于MIME类型为XML的文档。</p>
</li>
<li><p><code>default-style</code></p>
<p>  设置默认 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS 样式表</a>组的名称。</p>
</li>
<li><p><code>x-ua-compatible</code><br>  如果指定，则 <code>content</code> 属性必须具有值 “<code>IE=edge</code>“。用户代理必须忽略此指示。</p>
</li>
<li><p><code>refresh</code></p>
<p>  这个属性指定:</p>
<ul>
<li>  如果 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content"><code>content</code></a> 只包含一个正整数，则为重新载入页面的时间间隔(秒)；</li>
<li>  如果 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content"><code>content</code></a> 包含一个正整数，并且后面跟着字符串 ‘<code>;url=</code>‘ 和一个合法的 URL，则是重定向到指定链接的时间间隔(秒)</li>
</ul>
</li>
</ul>
</li>
<li><p><code>name</code></p>
<ul>
<li>  <code>name</code> 和 <code>content</code> 属性可以一起使用，以名-值对的方式给文档提供元数据，其中 name 作为元数据的名称，content 作为元数据的值。</li>
<li>  在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name">标准元数据名称</a>（见下方元数据名称）中查看 HTML 规范等规范中定义的标准元数据名称。</li>
</ul>
</li>
</ul>
<p><code>meta</code> 用途：</p>
<ul>
<li>  指定名/值元数据对</li>
<li>  声明字符编码</li>
<li>  模拟 HTTP 标头字段</li>
</ul>
<p>常用的 <code>meta</code> 标签：</p>
<ol>
<li><p><code>charset</code>，用来描述 HTML 文档的编码类型：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>keywords</code>，页面关键词：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>description</code>，页面描述：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;页面描述内容&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>refresh</code>，页面重定向和刷新：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li>  <code>width viewport</code> ：宽度(数值/device-width)</li>
<li>  <code>height viewport</code> ：高度(数值/device-height)</li>
<li>  <code>initial-scale</code> ：初始缩放比例</li>
<li>  <code>maximum-scale</code> ：最大缩放比例</li>
<li>  <code>minimum-scale</code> ：最小缩放比例</li>
<li>  <code>user-scalable</code> ：是否允许用户缩放(yes/no）</li>
</ul>
</li>
<li><p>搜索引擎索引方式：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p> 其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li>  <code>all</code>：文件将被检索，且页面上的链接可以被查询；</li>
<li>  <code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li>
<li>  <code>index</code>：文件将被检索；</li>
<li>  <code>follow</code>：页面上的链接可以被查询；</li>
<li>  <code>noindex</code>：文件将不被检索；</li>
<li>  <code>nofollow</code>：页面上的链接不可以被查询。</li>
</ul>
</li>
</ol>
<p>元数据名称（参考）：</p>
<ol>
<li><p>HTML 规范定义的标准元数据名称</p>
<ul>
<li><p>  application-name：网页中所运行的应用程序的名称</p>
</li>
<li><p>  author：文档作者的名字</p>
</li>
<li><p>  description：一段简短而精确的、对页面内容的描述。一些浏览器，比如 Firefox 和 Opera，将其用作书签的默认描述。</p>
</li>
<li><p>  generator：用来生成 HTML 的软件名称</p>
</li>
<li><p>  keywords：与页面内容相关的关键词，常以逗号分隔</p>
</li>
<li><p>referrer：控制有当前文档发出的请求的 HTTP Referer 请求头</p>
<ul>
<li><p>  &lt;meta name=”referrer”&gt; 的 content 属性的值</p>
</li>
<li><table>
<thead>
<tr>
<th align="left">content</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">no-referrer</td>
<td align="left">不发送 HTTP <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 请求头。</td>
</tr>
<tr>
<td align="left">origin</td>
<td align="left">只发送当前文档的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a>。</td>
</tr>
<tr>
<td align="left">no-referrer-when-downgrade</td>
<td align="left">如果请求目标与当前页面一样安全或者更加安全（HTTP(S)→HTTPS），则发送完整 URL；<br />如果请求目标更加不安全（HTTPS→HTTP），则不发送 referrer。这是默认行为。</td>
</tr>
<tr>
<td align="left">origin-when-cross-origin</td>
<td align="left">对同源请求发送完整 URL（不含 URL 参数），其他情况下，只发送 origin。</td>
</tr>
<tr>
<td align="left">same-origin</td>
<td align="left">对同源请求发送完整 URL（不含 URL 参数），其他情况下，请求不包含 referrer 请求头。</td>
</tr>
<tr>
<td align="left">strict-origin</td>
<td align="left">如果请求目标与当前页面一样安全或者更加安全（HTTP(S)→HTTPS），则发送 origin；<br />如果请求目标更加不安全（HTTPS→HTTP），则不发送 referrer。</td>
</tr>
<tr>
<td align="left">strict-origin-when-cross-origin</td>
<td align="left">对同源请求发送完整 URL（不含 URL 参数）；<br />其他情况下，如果请求目标与当前页面一样安全或者更加安全（HTTP(S)→HTTPS），则发送 origin；<br />如果请求目标更加不安全（HTTPS→HTTP），则不发送 referrer。</td>
</tr>
<tr>
<td align="left">unsafe-URL</td>
<td align="left">对同源请求和跨源请求发送完整 URL（不含 URL 参数）。</td>
</tr>
</tbody></table>
</li>
<li><blockquote>
<p>  备注：<br>  动态插入 &lt;meta name=”referrer”&gt;（使用 document.write() 方法或者 appendChild() 等方法）会使 referrer 行为变得不可预测。<br>  如果定义了互相冲突的策略，则会转而使用 no-referrer 策略。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>  theme-color：表示当前页面的建议颜色，在自定义当前页面从或页面周围的用户界面的显示时，用户代理应当使用此颜色。content 属性应当包含一个有效的 CSS &lt;color&gt; 值。</p>
</li>
</ul>
</li>
<li><p>CSS 颜色调整规范定义的元数据名称</p>
<ul>
<li><p><code>color-scheme</code>: 指定与当前文档兼容的一种或多种配色方案。</p>
<p>  浏览器将优先采用此元数据的值，然后再使用用户的浏览器或设备设置，来确定页面上的各种默认颜色和元素外观，例如背景色、前景色、窗体控件和滚动条。<code>&lt;meta name=&quot;color-scheme&quot;&gt;</code> 的主要用途是指示当前页面与浅色模式和深色模式的兼容性，以及选用这两种模式时的优先顺序。</p>
<p>  <code>color-scheme</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content"><code>content</code></a> 属性的值应当为以下值中的一个：</p>
<ul>
<li><p><code>normal</code></p>
<p>  该文档未指定（unaware of）配色方案，应当仅使用默认配色进行渲染。</p>
</li>
<li><p>[<code>light</code> | <code>dark</code>]+</p>
<p>  文档所支持的一种或多种配色方案。如果多次指定同一个配色方案，则与仅指定一次效果相同。如果指定了多种配色方案，则表示文档优先选择第一种方案——如果用户更倾向于选择第二种配色方案，则可以接受第二种。</p>
</li>
<li><p><code>only light</code></p>
<p>  表示文档<em>仅</em>支持浅色模式，也就是浅色背景色和深色前景色。按照规范，<code>only dark</code> <em>是无效的</em>。如果在文档不支持深色模式的情况下强迫其以深色模式进行渲染，会导致内容不可读。所以，在未经配置的情况下，所有主要浏览器均默认使用浅色模式。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CSS 设备适配规范定义的元数据名称</p>
<ul>
<li><p><code>viewport</code>: 为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport">viewport</a>（视口）的初始大小提供指示（hint）。目前仅用于移动设备。</p>
<ul>
<li><p>  &lt;meta name=”viewport”&gt; 的 content 属性的值</p>
</li>
<li><table>
<thead>
<tr>
<th>值</th>
<th>可能附加的值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>一个正整数，或者字符串 <code>device-width</code></td>
<td>定义 viewport 的宽度，如果值为正整数，则单位为像素。</td>
</tr>
<tr>
<td>height</td>
<td>一个正整数，或者字符串 <code>device-height</code></td>
<td>定义 viewport 的高度。未被任何浏览器使用。</td>
</tr>
<tr>
<td>initial-scale</td>
<td>一个 <code>0.0</code> 和 <code>10.0</code> 之间的正数</td>
<td>定义设备宽度（宽度和高度中更小的那个：如果是纵向屏幕，就是 <code>device-width</code>，如果是横向屏幕，就是 <code>device-height</code>）与 viewport 大小之间的缩放比例。</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>一个 <code>0.0</code> 和 <code>10.0</code> 之间的正数</td>
<td>定义缩放的最大值，必须大于等于 <code>minimum-scale</code>，否则表现将不可预测。<br />浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>一个 <code>0.0</code> 和 <code>10.0</code> 之间的正数</td>
<td>定义缩放的最小值，必须小于等于 <code>maximum-scale</code>，否则表现将不可预测。<br />浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。</td>
</tr>
<tr>
<td>user-scalable</td>
<td><code>yes</code> 或者 <code>no</code></td>
<td>默认为 <code>yes</code>，如果设置为 <code>no</code>，用户将无法缩放当前页面。<br />浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。</td>
</tr>
<tr>
<td>viewport-fit</td>
<td><code>auto</code>、<code>contain</code> 或者 <code>cover</code></td>
<td>该<code>auto</code>值不影响初始布局视口，整个网页都是可见的。<br />该<code>contain</code>值表示视口被缩放以适应显示中内接的最大矩形。<br />该<code>cover</code>值意味着缩放视口以填充设备显示。强烈建议使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/env()">安全区域插入</a>变量来确保重要内容不会出现在显示之外。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>其它元数据名称</p>
<ul>
<li><p>  <code>creator</code>：当前文档的创建者，例如某个组织或者机构。如果有不止一个创建者，则应当使用多个名称为 <code>creator</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">``</a> 元素。（而不是像关键词一样使用逗号分隔：关键词不应包含逗号，但创建者名称可能含有逗号。）</p>
</li>
<li><p>  <code>googlebot</code>：<code>robots</code> 的替代名称，只被 Googlebot（Google 的网页爬虫/索引搜寻器）使用。</p>
</li>
<li><p>  <code>publisher</code>：当前文档的发布者/出版者。</p>
</li>
<li><p><code>robots</code>：爬虫、协作搜寻器，或者“机器人”，对此页面的处理行为，或者说，应当遵守的规则。是一个使用逗号分隔的、由下列值构成的列表：</p>
<ul>
<li><p>  &lt;meta name=”robots”&gt; 的 content 属性的值</p>
</li>
<li><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>被用于</th>
</tr>
</thead>
<tbody><tr>
<td><code>index</code></td>
<td>允许机器人索引此页面（默认）。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>noindex</code></td>
<td>要求机器人不索引此页面。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>follow</code></td>
<td>允许机器人跟随此页面上的链接（默认）。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>nofollow</code></td>
<td>要求机器人不跟随此页面上的链接。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>all</code></td>
<td>与 <code>index, follow</code> 等价</td>
<td><a href="https://support.google.com/webmasters/answer/79812">谷歌</a></td>
</tr>
<tr>
<td><code>none</code></td>
<td>与 <code>noindex, nofollow</code> 等价</td>
<td><a href="https://support.google.com/webmasters/answer/79812">谷歌</a></td>
</tr>
<tr>
<td><code>noarchive</code></td>
<td>要求搜索引擎不缓存页面内容。</td>
<td><a href="https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives">谷歌</a>、<a href="https://help.yahoo.com/kb/search-for-desktop/SLN2213.html">雅虎</a>、<a href="https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240">Bing</a></td>
</tr>
<tr>
<td><code>nosnippet</code></td>
<td>防止在搜索引擎结果中显示页面的任何描述。</td>
<td><a href="https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives">谷歌</a>、<a href="https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240">Bing</a></td>
</tr>
<tr>
<td><code>noimageindex</code></td>
<td>要求此页面不显示为索引图像的引用页面。</td>
<td><a href="https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives">谷歌</a></td>
</tr>
<tr>
<td><code>nocache</code></td>
<td><code>noarchive</code> 的替代名称。</td>
<td><a href="https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240">Bing</a></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h2><p><strong>1.新的 DOCTYPE 和字符集</strong></p>
<ul>
<li><p>HTML4</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>HTML5</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 语义化标签</strong></p>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">address</td>
<td align="center">表示文档或article的联系信息</td>
</tr>
<tr>
<td align="center">article</td>
<td align="center">表示一段独立的内容</td>
</tr>
<tr>
<td align="center">aside</td>
<td align="center">表示与周边内容稍有牵涉的内容，相关内容或引文</td>
</tr>
<tr>
<td align="center">details</td>
<td align="center">生成一个区域，用户将其展开可以获得更多细节知识</td>
</tr>
<tr>
<td align="center">footer</td>
<td align="center">表示尾部</td>
</tr>
<tr>
<td align="center">header</td>
<td align="center">表示首部</td>
</tr>
<tr>
<td align="center">hgroup</td>
<td align="center">将一组标题组织在一起，以便文档大纲只显示其中第一个标题</td>
</tr>
<tr>
<td align="center">nav</td>
<td align="center">表示有意集中在一起的导航元素</td>
</tr>
<tr>
<td align="center">section</td>
<td align="center">表示一个重要的概念或主题</td>
</tr>
<tr>
<td align="center">summary</td>
<td align="center">用在 details 元素中，表示该元素内容的标题或说明</td>
</tr>
</tbody></table>
<p><strong>3. 媒体标签</strong></p>
<ol>
<li><p>audio：在网页里嵌入音频内容</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">autoplay</td>
<td align="center">如果存在，此属性会使浏览器尽可能立刻开始播放视频</td>
</tr>
<tr>
<td align="center">preload</td>
<td align="center">告诉浏览器是否要预先载入视频<br />none：用户开始播放之前不会载入视频<br />metadata：用户开始播放之前只能载入视频的元数据（音频长度和其它此类信息）<br />auto：请求浏览器尽快下载整个视频。浏览器可以忽略这个请求。这是默认行为</td>
</tr>
<tr>
<td align="center">controls</td>
<td align="center">除非此属性存在，否则浏览器不会显示播放控件</td>
</tr>
<tr>
<td align="center">loop</td>
<td align="center">如果存在，此属性会让浏览器反复播放视频</td>
</tr>
<tr>
<td align="center">muted</td>
<td align="center">如果此属性存在，视频从一开始就会处于静音状态</td>
</tr>
<tr>
<td align="center">src</td>
<td align="center">指定要显示的视频</td>
</tr>
</tbody></table>
</li>
<li><p>video：在网页里嵌入视频内容</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">poster</span>=<span class="string">&#x27;imgs/aa.jpg&#x27;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">autoplay</td>
<td align="center">如果存在，此属性会使浏览器尽可能立刻开始播放视频</td>
</tr>
<tr>
<td align="center">preload</td>
<td align="center">告诉浏览器是否要预先载入视频<br />none：用户开始播放之前不会载入视频<br />metadata：用户开始播放之前只能载入视频的元数据（宽度、高度、第一帧、长度和其它此类信息）<br />auto：请求浏览器尽快下载整个视频。浏览器可以忽略这个请求。这是默认行为</td>
</tr>
<tr>
<td align="center">controls</td>
<td align="center">除非此属性存在，否则浏览器不会显示播放控件</td>
</tr>
<tr>
<td align="center">loop</td>
<td align="center">如果存在，此属性会让浏览器反复播放视频</td>
</tr>
<tr>
<td align="center">poster</td>
<td align="center">指定在视频数据载入时显示的图片</td>
</tr>
<tr>
<td align="center">height</td>
<td align="center">指定视频的高度</td>
</tr>
<tr>
<td align="center">width</td>
<td align="center">指定视频的宽度</td>
</tr>
<tr>
<td align="center">muted</td>
<td align="center">如果此属性存在，视频从一开始就会处于静音状态</td>
</tr>
<tr>
<td align="center">src</td>
<td align="center">指定要显示的视频</td>
</tr>
</tbody></table>
</li>
<li><p>source：因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p>
<p> 浏览器重点支持的视频格式：</p>
<table>
<thead>
<tr>
<th align="center">格式</th>
<th align="center">说明</th>
<th align="center">支持</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WebM</td>
<td align="center">此格式由谷歌提供支持，目标是创建一个无专利约束，免版税的格式</td>
<td align="center">Opera、Chrome、Firefox</td>
</tr>
<tr>
<td align="center">Ogg/Theora</td>
<td align="center">Ogg Theora 是一种开放、免版税和无专利约束的格式</td>
<td align="center">Opera、Chrome、Firefox</td>
</tr>
<tr>
<td align="center">MP4/H.264</td>
<td align="center">暂无</td>
<td align="center">IE、Chrome、Safari</td>
</tr>
</tbody></table>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;images/s1.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;images/s1.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;images/s1.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>track：提供了一套视频相关内容的实现机制。这些内容包括字幕、说明和章节标题。</p>
<p> MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track</a></p>
</li>
</ol>
<p><strong>4. 表单</strong></p>
<p><strong>表单类型：</strong></p>
<ul>
<li>  email ：能够验证当前输入的邮箱地址是否合法</li>
<li>  url ： 验证URL</li>
<li>  tel：验证电话号码</li>
<li>  number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li>
<li>  search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li>
<li>  range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li>
<li>  color ： 提供了一个颜色拾取器</li>
<li>  time ： 时分秒</li>
<li>  data ： 日期选择年月日</li>
<li>  datatime ： 时间和日期(目前只有Safari支持)</li>
<li>  datatime-local ：日期时间控件</li>
<li>  week ：周控件</li>
<li>  month：月控件</li>
</ul>
<p><strong>表单属性：</strong></p>
<ul>
<li>  placeholder ：提示信息</li>
<li>  autofocus ：自动获取焦点</li>
<li>autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：<ul>
<li>  表单必须提交过</li>
<li>  必须有name属性。</li>
</ul>
</li>
<li>  required：要求输入框不能为空，必须有值才能够提交。</li>
<li>  pattern=” “ 里面写入想要的正则模式，例如手机号patte=”^(+86)?\d{10}$”</li>
<li>  multiple：可以选择多个文件或者多个邮箱</li>
<li>  form=” form表单的ID”</li>
<li>  novalidate 不经输入验证就能提交表单</li>
</ul>
<p><strong>表单事件：</strong></p>
<ul>
<li>  oninput 每当input里的输入框内容发生变化都会触发此事件。</li>
<li>  oninvalid 当验证不通过时触发此事件。</li>
</ul>
<p><strong>附：</strong></p>
<p><img src="/2021/11/24/html/01-6.png" alt="01-6"></p>
<p><strong>5. 进度条、度量器</strong></p>
<ul>
<li>  progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</li>
<li>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）<ul>
<li>  high/low：规定被视作高/低的范围</li>
<li>  max/min：规定最大/小值</li>
<li>  value：规定当前度量值</li>
</ul>
</li>
</ul>
<p>设置规则：min &lt; low &lt; high &lt; max</p>
<p><strong>6.DOM查询操作</strong></p>
<ul>
<li>  document.querySelector()</li>
<li>  document.querySelectorAll()</li>
</ul>
<p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p>
<p><strong>7. Web存储</strong></p>
<p>HTML5 提供了两种在客户端存储数据的新方法：</p>
<ul>
<li>  localStorage - 没有时间限制的数据存储</li>
<li>  sessionStorage - 针对一个 session 的数据存储</li>
</ul>
<p><strong>8. 其他</strong></p>
<ul>
<li>  拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li>
<li>  Geolocation API（地理定位）用于定位用户的位置。</li>
<li>  WebSockets</li>
<li>  Web Workers</li>
<li>  Web Storage API</li>
<li>  Communication API</li>
<li>  History API</li>
</ul>
<p><strong>总结(不全，还没改)：</strong> （1）新增语义化标签：nav、header、footer、aside、section、article （2）音频、视频标签：audio、video （3）数据存储：localStorage、sessionStorage （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） （5）input标签新增属性：placeholder、autocomplete、autofocus、required （6）history API：go、forward、back、pushstate</p>
<p><strong>移除的元素有(<a href="https://html.spec.whatwg.org/multipage/obsolete.html)%EF%BC%9A">https://html.spec.whatwg.org/multipage/obsolete.html)：</a></strong></p>
<ul>
<li>  纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li>
<li>  对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<h2 id="7-img的srcset属性的作⽤？"><a href="#7-img的srcset属性的作⽤？" class="headerlink" title="7. img的srcset属性的作⽤？"></a>7. img的srcset属性的作⽤？</h2><p>H5中img有两个新属性，<code>srcset</code>和<code>sizes</code>，主要作用：</p>
<ul>
<li>  控制响应式图片，根据屏幕大小来选择显示不同图片</li>
<li>  根据屏幕的不同（视网膜屏幕还是普通屏），展示不同质量的图片，合理控制下载资源，以及带给用户高质量享受。</li>
</ul>
<p><strong>srcset：</strong></p>
<ol>
<li><p>格式一：图片源地址 空格 图片像素宽度[，图片源地址 空格 图片像素宽度，…]，如</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">srcset=&quot;1.jpg 580w, 2.png 618w&quot;</span><br></pre></td></tr></table></figure>

<p> 表示图片<code>1.jpg</code>的像素宽度为<code>580px</code>，图片<code>2.png</code>的像素宽度为<code>618px</code>，两个图片源之间用逗号隔开。</p>
<p> <strong>千万注意：描述图片的像素宽度是用’w’单位，且一定要是图片的真实像素宽度，如果私自改动，那么会影响浏览器对图片的选择！</strong><del>这里的以 w 后缀的值并不是 “真实” 大小，它只是对浏览器的一个提示，大致等于图片的 “CSS像素” 大小。</del></p>
<p> 其实上述例子类似给了个默认的<code>sizes</code>属性（具体下面再讲）</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">srcset=&quot;1.jpg 580w, 2.png 618w&quot; sizes=&quot;100vw&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>格式二：图片源地址 空格 屏幕像素密度[, 图片源地址 空格 屏幕像素密度, …]，如</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">srcset=&quot;1.jpg 1x, 2.png 2x&quot;</span><br></pre></td></tr></table></figure>

<p> 表示图片<code>1.jpg</code>为DPR（**DPR = 设备像素 / CSS像素(某一方向上)**）为1时下显示的图片；<code>2.png</code>为DPR为2时显示的图片，如果没有更大的DPR设置的图片源，那么当大于当前设置的DPR最高值时，会采用当前设置的最大DPR的图片源。如这里如果屏幕DPR为3，那么还是会用<code>2.png</code>。</p>
</li>
<li><p> 小结：在浏览器支持<code>srcset</code>的情况下，<code>src</code>值就成为了一个<code>1x</code>情况下的候选图片，在没有符合条件的情况下，会采用该值。</p>
</li>
</ol>
<p><strong>sizes：</strong>只有当设置了<code>srcset</code>，且单位为<code>w</code>时，<code>sizes</code>的设置才会起效。浏览器先根据<code>sizes</code>设定的条件下，找出此刻图片显示的宽度，然后根据这个宽度去<code>srcset</code>里找符合条件的图片。</p>
<ul>
<li><p>浏览器的选取规则</p>
<ul>
<li>  srcset中设置的图片像素宽度（’w’的值），组成了相应的半开半闭区间(a, b]。 图片的显示宽度（sizes规定的值）看落在哪个区间内，取区间中最大值对应的图片。若没有最大值（如∞），则取上个区间最大值。</li>
<li>如<code>&lt;img src=&quot;4.jpg&quot; srcset=&quot;3.jpg 229w,2.png 618w,1.jpg 1000w&quot;, sizes=&quot;300px&quot;&gt;</code><ul>
<li>  上面设置图片要显示成<code>300px</code>（<code>sizes</code>里的值），在<code>srcset</code>里的几个临界值中形成了<code>(0, 229px]</code>、<code>(229px, 618px]</code>、<code>(618px, 1000px]</code>、<code>(1000px, ∞]</code>。<code>300px</code>落在了<code>(229px, 618px]</code>中，取最大值<code>618</code>，因此最终选择的图片就是<code>2.png</code></li>
<li>  如果<code>sizes</code>改成<code>1200px</code>，按照上述规则，最终会选取<code>1000w</code>的<code>1.jpg</code></li>
<li>  注意：srcset里的顺序不重要，不会受到影响。</li>
</ul>
</li>
</ul>
</li>
<li><p>sizes 的语法结构</p>
<ul>
<li><p>[媒体查询 空格 ]图片显示宽度[, [媒体查询 空格 ]图片显示宽], …, 其余条件宽度值]</p>
<p>  图片的宽度值单位不能为<code>%</code>，其余正常单位可以使用</p>
</li>
<li><p>举例：<code>sizes=&quot;(max-width: 500px) 400px, (max-width: 900px) 700px, 1200px&quot;</code></p>
<ul>
<li>  上面的意思就是，在屏幕小于等于500px情况下，图片显示成400px宽；在屏幕小于等于900px情况下，图片显示成700px宽；其余情况显示成1200px宽。</li>
<li>  因此，可根据这种<code>sizes</code>值，判断在哪个屏幕大小下显示什么宽度的图片，然后根据这个宽度值去<code>srcset</code>里找满足条件的图片源。</li>
</ul>
</li>
<li><p>所以下面这个例子：<code>&lt;img src=&quot;4.jpg&quot; srcset=&quot;3.jpg 229w,2.png 618w,1.jpg 1000w&quot;, sizes=&quot;(max-width: 500px) 400px, (max-width: 900px) 700px, 1200px&quot;&gt;</code></p>
<ul>
<li>  在屏幕小于等于500px情况下，图片显示成400px宽，选取<code>2.png</code>；在屏幕小于等于900px情况下，图片显示成700px宽，选取<code>1.jpg</code>；其余情况显示成1200px宽，还是选取<code>1.jpg</code>。</li>
<li>  注意：sizes里的媒体查询条件顺序是很重要的，只要满足了越靠前的某个条件，那么后面的条件会被忽略的</li>
</ul>
</li>
</ul>
</li>
<li><p>如果<code>sizes</code>属性没有值，或者在有媒体条件下，其余条件宽度没有设值，那么默认是<code>100vw</code></p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;100vw&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span>, <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 500px) 400px&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span>, <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 500px) 400px, 100vw&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  这种时候，就是直接根据屏幕的宽度来决定选取哪个图片源了。</p>
</li>
</ul>
<p><strong>DPR的影响</strong></p>
<p>上述内容，都是在DPR为1的情况下说明的，主要针对PC端吧。那如果是手机端，DPR不单单是1，还有2，3的情况。这时候其实上述内容的规则还是不会变的，但是我们需要做一些值的转化才能套用上述规则。这里主要是说’w’的情况下浏览器如何去选择</p>
<p>例如：<code>&lt;img src=&quot;4.jpg&quot; srcset=&quot;3.jpg 229w,2.png 618w&quot; sizes=&quot;(max-width: 600px) 114px&quot;&gt;</code></p>
<p>首先我们要知道，srcset里的’w’符号，是代表的是图像的宽度像素，是个物理像素；sizes里的114px是表示逻辑像素！</p>
<p>而浏览器对图片的选择，是要转化为同一概念上的像素才能进行对比的，总不能拿着逻辑像素值去物理像素区间里做比较吧？</p>
<p>因此，在DPR不为1时，要转化一下像素值才能去区间里比较，套用上述规则。</p>
<p>如在DPR=2时，把114px转化为物理像素，即114px * 2 = 228px，用228px去(0, 229px]、(229px, 618px]、(618px, ∞]里做比较，落在了(0, 229px]中，取229px对应的3.jpg</p>
<h2 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><ul>
<li>  行内元素有：<code>a b span img input select strong</code>；</li>
<li>  块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li>
</ul>
<p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p>
<ul>
<li>  常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li>
<li>  鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li>
</ul>
<h2 id="9-说一下-web-worker"><a href="#9-说一下-web-worker" class="headerlink" title="9. 说一下 web worker"></a>9. 说一下 web worker</h2><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。web worker 是运行在后台的 js，独立于其他脚本，通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>
<p>在 Web Workers 中执行的脚本不能访问 Web 页面和 DOM API，虽然不会导致浏览器 UI 停止响应，但是仍然会消耗 CPU 周期，导致系统反应变慢。 </p>
<p>如何创建 web worker：</p>
<ol>
<li> 检测浏览器对于 web worker 的支持性</li>
<li> 创建 web worker 文件（js，回传函数等）</li>
<li> 创建 web worker 对象</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Workers<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Worker<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;support&quot;</span>&gt;</span>not support<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;stopButton&quot;</span>&gt;</span>Stop Task<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;helloButton&quot;</span>&gt;</span>Post a Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">stopWorker</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  worker.terminate()</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">messageHandler</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(e.data)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.warn(e.message, e)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">loadDemo</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (Worker) !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;support&quot;</span>).innerHTML = <span class="string">&quot;support&quot;</span></span></span><br><span class="line"><span class="javascript">    worker = <span class="keyword">new</span> Worker(<span class="string">&quot;echoWorker.js&quot;</span>)</span></span><br><span class="line"><span class="javascript">    worker.addEventListener(<span class="string">&quot;message&quot;</span>, messageHandler, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">    worker.addEventListener(<span class="string">&quot;error&quot;</span>, errorHandler, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;helloButton&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      worker.postMessage(<span class="string">&quot;for you&quot;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;stopButton&quot;</span>).onclick = stopWorker</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, loadDemo, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">messageHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  postMessage(<span class="string">&quot;say: &quot;</span> + e.data)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">&quot;message&quot;</span>, messageHandler, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h2 id="10-HTML5的离线缓存怎么使用，它的工作原理是什么"><a href="#10-HTML5的离线缓存怎么使用，它的工作原理是什么" class="headerlink" title="10. HTML5的离线缓存怎么使用，它的工作原理是什么"></a>10. HTML5的离线缓存怎么使用，它的工作原理是什么</h2><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>
<p><strong>原理：</strong>HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>
<p><strong>使用方法：</strong> （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">manifest</span>=<span class="string">&quot;index.manifest&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js/app.js</span><br><span class="line">    css/style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse/logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    / /offline.html</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>
<li>  <strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li>
<li>  <strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>
</ul>
<p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p>
<p><strong>如何更新缓存：</strong></p>
<p>（1）更新 manifest 文件</p>
<p>（2）通过 javascript 操作</p>
<p>（3）清除浏览器缓存</p>
<p><strong>注意事项：</strong></p>
<p>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p>
<p>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p>
<p>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p>
<p>（4）FALLBACK 中的资源必须和 manifest 文件同源。</p>
<p>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p>
<p>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p>
<p>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>
<h2 id="11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？"><a href="#11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？" class="headerlink" title="11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？"></a>11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h2><ul>
<li>  <strong>在线的情况下</strong>，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li>
<li>  <strong>离线的情况下</strong>，浏览器会直接使用离线存储的资源。</li>
</ul>
<h2 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h2><ul>
<li>title与h1的区别<ul>
<li>定义：<ul>
<li>  title是网站标题，一个页面只能有一个</li>
<li>  h1是文章主题</li>
</ul>
</li>
<li>作用：<ul>
<li>  title概括网站信息，可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的，是显示在网页Tab栏里的；</li>
<li>  h1突出文章主题，面对用户，更突出其视觉效果，指向页面主体信息，是显示在网页中的。</li>
</ul>
</li>
<li>注意：<ul>
<li>  如果title为空，但是页面存在h1,b,strong标签，搜索引擎会默认页面title为h1内的内容，所以得出结论h1是在没有外界干扰下除title以外第二个能强调页面主旨的标记，在一个页面中应该使用且只使用一次h1标记。</li>
</ul>
</li>
</ul>
</li>
<li>b与strong的区别<ul>
<li>定义：<ul>
<li>  b(bold)是实体标签，用来给文字加粗</li>
<li>  strong是逻辑标签，作用是加强字符语气</li>
</ul>
</li>
<li>区别：<ul>
<li>  b标签只是加粗的样式，没有实际含义，常用来表达无强调或着中意味的粗体文字</li>
<li>  strong表示标签内字符重要，用以强调，其默认格式是加粗，但是可以通过css添加样式，使用别的样式强调</li>
<li>  建议：为了符合css3的规范语义化，b应尽量少用而改用strong</li>
</ul>
</li>
</ul>
</li>
<li>i与em的区别<ul>
<li>定义：<ul>
<li>  i(italic)是实体标签，用来使字符倾斜</li>
<li>  em(emphasis)是逻辑标签，作用是强调文本内容</li>
</ul>
</li>
<li>区别：<ul>
<li>  i标签只是斜体的样式，没有实际含义，常用来表达无强调或着重意味的斜体，比如生物学名、术语、外来语；</li>
<li>  em表示标签内字符重要，用以强调，其默认格式是斜体，但是可以通过CSS添加样式。</li>
<li>  建议：为了符合CSS3的规 范，i应尽量少用而改用em</li>
</ul>
</li>
</ul>
</li>
<li>tips:<ul>
<li>  物理元素是告诉浏览器我应该以何种格式显示文字，逻辑元素告诉浏览器这些文字有怎么样的重要性。</li>
<li>  对于搜索引擎来说em和strong比i和b要重视的多。</li>
</ul>
</li>
</ul>
<h2 id="13-iframe-有那些优点和缺点？"><a href="#13-iframe-有那些优点和缺点？" class="headerlink" title="13. iframe 有那些优点和缺点？"></a>13. iframe 有那些优点和缺点？</h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">allow</td>
<td align="left">用于为<code>&lt;iframe&gt;</code>指定其<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Feature_Policy">特征策略</a>.</td>
</tr>
<tr>
<td align="left">allowfullscreen</td>
<td align="left">设置为<code>true</code>时，可以通过调用 <code>&lt;iframe&gt;</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/requestFullScreen"><code>requestFullscreen()</code></a> 方法激活全屏模式。<br />这是一个历史遗留属性，已经被重新定义为 <code>allow=&quot;fullscreen&quot;</code>。</td>
</tr>
<tr>
<td align="left">allowpaymentrequest</td>
<td align="left">设置为<code>true</code>时，跨域的 <code>&lt;iframe&gt;</code> 就可以调用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API">Payment Request API</a>。<br />这是一个历史遗留属性，已经被重新定义为 <code>allow=&quot;payment&quot;</code>.</td>
</tr>
<tr>
<td align="left">csp</td>
<td align="left">对嵌入的资源配置<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">内容安全策略</a>。</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left">以CSS像素格式<a href="https://developer.mozilla.org/zh-CN/docs/HTML/HTML5">HTML5</a>，或像素格式HTML 4.01，或百分比格式指定frame的高度。默认值为<code>150</code>。</td>
</tr>
<tr>
<td align="left">importance</td>
<td align="left">表示 <code>&lt;iframe&gt; </code>的 <code>src</code> 属性指定的资源的加载优先级。允许的值有：<br /><code>auto</code> (default)：不指定优先级。浏览器根据自身情况决定资源的加载顺序<br /><code>high</code>：资源的加载优先级较高<br /><code>low</code>：资源的加载优先级较低</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">用于定位嵌入的浏览上下文的名称。该名称可以用作 &lt;a&gt; 标签与 &lt;form&gt; 标签的 target 属性值，也可以用作 &lt;input&gt; 标签和 &lt;button&gt; 标签的 formtarget 属性值，还可以用作 window.open() 方法的 windowName 参数值。</td>
</tr>
<tr>
<td align="left">referrerpolicy</td>
<td align="left">表示在获取 iframe 资源时如何发送 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/referrer">referrer</a> 首部：<br /><code>no-referrer</code>: 不发送 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 首部。<br /><code>no-referrer-when-downgrade</code> (default): 向不受 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/TLS">TLS</a> (<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/https">HTTPS</a>) 保护的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a> 发送请求时，不发送 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 首部。<br /><code>origin</code>: referrer 首部中仅包含来源页面的源。换言之，仅包含来源页面的 <a href="https://developer.mozilla.org/en-US/docs/Archive/Mozilla/URIScheme">scheme</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">host</a>, 以及 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port (en-US)</a>。<br /><code>origin-when-cross-origin</code>: 发起跨域请求时，仅在 referrer 中包含来源页面的源。发起同源请求时，仍然会在 referrer 中包含来源页面在服务器上的路径信息。<br /><code>same-origin</code>: 对于 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Same-origin_policy">same origin</a> （同源）请求，发送 referrer 首部，否则不发送。<br /><code>strict-origin</code>: 仅当被请求页面和来源页面具有相同的协议安全等级时才发送 referrer 首部（比如从采用 HTTPS 协议的页面请求另一个采用 HTTPS 协议的页面）。如果被请求页面的协议安全等级较低，则不会发送 referrer 首部（比如从采用 HTTPS 协议的页面请求采用 HTTP 协议的页面）。<br /><code>strict-origin-when-cross-origin</code>: 当发起同源请求时，在 referrer 首部中包含完整的 URL。当被请求页面与来源页面不同源但是有相同协议安全等级时（比如 HTTPS→HTTPS），在 referrer 首部中仅包含来源页面的源。当被请求页面的协议安全等级较低时（比如 HTTPS→HTTP），不发送 referrer 首部。<br /><code>unsafe-url</code>: 始终在 referrer 首部中包含源以及路径 （但不包括 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash">fragment</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/password">密码</a>，或<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/username">用户名</a>）。<strong>这个值是不安全的</strong>, 因为这样做会暴露受 TLS 保护的资源的源和路径信息。</td>
</tr>
<tr>
<td align="left">sandbox</td>
<td align="left">该属性对呈现在 iframe 框架中的内容启用一些额外的限制条件。属性值可以为空字符串（这种情况下会启用所有限制），也可以是用空格分隔的一系列指定的字符串。有效的值有：<br /> <code>allow-downloads-without-user-activation</code> : 允许在没有征求用户同意的情况下下载文件.<br /> <code>allow-forms</code>: 允许嵌入的浏览上下文提交表单。如果没有使用该关键字，则无法提交表单。<br /> <code>allow-modals</code>: 允许嵌入的浏览上下文打开模态窗口。 <br /><code>allow-orientation-lock</code>: 允许嵌入的浏览上下文锁定屏幕方向（译者注：比如智能手机、平板电脑的水平朝向或垂直朝向）。<br /> <code>allow-pointer-lock</code>: 允许嵌入的浏览上下文使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Pointer_Lock_API">Pointer Lock API</a>.<br /> <code>allow-popups</code>: 允许弹窗 (例如 window.open, target=”_blank”, <code>showModalDialog</code>)。如果没有使用该关键字，相应的功能将自动被禁用。 <br /><code>allow-popups-to-escape-sandbox</code>:  允许沙箱化的文档打开新窗口，并且新窗口不会继承沙箱标记。例如，安全地沙箱化一个广告页面，而不会在广告链接到的新页面中启用相同的限制条件。<br /> <code>allow-presentation</code>: 允许嵌入的浏览上下文开始一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/PresentationRequest"> presentation session</a>。 <br /><code>allow-same-origin</code>: 如果没有使用该关键字，嵌入的浏览上下文将被视为来自一个独立的源，这将使 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Same-origin_policy">same-origin policy</a> 同源检查失败。<br /> <code>allow-scripts</code>: 允许嵌入的浏览上下文运行脚本（但不能创建弹窗）。如果没有使用该关键字，就无法运行脚本。 <br /><code>allow-storage-access-by-user-activation</code> : 允许嵌入的浏览上下文通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage_Access_API">Storage Access API</a> 使用父级浏览上下文的存储功能。<br /> <code>allow-top-navigation</code>: 允许嵌入的浏览上下文导航（加载）内容到顶级的浏览上下文。<br /> <code>allow-top-navigation-by-user-activation</code>: 允许嵌入的浏览上下文<strong>在经过用户允许后</strong>导航（加载）内容到顶级的浏览上下文。</td>
</tr>
<tr>
<td align="left">src</td>
<td align="left">被嵌套的页面的 URL 地址。使用 <code>about:blank</code> 值可以嵌入一个遵从<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>的空白页。在 Firefox （version 65及更高版本）、基于 Chromium 的浏览器、Safari/iOS 中使用代码移除 <code>iframe</code> 的 <code>src</code> 属性（例如通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/removeAttribute"><code>Element.removeAttribute()</code></a> ）会导致 <code>about:blank</code> 被载入 frame。</td>
</tr>
<tr>
<td align="left">srcdoc</td>
<td align="left">该属性是一段HTML代码，这些代码会被渲染到 iframe 中。如果浏览器不支持 <code>srcdoc</code> 属性，则会渲染 <code>src</code> 属性表示的内容。</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left">以CSS像素格式<a href="https://developer.mozilla.org/zh-CN/docs/HTML/HTML5">HTML5</a>，或以像素格式HTML 4.01，或以百分比格式指定的 frame 的宽度。默认值是<code>300</code>。</td>
</tr>
</tbody></table>
<p><strong>优点：</strong></p>
<ul>
<li>  用来加载速度较慢的内容（如广告）</li>
<li>  可以使脚本可以并行下载</li>
<li>  可以实现跨子域通信</li>
<li>  如果有多个网页引用iframe，那么只需要修改iframe的内容，就可以实现调用每一个页面的更改，方便快捷。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  iframe 会阻塞主页面的 onload 事件</li>
<li>  代码复杂，无法被一些搜索引擎索引到，搜索引擎爬虫还不能很好的处理iframe中的内容，所以不利于搜索引擎优化。</li>
<li>  会产生很多页面，不容易管理</li>
<li>  很多移动设备无法完全显示框架，设备兼容性差</li>
<li>  iframe框架页面会增加服务器的http请求，对于大型网站是不可取的</li>
</ul>
<h2 id="14-label-的作用是什么？如何使用？"><a href="#14-label-的作用是什么？如何使用？" class="headerlink" title="14. label 的作用是什么？如何使用？"></a>14. label 的作用是什么？如何使用？</h2><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>
<ul>
<li>  使用方法1：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mobile&quot;</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mobile&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  使用方法2：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h2><p><strong>（1）SVG：</strong> SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p>
<p>其特点如下：</p>
<ul>
<li>  不依赖分辨率</li>
<li>  支持事件处理器</li>
<li>  最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
<li>  复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>
<li>  不适合游戏应用</li>
</ul>
<p><strong>（2）Canvas：</strong> Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p>
<p>其特点如下：</p>
<ul>
<li>  依赖分辨率</li>
<li>  不支持事件处理器</li>
<li>  弱的文本渲染能力</li>
<li>  能够以 .png 或 .jpg 格式保存结果图像</li>
<li>  最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>
</ul>
<p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p>
<h2 id="16-head-标签有什么作用，其中什么标签必不可少？"><a href="#16-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="16. head 标签有什么作用，其中什么标签必不可少？"></a>16. head 标签有什么作用，其中什么标签必不可少？</h2><p>标签用于定义文档的头部，它是所有头部元素的容器。 标签中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p>
<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>
<p>下面这些标签可用在 head 部分：<code>&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;&lt;noscript&gt;</code>。</p>
<p><strong>经过测试，好像没有必需的标签</strong></p>
<table>
<thead>
<tr>
<th>元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;title&gt;</td>
<td align="left">定义文档的标题，显示在浏览器的标题栏或标签页上，一般会完整地概括整个网页的内容</td>
</tr>
<tr>
<td>&lt;base&gt;</td>
<td align="left">指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个 &lt;base&gt; 元素。</td>
</tr>
<tr>
<td>&lt;link&gt;</td>
<td align="left">规定外部资源与当前文档的关系，常用于链接样式表：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;xxx.css&quot; type=&quot;text/css&quot;&gt;</code><br />还有其它作用：<br />1. 用于 SEO ，主要是给搜索引擎看的：<code>&lt;link rel=&quot;canonical&quot; href=&quot;...&quot;&gt;</code><br />2. 提供 rss 订阅：<code>&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;...&quot;&gt;</code><br />3. 表示页面 icon ：<code>&lt;link rel=&quot;icon&quot; href=&quot;https://xxx.png&quot;&gt;</code><br />4. 对页面提供预处理：<code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//xxx.com&quot;&gt;</code>，提前对一个域名做 dns 查询。强制对域名进行预读取在有的情况下很有用。比如, 在网站的主页上，强制在整个网站上对频繁引用的域名做预解析处理，即使它们不在主页本身上使用。虽然主页的性能可能不受影响，但是会提高站点整体性能。</td>
</tr>
<tr>
<td>&lt;style&gt;</td>
<td align="left">包含文档的样式信息。</td>
</tr>
<tr>
<td>&lt;meta&gt;</td>
<td align="left">一种通用的元数据信息表示标签。见上述5</td>
</tr>
<tr>
<td>&lt;script&gt;</td>
<td align="left">用于嵌入或引用可执行脚本。见上述4</td>
</tr>
<tr>
<td>&lt;noscript&gt;</td>
<td align="left">如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在此中定义脚本未被执行时的替代内容。可以包含除&lt;script&gt;外任何可以出现在&lt;body&gt;标签中的内容</td>
</tr>
</tbody></table>
<h2 id="17-文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#17-文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="17. 文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>17. 文档声明（Doctype）和<code>&lt;!Doctype html&gt;</code>有何作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><p><strong>文档声明的作用：</strong> 文档声明是为了告诉浏览器，当前<code>HTML</code>文档使用什么版本的<code>HTML</code>来写的，这样浏览器才能按照声明的版本来正确的解析。</p>
<p><code>&lt;!Doctype html&gt;</code><strong>的作用：</strong><code>&lt;!doctype html&gt;</code> 的作用就是让浏览器进入标准模式，使用最新的 <code>HTML5</code> 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。</p>
<p><strong>严格模式与混杂模式的区分：</strong></p>
<ul>
<li>  <strong>严格模式</strong>： 又称为标准模式，指浏览器按照<code>W3C</code>标准解析代码；</li>
<li>  <strong>混杂模式</strong>： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；</li>
</ul>
<p><strong>区分</strong>：网页中的<code>DTD</code>，直接影响到使用的是严格模式还是浏览模式，可以说<code>DTD</code>的使用与这两种方式的区别息息相关。</p>
<ul>
<li>  如果文档包含严格的<code>DOCTYPE</code> ，那么它一般以严格模式呈现（<strong>严格 DTD ——严格模式</strong>）；</li>
<li>  包含过渡 <code>DTD</code> 和 <code>URI</code> 的 <code>DOCTYPE</code> ，也以严格模式呈现，但有过渡 <code>DTD</code> 而没有 <code>URI</code> （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（<strong>有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式</strong>）；</li>
<li>  <code>DOCTYPE</code> 不存在或形式不正确会导致文档以混杂模式呈现（<strong>DTD不存在或者格式不正确——混杂模式</strong>）；</li>
<li>  <code>HTML5</code> 没有 <code>DTD</code> ，因此也就没有严格模式与混杂模式的区别，<code>HTML5</code> 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(<strong>HTML5 没有严格和混杂之分</strong>在使用HTML5的时候，在开头只写了这一句话，浏览器也能解析，原因是：HTML5不基于 SGML，所以不需要引用DTD，但是需要DOCTYPE来规范浏览器的行为，让浏览器按照W3C的标准解析渲染页面。 而HTML4.01和XHTML1.0基于SGML，所以需要引用DTD，才能告诉浏览器使用哪种DTD来解析文档。)。</li>
</ul>
<p>总之，<strong>严格模式让各个浏览器统一执行一套规范，兼容模式保证了旧网站的正常运行。</strong></p>
<p>在怪异模式下，盒模型为IE模型 ；严格模式下为W3C标准的盒模型</p>
<p>参考：<a href="https://juejin.cn/post/6989264337143595044%EF%BC%9Bhttps://juejin.cn/post/6969072081308745764">https://juejin.cn/post/6989264337143595044；https://juejin.cn/post/6969072081308745764</a></p>
<h2 id="18-浏览器乱码的原因是什么？如何解决？"><a href="#18-浏览器乱码的原因是什么？如何解决？" class="headerlink" title="18. 浏览器乱码的原因是什么？如何解决？"></a>18. 浏览器乱码的原因是什么？如何解决？</h2><p><strong>产生乱码的原因：</strong></p>
<ul>
<li>  网页源代码是<code>gbk</code>的编码，而内容中的中文字是<code>utf-8</code>编码的，这样浏览器打开即会出现<code>html</code>乱码，反之也会出现乱码；</li>
<li>  <code>html</code>网页编码是<code>gbk</code>，而程序从数据库中调出呈现是<code>utf-8</code>编码的内容也会造成编码乱码；</li>
<li>  浏览器不能自动检测网页编码，造成网页乱码。</li>
</ul>
<p><strong>解决办法：</strong></p>
<ul>
<li>  使用软件编辑HTML网页内容；</li>
<li>  如果网页设置编码是<code>gbk</code>，而数据库储存数据编码格式是<code>UTF-8</code>，此时需要程序查询数据库数据显示数据前进程序转码；</li>
<li>  如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li>
</ul>
<h2 id="19-渐进增强和优雅降级之间的区别"><a href="#19-渐进增强和优雅降级之间的区别" class="headerlink" title="19. 渐进增强和优雅降级之间的区别"></a>19. 渐进增强和优雅降级之间的区别</h2><p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。 </p>
<p><strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p>
<p><strong>两者区别：</strong></p>
<ul>
<li>  优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li>
<li>  降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>
</ul>
<p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>
<p>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p>
<h2 id="20-说一下-HTML5-drag-API"><a href="#20-说一下-HTML5-drag-API" class="headerlink" title="20. 说一下 HTML5 drag API"></a>20. 说一下 HTML5 drag API</h2><p>参考：<a href="https://juejin.cn/post/7014414669221724190">https://juejin.cn/post/7014414669221724190</a></p>
<p><strong>draggable</strong></p>
<ul>
<li>  当我们想让元素变成可拖拽时，我们就需要设置 draggable 属性。</li>
<li>  属性值未设置的情况下，默认是 auto，此时拖拽行为为浏览器默认行为，只有选中的文字，链接，图片可以拖动。</li>
<li>  draggable 属性值不是 Boolean 类型，需要显式设置为 true 或者 false，true 为可拖动，false 为不可拖动</li>
</ul>
<p><strong>拖拽事件</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发时刻</th>
</tr>
</thead>
<tbody><tr>
<td>dragstart</td>
<td>当用户开始拖拽一个元素或选中的文本时触发</td>
</tr>
<tr>
<td>drag</td>
<td>当拖拽元素或选中的文本时触发</td>
</tr>
<tr>
<td>dragend</td>
<td>当拖拽操作结束时触发</td>
</tr>
<tr>
<td>dragenter</td>
<td>当拖拽元素或选中的文本到一个可放置的目标时触发</td>
</tr>
<tr>
<td>dragover</td>
<td>当元素或选中的文本被拖到一个可放置的目标上时触发（每100毫秒触发一次）</td>
</tr>
<tr>
<td>drop</td>
<td>当元素或选中的文本在可放置的目标上被释放时触发</td>
</tr>
<tr>
<td>dragleave</td>
<td>当拖拽元素或选中的文本离开一个可放置的目标时触发。</td>
</tr>
<tr>
<td>dragexit</td>
<td>和dragleave类似，但是兼容性不好，建议不要使用。</td>
</tr>
</tbody></table>
<p><strong>事件分类</strong>：</p>
<ul>
<li>  可拖拽元素：dragstart，drag，dragend</li>
<li>  可放置的元素：dragenter，dragover，drop，dragleave</li>
</ul>
<p>拖拽事件的 event 对象 dragEvent 继承 mouseEvent，dragEvent 有个属性 dataTransfer，dataTransfer 属性是一个 DataTransfer 对象</p>
<p><strong>拖拽数据对象</strong>涉及到三个类：DataTransfer, DataTransferItemList, DataTransferItem</p>
<ul>
<li>DataTransfer<ul>
<li>  DataTransfer 对象用于保存在拖放操作期间拖动的数据，同时还可以设置拖拽样式，读取拖拽文件等等。它可以包含一个或多个数据项，每个数据项包含一个或多个数据类型。</li>
<li>  所有拖拽事件中我们都可以通过 event.dataTransfer 访问到它。</li>
</ul>
</li>
<li>dropEffect 和 effectAllowed<ul>
<li>  <code>dropEffect</code> 用于表示放置区接受什么行为的拖放，一般在 dragenter 和 dragover 中设置；</li>
<li>  对应的 <code>effectAllowed</code> 表示这次拖拽的行为是什么行为，要在 dragstart 中设置。</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>拖放示例-文本<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#drop-area</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#660000</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#drag-el</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: palegoldenrod;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;drop-area&quot;</span>&gt;</span>423423423<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;drag-el&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> dragEl = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#drag-el&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> dropArea = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#drop-area&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    dragEl.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      event.dataTransfer.setData(<span class="string">&#x27;text/plain&#x27;</span>, event.target.id)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    dropArea.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 通知浏览器不要执行事件的常规内置操作</span></span></span><br><span class="line"><span class="javascript">      event.preventDefault()</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    dropArea.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> id = event.dataTransfer.getData(<span class="string">&#x27;text/plain&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      dropArea.appendChild(<span class="built_in">document</span>.getElementById(id))</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="21-为什么-script-标签放在-body-最后，css-放在-head-里面"><a href="#21-为什么-script-标签放在-body-最后，css-放在-head-里面" class="headerlink" title="21. 为什么 script 标签放在 body 最后，css 放在 head 里面"></a>21. 为什么 script 标签放在 body 最后，css 放在 head 里面</h2><h2 id="22-导入-css-的方式，为什么建议用-link-而不是-import（见02-CSS）"><a href="#22-导入-css-的方式，为什么建议用-link-而不是-import（见02-CSS）" class="headerlink" title="22. 导入 css 的方式，为什么建议用 link 而不是 @import（见02.CSS）"></a>22. 导入 css 的方式，为什么建议用 link 而不是 @import（见02.CSS）</h2><p>import会增加http请求（进而影响加载速度）</p>
<h2 id="23-HTML-的全局属性"><a href="#23-HTML-的全局属性" class="headerlink" title="23. HTML 的全局属性"></a>23. HTML 的全局属性</h2><h2 id="24-Geolocation-API（地理定位）用于定位用户的位置。"><a href="#24-Geolocation-API（地理定位）用于定位用户的位置。" class="headerlink" title="24. Geolocation API（地理定位）用于定位用户的位置。"></a>24. Geolocation API（地理定位）用于定位用户的位置。</h2><h2 id="25-WebSockets"><a href="#25-WebSockets" class="headerlink" title="25. WebSockets"></a>25. WebSockets</h2><h2 id="26-Communication-API"><a href="#26-Communication-API" class="headerlink" title="26. Communication API"></a>26. Communication API</h2><h2 id="27-lt-img-gt-title-和-alt-的区别"><a href="#27-lt-img-gt-title-和-alt-的区别" class="headerlink" title="27. &lt;img&gt; title 和 alt 的区别"></a>27. &lt;img&gt; title 和 alt 的区别</h2>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS面试题</title>
    <url>/2021/11/27/css/</url>
    <content><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2021/11/27/css/02.CSS%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="02.CSS面试题"></p>
<h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><ol>
<li><p>基本选择器</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>通用选择器</td>
<td>*</td>
<td>所有元素</td>
<td>2</td>
</tr>
<tr>
<td>元素类型选择器</td>
<td>&lt;元素类型&gt;（例如：div）</td>
<td>所有指定类型的元素</td>
<td>1</td>
</tr>
<tr>
<td>元素类选择器</td>
<td>&lt;类型&gt;(或 *.&lt;类型&gt;)<br />&lt;元素类型&gt;.&lt;类名&gt;</td>
<td>属于指定类的元素；<br />当跟元素类型一起使用时，匹配属于指定类的特定类型的元素</td>
<td>1</td>
</tr>
<tr>
<td>ID选择器</td>
<td>#&lt;id值&gt;</td>
<td>具有指定全局属性 id 值的元素</td>
<td>1</td>
</tr>
<tr>
<td>属性选择器</td>
<td>[&lt;条件&gt;]<br />&lt;元素类型&gt;[&lt;条件&gt;]</td>
<td>具有匹配指定条件的属性的元素；<br />当跟元素类型一起使用时，匹配满足条件的特定类型的元素<br />条件说明（括号内为最低支持版本）：<br />1.[attr]：选择定义attr属性的元素，忽略属性值（2）<br />2.[attr=“val”]：选择定义attr属性，且属性值为val的元素（2）<br />3.[attr^=“val”]：选择定义attr属性，且属性值以字符串val打头的元素（3）<br />4.[attr$=“val”]：选择定义attr属性，且属性值以字符串val结尾的元素（3）<br />5.[attr*=“val”]：选择定义attr属性，且属性值包含字符串val的元素（3）<br />6.[attr~=“val”]：选择定义attr属性，且属性值具有多个值，其中一个为字符串val的元素（2）<br />7.[attr|=“val”]：选择定义attr属性，且属性值为连字符分割的多个值，其中第一个为字符串val的元素（2）</td>
<td>视情况定</td>
</tr>
</tbody></table>
</li>
<li><p>复合选择器</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>并集选择器</td>
<td>&lt;选择器&gt;,&lt;选择器&gt;,&lt;选择器&gt;</td>
<td>单个选择器匹配的所有元素的并集</td>
<td>1</td>
</tr>
<tr>
<td>后代选择器</td>
<td>&lt;第一个选择器&gt; &lt;第二个选择器&gt;</td>
<td>目标元素为匹配第一个选择器的元素的后代，且匹配第二个选择器</td>
<td>1</td>
</tr>
<tr>
<td>子代选择器</td>
<td>&lt;第一个选择器&gt; &gt; &lt;第二个选择器&gt;</td>
<td>目标元素为匹配第一个选择器的元素的直接后代，且匹配第二个选择器</td>
<td>2</td>
</tr>
<tr>
<td>相邻兄弟选择器</td>
<td>&lt;第一个选择器&gt; + &lt;第二个选择器&gt;</td>
<td>目标元素紧跟匹配第一个选择器的元素，且匹配第二个选择器</td>
<td>2</td>
</tr>
<tr>
<td>普通兄弟选择器</td>
<td>&lt;第一个选择器&gt; ~ &lt;第二个选择器&gt;</td>
<td>目标元素位于匹配第一个选择器的元素之后，且匹配第二个选择器</td>
<td>3</td>
</tr>
</tbody></table>
</li>
<li><p>伪元素选择器</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>::first-line 选择器</td>
<td>::first-line</td>
<td>文本内容的首行</td>
<td>1</td>
</tr>
<tr>
<td>::first-letter 选择器</td>
<td>::first-letter</td>
<td>文本内容的首字母</td>
<td>1</td>
</tr>
<tr>
<td>:before 选择器</td>
<td>:before</td>
<td>说明：在选中元素的内容之前插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:after 选择器</td>
<td>:after</td>
<td>说明：在选中元素的内容之后插入内容</td>
<td>2</td>
</tr>
</tbody></table>
<blockquote>
<p>  伪元素选择器的前缀是两个冒号（ :: ），但浏览器认为选择器只有一个冒号（也就是说将 ::first-line看做 ::first-line）。这样它的格式就跟伪类选择器的格式一致了，这是为了向后兼容。</p>
</blockquote>
</li>
<li><p>伪类选择器</p>
<ol>
<li><p>结构性伪类选择器</p>
 <table>
       <tr>
         <th>选择器类型</th>
         <th>选择器</th>
         <th>匹配/说明</th>
         <th>最低支持CSS版本</th>
     </tr>
     <tr>
         <td>:root 选择器</td>
         <td>:root</td>
         <td>选择文档中的根元素，总是返回html</td>
         <td>3</td>
     </tr>
     <tr>
         <td rowspan="4">子元素选择器</td>
         <td>:first-child</td>
         <td>选择元素的第一个元素</td>
         <td>2</td>
     </tr>
     <tr>
         <td>:last-child</td>
         <td>选择元素的最后一个元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:only-child</td>
         <td>选择元素的唯一子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:only-of-type</td>
         <td>选择元素指定类型的唯一子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td rowspan="4">:nth-child 选择器</td>
         <td>:nth-child(n)</td>
         <td>选择父元素的第n个子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:nth-last-child(n)</td>
         <td>选择父元素的倒数第n个子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:nth-of-type(n)</td>
         <td>选择父元素定义类型的第n个子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:nth-last-of-type(n)</td>
         <td>选择父元素定义类型的倒数第n个子元素</td>
         <td>3</td>
     </tr>
 </table></li>
<li><p>UI 伪类选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>:enabled</td>
<td>选择启用状态的元素</td>
<td>3</td>
</tr>
<tr>
<td>:disabled</td>
<td>选择禁用状态的元素</td>
<td>3</td>
</tr>
<tr>
<td>:checked</td>
<td>选择被选中的input的元素（只用于单选按钮和复选框）</td>
<td>3</td>
</tr>
<tr>
<td>:default</td>
<td>选择默认元素</td>
<td>3</td>
</tr>
<tr>
<td>:valid<br />:invalid</td>
<td>根据输入验证选择有效或者无效的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:in-range<br />:out-of-range</td>
<td>选择在指定范围之内或者之外受限的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:required<br />:optional</td>
<td>根据是否允许 :required 属性选择input元素</td>
<td>3</td>
</tr>
</tbody></table>
</li>
<li><p>动态伪类选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>匹配/说明</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>:link</td>
<td>选择链接元素</td>
<td>1</td>
</tr>
<tr>
<td>:visited</td>
<td>选择用户已访问的链接元素</td>
<td>1</td>
</tr>
<tr>
<td>:hover</td>
<td>鼠标悬停在其上的元素</td>
<td>2</td>
</tr>
<tr>
<td>:active</td>
<td>当前被用户激活的元素，通常意味着用户即将点击（或者按压）该元素</td>
<td>2</td>
</tr>
<tr>
<td>:focus</td>
<td>当前获得焦点的元素</td>
<td>2</td>
</tr>
</tbody></table>
</li>
<li><p>其它伪类选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>:not(&lt;选择器&gt;)</td>
<td>对括号内选择器的选择取反</td>
<td>3</td>
</tr>
<tr>
<td>:empty</td>
<td>没有子元素的元素</td>
<td>3</td>
</tr>
<tr>
<td>:lang(&lt;目标语言&gt;)</td>
<td>选择基于lang全局属性值的元素</td>
<td>1</td>
</tr>
<tr>
<td>:target</td>
<td>URL片段标识符指向的元素</td>
<td>3</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<p><strong>从层叠、继承、优先级来讨论如果有多个应用于某个元素的css样式时，为什么会显示这个样式，而不会显示另外一个样式：</strong></p>
<ul>
<li><p>层叠</p>
<ul>
<li>  层叠的概念是如果优先级相等，对于同一元素，后面的css样式会覆盖前面的css样式；</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li>  继承的概念是子元素会继承父元素的某些属性，从而表现出和父元素一样的样式；</li>
<li>  这里要注意的是有些元素可以被继承（eg：color，font-family）,有些则不能被继承（eg：height，width）；</li>
</ul>
</li>
<li><p>优先级</p>
<ul>
<li><p>选择器优先级的计算方式</p>
<ul>
<li>  第一位加1：如果某个元素具有内联样式，虽然没有选择器，具有内联样式时此位恒为1；</li>
<li>  第二位加1：如果选择器包含一个id选择器时；</li>
<li>  第三位加1：如果选择器包含一个类选择器、伪类选择器或属性选择器时；</li>
<li>  第四位加1：如果选择器包含一个元素选择器或伪元素选择器时；</li>
</ul>
<p>  注：通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ‘ ‘)，和否定伪类 (<code>:not</code>) 不会影响优先级。</p>
</li>
<li><p>注意事项</p>
<ul>
<li>  !important声明的样式的优先级最高，权重为正无穷；</li>
<li>  如果优先级相同，则最后出现的样式生效；</li>
<li>  继承得到的样式的优先级最低；</li>
<li>  通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li>
<li>  样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p>
<ol>
<li> <strong>display</strong>：规定元素应该生成的框的类型</li>
<li><strong>文本属性</strong>：<ul>
<li>  vertical-align：垂直文本对齐</li>
<li>  text-decoration：规定添加到文本的装饰</li>
<li>  text-shadow：文本阴影效果</li>
<li>  white-space：空白符的处理</li>
<li>  unicode-bidi：设置文本的方向</li>
</ul>
</li>
<li> <strong>盒子模型的属性</strong>：width、height、margin、border、padding</li>
<li> <strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li>
<li> <strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
<li> <strong>生成内容属性</strong>：content、counter-reset、counter-increment</li>
<li> <strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li>
<li> <strong>页面样式属性</strong>：size、page-break-before、page-break-after</li>
<li> <strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li>
</ol>
<p><strong>二、有继承性的属性</strong></p>
<ol>
<li><strong>字体系列属性</strong><ul>
<li>  font-family：字体系列</li>
<li>  font-weight：字体的粗细</li>
<li>  font-size：字体的大小</li>
<li>  font-style：字体的风格</li>
</ul>
</li>
<li><strong>文本系列属性</strong><ul>
<li>  text-indent：文本缩进</li>
<li>  text-align：文本水平对齐</li>
<li>  line-height：行高</li>
<li>  word-spacing：单词之间的间距</li>
<li>  letter-spacing：中文或者字母之间的间距</li>
<li>  text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li>
<li>  color：文本颜色</li>
</ul>
</li>
<li><strong>元素可见性</strong><ul>
<li>  visibility：控制元素显示隐藏</li>
</ul>
</li>
<li><strong>列表布局属性</strong><ul>
<li>  list-style：列表风格，包括list-style-type、list-style-image等</li>
</ul>
</li>
<li><strong>光标属性</strong><ul>
<li>  cursor：光标显示为何种形态</li>
</ul>
</li>
</ol>
<h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>此元素不会被显示。</td>
</tr>
<tr>
<td>block</td>
<td>此元素将显示为块级元素，此元素前后会带有换行符。</td>
</tr>
<tr>
<td>inline</td>
<td>默认。此元素会被显示为内联元素，元素前后没有换行符。</td>
</tr>
<tr>
<td>inline-block</td>
<td>行内块元素。（CSS2.1 新增的值）</td>
</tr>
<tr>
<td>list-item</td>
<td>此元素会作为列表显示。</td>
</tr>
<tr>
<td>run-in</td>
<td>此元素会根据上下文作为块级元素或内联元素显示。</td>
</tr>
<tr>
<td>compact</td>
<td>CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td>
</tr>
<tr>
<td>marker</td>
<td>CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。<br />1.inline-table: 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。<br />2.table-row-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。<br />3.table-header-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。<br />4.table-footer-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。<br />5.table-row: 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。<br />6.table-column-group: 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。<br />7.table-column: 此元素会作为一个单元格列显示（类似 &lt;col&gt;）<br />8.table-cell: 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;）<br />9.table-caption: 此元素会作为一个表格标题显示（类似 &lt;caption&gt;）</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 display 属性的值。</td>
</tr>
</tbody></table>
<h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><ol>
<li> <strong>block：</strong> 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</li>
<li> <strong>inline：</strong> 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li>
<li> <strong>inline-block：</strong> 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</li>
</ol>
<p>对于行内元素和块级元素，其特点如下：</p>
<ol>
<li><strong>行内元素</strong><ul>
<li>  设置宽高无效；</li>
<li>  可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li>
<li>  不会自动换行；</li>
</ul>
</li>
<li><strong>块级元素</strong><ul>
<li>  可以设置宽高；</li>
<li>  设置margin和padding都有效；</li>
<li>  可以自动换行；</li>
<li>  多个块状，默认排列从上到下。</li>
</ul>
</li>
</ol>
<h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul>
<li>  <strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li>
<li>  <strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li>
<li>  <strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li>
<li>  <strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li>
<li>  <strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li>
<li>  <strong>clip/clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li>
<li>  **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li>
</ul>
<h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p><strong>两者都是外部引用CSS的方式，它们的区别如下：</strong></p>
<ul>
<li>  link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li>
<li>  link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>  link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li>
<li>  link支持使用Javascript控制DOM去改变样式；而@import不支持。</li>
</ul>
<p><strong>link先于@import加载，为什么@import和link优先级相同，@import的样式没有覆盖link？</strong></p>
<ul>
<li>  浏览器渲染的动作一般会执行多次的。最后一次渲染，一定是基于之前加载过的所有样式整合后渲染树进行绘制页面的，已经被渲染过的页面元素，也会被重新渲染。</li>
<li>  那么我们就可以把@import这种导入 CSS 文件的方式理解成一种替换，CSS 解析引擎在对一个 CSS 文件进行解析时，如在文件顶部遇到@import，将被替换为该@import导入的 CSS 文件中的全部样式。</li>
<li>  @import引入的样式，其虽然后被加载，却会在加载完毕后置于样式表顶部，最终渲染时自然会被下面的同名样式层叠。</li>
</ul>
<p><strong>为什么建议用link而不是@import</strong></p>
<ul>
<li>  每个@import都会产生一个新的http请求，消耗服务器资源</li>
<li>  @import混合js文件时，在IE中引发资源文件的下载顺序被打乱（即使排列在@import后面的js文件先于@import下载），而且会打乱甚至破坏@import自身的并行下载 </li>
<li>  link混合@import会破坏并行下载，这会导致原本并行下载的样式变成一个一个的同步下载</li>
<li>  仅用link标签，可确保样式在所有浏览器里面都能被并行且按照顺序被下载</li>
<li>  如果import加载的样式比较大，容易出现加载延迟，甚至有闪屏的情况</li>
</ul>
<h3 id="7-transition和animation的区别"><a href="#7-transition和animation的区别" class="headerlink" title="7. transition和animation的区别"></a>7. transition和animation的区别</h3><ul>
<li>  <strong>transition是过渡属性</strong>，强调过渡，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</li>
<li>  <strong>animation是动画属性</strong>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</li>
</ul>
<h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者区别如下：</strong></p>
<ol>
<li><strong>在渲染树中</strong><ul>
<li>  <code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li>
<li>  <code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li>
</ul>
</li>
<li><strong>是否是继承属性</strong><ul>
<li>  <code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li>
<li>  <code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；</li>
</ul>
</li>
<li> 修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</li>
<li> 如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</li>
</ol>
<h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. 伪元素和伪类的区别和作用？</h3><p><strong>定义</strong></p>
<ul>
<li><p>  伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。</p>
</li>
<li><p>  伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</p>
</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><p>表示方法</p>
<p>  CSS2 中伪类、伪元素都是以单冒号<code>:</code>表示，CSS2.1 后规定伪类用单冒号表示，伪元素用双冒号<code>::</code>表示，浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first-line, :first-letter 等)的单冒号写法。对于 CSS2 之后所有新增的伪元素(如::selection)，应该采用双冒号的写法。但是因为兼容性问题，大部分还是用的单冒号。</p>
</li>
<li><p>定义不同</p>
<p>  伪类即假的类，通常可以添加类来达到效果，伪元素即假元素，需要通过添加元素才能达到效果。</p>
</li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li>  伪类和伪元素都是用来表示文档树以外的”元素”。</li>
<li>  伪类和伪元素分别用单冒号<code>:</code>和双冒号<code>::</code>来表示。</li>
<li>  伪类和伪元素的区别，最关键的点在于如果没有伪元素(或伪类)，是否需要添加元素才能达到目的，如果是则是伪元素，反之则是伪类。</li>
</ul>
<h3 id="10-对requestAnimationframe的理解"><a href="#10-对requestAnimationframe的理解" class="headerlink" title="10. 对requestAnimationframe的理解"></a>10. 对requestAnimationframe的理解</h3><p>参考：<a href="https://juejin.cn/post/6991297852462858277#heading-3">https://juejin.cn/post/6991297852462858277#heading-3</a></p>
<p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是<strong>请求动画帧</strong>。</p>
<p>MDN对该方法的描述：</p>
<blockquote>
<p>  window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
</blockquote>
<p><strong>语法：</strong> <code>window.requestAnimationFrame(callback);</code>  其中，callback是<strong>下一次重绘之前更新动画帧所调用的函数</strong>(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p>
<p><strong>取消动画：</strong> 使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p>
<p><strong>优势：</strong></p>
<ul>
<li>  <strong>CPU节能</strong>：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li>
<li>  <strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li>
<li>  <strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
</ul>
<p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p>
<ul>
<li>  settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li>
<li>  settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li>
</ul>
<h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><ul>
<li><p>盒⼦模型的概念</p>
<p>  盒⼦模型（boxmodel）。⽹⻚中，每⼀个元素都占有⼀定的空间，⽆论是div、h1~h6、还是p，都可以看成是盒⼦。</p>
</li>
<li><p>盒⼦模型的组成</p>
<ul>
<li><p>⼀个元素占有空间的⼤小由⼏个部分构成，其中包括</p>
<ul>
<li>  元素的内容（content），</li>
<li>  元素的内边距（padding），内容与边框之间的距离</li>
<li>  元素的边框（border），</li>
<li>  元素的外边距（margin），边框与外部元素之间的距离</li>
</ul>
<p>  四个部分，这四个部分⼀起构成了盒⼦模型。</p>
</li>
<li><p>注意：margin重叠，也叫margin塌陷</p>
<p>  标准⽂档流中，两个盒⼦，分别有上下外边距，竖直⽅向的margin不叠加，只取较⼤的值作为margin(⽔平⽅向的margin是可以叠加的)。</p>
</li>
<li><p>  margin这个属性，本质上描述的是兄弟和兄弟之间的距离；最好不要⽤这个marign表达⽗⼦之间的距离。如果向设置⽗⼦之间的距离，我们最好使⽤⽗元素的padding。</p>
</li>
</ul>
</li>
<li><p>盒⼦模型的分类</p>
<ul>
<li>  盒模型分为：W3C标准盒⼦、IE盒⼦</li>
<li>  W3C标准盒⼦（content-box）：⼜称内容盒⼦，是指块元素box-sizing属性为content-box的盒模型。⼀般在现代浏览器中使⽤的都是正常盒模型content-box。它所说的width⼀般只包含内容，不包含padding与margin，并且盒⼦的⼤小会以内容优先，⾃动扩展，⼦元素可以撑开⽗元素.</li>
<li>  IE盒⼦（border-box）：⼜称怪异盒模型（边框盒⼦），是指块元素box-sizing属性为border-box的盒模型。⼀般在IE浏览器中默认为这种怪异盒模型，但是由于其⾃⾝的特殊性，⼿机⻚⾯中也有使⽤怪异盒模型。怪异盒模型中，⽗元素的盒模型确定，⼦元素⽆法撑开⽗元素的盒模型。</li>
</ul>
</li>
</ul>
<h3 id="12-为什么有时候⽤translate来改变位置⽽不是定位？"><a href="#12-为什么有时候⽤translate来改变位置⽽不是定位？" class="headerlink" title="12. 为什么有时候⽤translate来改变位置⽽不是定位？"></a>12. 为什么有时候⽤translate来改变位置⽽不是定位？</h3><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p>
<p>参考：<a href="https://juejin.cn/post/6844904077394984968#heading-0">https://juejin.cn/post/6844904077394984968#heading-0</a></p>
<h3 id="13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？"><a href="#13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？" class="headerlink" title="13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？"></a>13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？</h3><p>浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个<code>&lt;li&gt;</code>放在一行，这导致<code>&lt;li&gt;</code>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p>
<p><strong>解决办法：</strong></p>
<p>（1）为<code>&lt;li&gt;</code>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p>
<p>（2）将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</p>
<p>（3）将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即font-size:0。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p>
<p>（4）消除<code>&lt;ul&gt;</code>的字符间隔letter-spacing:-8px，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符间隔设为默认letter-spacing:normal。</p>
<h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><p>参考：<a href="https://juejin.cn/post/6844903518520901639#heading-43%EF%BC%8Chttps://juejin.cn/post/6844903829679390728#heading-3">https://juejin.cn/post/6844903518520901639#heading-43，https://juejin.cn/post/6844903829679390728#heading-3</a></p>
<ol>
<li><p> 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）见1</p>
</li>
<li><p>边框</p>
 <table>
       <tr>
         <th>属性</th>
         <th  colspan="2">说明</th>
     </tr>
     <tr>
         <td rowspan="6">border-image</td>
         <td colspan="2">使用图像作为边框的简写属性</td>
     </tr>
     <tr>
         <td>border-image-outset</td>
         <td>指定图像向边框盒外部扩展的区域</td>
     </tr>
     <tr>
         <td>border-image-repeat</td>
         <td>指定边框图像的缩放和重复方式</td>
     </tr>
     <tr>
         <td>border-image-slice</td>
         <td>指定边框图像的切割方式</td>
     </tr>
     <tr>
         <td>border-image-source</td>
         <td>设置边框图片的来源路径</td>
     </tr>
     <tr>
         <td>border-image-width</td>
         <td>设置边框图像的宽度</td>
     </tr>
     <tr>
         <td rowspan="5">border-radius</td>
         <td colspan="2">使用圆角边框的简写属性</td>
     </tr>
     <tr>
         <td>border-top-left-radius</td>
         <td>将边框左上角设置为圆角</td>
     </tr>
     <tr>
         <td>border-top-right-radius</td>
         <td>将边框右上角设置为圆角</td>
     </tr>
     <tr>
         <td>border-bottom-left-radius</td>
         <td>将边框左下角设置为圆角</td>
     </tr>
     <tr>
         <td>border-bottom-right-radius</td>
         <td>将边框右下角设置为圆角</td>
     </tr>
     <tr>
         <td>box-shadow</td>
         <td colspan="2">设置元素的一个或多个阴影效果</td>
     </tr>
 </table>    </li>
<li><p>背景</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background-clip</td>
<td>规定背景的绘制区域。</td>
</tr>
<tr>
<td>background-origin</td>
<td>规定背景图片的定位区域。</td>
</tr>
<tr>
<td>background-size</td>
<td>规定背景图片的尺寸。</td>
</tr>
</tbody></table>
</li>
<li><p>渐变</p>
<ul>
<li><p>线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(direction, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure></li>
<li><p>径向渐变（Radial Gradients）- 由它们的中心定义</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(center, shape size, start-color, ..., last-color);</span><br></pre></td></tr></table></figure></li>
<li><p>圆锥渐变（Conic Gradient）</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">conic-gradient</span>(red, orange, yellow, green, teal, blue, purple);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>文本属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@font-face</td>
<td>指定网页使用的字体</td>
</tr>
<tr>
<td>hanging-punctuation</td>
<td>规定标点字符是否位于线框之外。</td>
</tr>
<tr>
<td>punctuation-trim</td>
<td>规定是否对标点字符进行修剪。</td>
</tr>
<tr>
<td>text-align-last</td>
<td>设置如何对齐最后一行或紧挨着强制换行符之前的行。</td>
</tr>
<tr>
<td>text-emphasis</td>
<td>向元素的文本应用重点标记以及重点标记的前景色。</td>
</tr>
<tr>
<td>text-justify</td>
<td>规定当 text-align 设置为 “justify” 时所使用的对齐方法。</td>
</tr>
<tr>
<td>text-outline</td>
<td>规定文本的轮廓。</td>
</tr>
<tr>
<td>text-overflow</td>
<td>规定当文本溢出包含元素时发生的事情。</td>
</tr>
<tr>
<td>text-shadow</td>
<td>向文本添加阴影。</td>
</tr>
<tr>
<td>text-wrap</td>
<td>规定文本的换行规则。</td>
</tr>
<tr>
<td>word-break</td>
<td>规定非中日韩文本的换行规则。</td>
</tr>
<tr>
<td>word-wrap</td>
<td>允许对长的不可分割的单词进行分割并换行到下一行。</td>
</tr>
</tbody></table>
</li>
<li><p>转换和变形</p>
<p> <strong>2D新转换属性</strong></p>
<p> 以下列出了所有的转换属性:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>适用于2D或3D转换的元素</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许您更改转化元素位置</td>
</tr>
</tbody></table>
<p> <strong>2D 转换方法</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>matrix(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td>定义 2D 转换，使用六个值的矩阵。</td>
</tr>
<tr>
<td>translate(<em>x</em>,<em>y</em>)</td>
<td>定义 2D 转换，沿着 X 和 Y 轴移动元素。</td>
</tr>
<tr>
<td>translateX(<em>n</em>)</td>
<td>定义 2D 转换，沿着 X 轴移动元素。</td>
</tr>
<tr>
<td>translateY(<em>n</em>)</td>
<td>定义 2D 转换，沿着 Y 轴移动元素。</td>
</tr>
<tr>
<td>scale(<em>x</em>,<em>y</em>)</td>
<td>定义 2D 缩放转换，改变元素的宽度和高度。</td>
</tr>
<tr>
<td>scaleX(<em>n</em>)</td>
<td>定义 2D 缩放转换，改变元素的宽度。</td>
</tr>
<tr>
<td>scaleY(<em>n</em>)</td>
<td>定义 2D 缩放转换，改变元素的高度。</td>
</tr>
<tr>
<td>rotate(<em>angle</em>)</td>
<td>定义 2D 旋转，在参数中规定角度。</td>
</tr>
<tr>
<td>skew(<em>x-angle</em>,<em>y-angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 X 和 Y 轴。</td>
</tr>
<tr>
<td>skewX(<em>angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 X 轴。</td>
</tr>
<tr>
<td>skewY(<em>angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 Y 轴。</td>
</tr>
</tbody></table>
<p> <strong>3D转换属性</strong></p>
<p> 下表列出了所有的转换属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>向元素应用 2D 或 3D 转换。</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许你改变被转换元素的位置。</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示。</td>
</tr>
<tr>
<td>perspective</td>
<td>规定 3D 元素的透视效果。</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>规定 3D 元素的底部位置。</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>定义元素在不面对屏幕时是否可见。</td>
</tr>
</tbody></table>
<p> <strong>3D 转换方法</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>, <em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td>
</tr>
<tr>
<td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>定义 3D 转化。</td>
</tr>
<tr>
<td>translateX(<em>x</em>)</td>
<td>定义 3D 转化，仅使用用于 X 轴的值。</td>
</tr>
<tr>
<td>translateY(<em>y</em>)</td>
<td>定义 3D 转化，仅使用用于 Y 轴的值。</td>
</tr>
<tr>
<td>translateZ(<em>z</em>)</td>
<td>定义 3D 转化，仅使用用于 Z 轴的值。</td>
</tr>
<tr>
<td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>定义 3D 缩放转换。</td>
</tr>
<tr>
<td>scaleX(<em>x</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 X 轴的值。</td>
</tr>
<tr>
<td>scaleY(<em>y</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 Y 轴的值。</td>
</tr>
<tr>
<td>scaleZ(<em>z</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 Z 轴的值。</td>
</tr>
<tr>
<td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td>
<td>定义 3D 旋转。</td>
</tr>
<tr>
<td>rotateX(<em>angle</em>)</td>
<td>定义沿 X 轴的 3D 旋转。</td>
</tr>
<tr>
<td>rotateY(<em>angle</em>)</td>
<td>定义沿 Y 轴的 3D 旋转。</td>
</tr>
<tr>
<td>rotateZ(<em>angle</em>)</td>
<td>定义沿 Z 轴的 3D 旋转。</td>
</tr>
<tr>
<td>perspective(<em>n</em>)</td>
<td>定义 3D 转换元素的透视视图。</td>
</tr>
</tbody></table>
</li>
<li><p>反射</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片</span><br></pre></td></tr></table></figure></li>
<li><p>颜色</p>
<ul>
<li><p>rgba：rgb为颜色值，a为透明度</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">1</span>);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,.<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>hsla：h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”。使用HSLA时，透明度不会影响其后代元素</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">hsla</span>( <span class="number">112</span>, <span class="number">72%</span>, <span class="number">33%</span>, <span class="number">0.68</span>);</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">hsla</span>( <span class="number">49</span>, <span class="number">65%</span>, <span class="number">60%</span>, <span class="number">0.68</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>滤镜</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>原图<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>黑白色filter: grayscale(100%)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter: grayscale(100%);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>褐色filter:sepia(1)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:sepia(1);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>饱和度saturate(2)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:saturate(2);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>色相旋转hue-rotate(90deg)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:hue-rotate(90deg);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>反色filter:invert(1)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:invert(1);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>透明度opacity(.5)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:opacity(.5);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>亮度brightness(.5)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:brightness(.5);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>对比度contrast(2)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:contrast(2);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>模糊blur(3px)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:blur(3px);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>阴影drop-shadow(5px 5px 5px #000)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:drop-shadow(5px 5px 5px #000);&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>过渡</p>
<p> 下表列出了所有的过渡属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition.html">transition</a></td>
<td>简写属性，用于在一个属性中设置四个过渡属性。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-property.html">transition-property</a></td>
<td>规定应用过渡的 CSS 属性的名称。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-duration.html">transition-duration</a></td>
<td>定义过渡效果花费的时间。默认是 0。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-timing-function.html">transition-timing-function</a></td>
<td>规定过渡效果的时间曲线。默认是 “ease”。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-delay.html">transition-delay</a></td>
<td>规定过渡效果何时开始。默认是 0。</td>
</tr>
</tbody></table>
</li>
<li><p>动画</p>
<p> 下面的表格列出了 @keyframes 规则和所有动画属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-keyframes.html">@keyframes</a></td>
<td>规定动画。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation.html">animation</a></td>
<td>所有动画属性的简写属性，除了 animation-play-state 属性。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-name.html">animation-name</a></td>
<td>规定 @keyframes 动画的名称。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-duration.html">animation-duration</a></td>
<td>规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-timing-function.html">animation-timing-function</a></td>
<td>规定动画的速度曲线。默认是 “ease”。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-delay.html">animation-delay</a></td>
<td>规定动画何时开始。默认是 0。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-iteration-count.html">animation-iteration-count</a></td>
<td>规定动画被播放的次数。默认是 1。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-direction.html">animation-direction</a></td>
<td>规定动画是否在下一周期逆向地播放。默认是 “normal”。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-play-state.html">animation-play-state</a></td>
<td>规定动画是否正在运行或暂停。默认是 “running”。</td>
</tr>
</tbody></table>
</li>
<li><p>多列布局</p>
<p> 下表列出了所有 CSS3 的多列属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-count.html">column-count</a></td>
<td>指定元素应该被分割的列数。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-fill.html">column-fill</a></td>
<td>指定如何填充列</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-gap.html">column-gap</a></td>
<td>指定列与列之间的间隙</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule.html">column-rule</a></td>
<td>所有 column-rule-* 属性的简写</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule-color.html">column-rule-color</a></td>
<td>指定两列间边框的颜色</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule-style.html">column-rule-style</a></td>
<td>指定两列间边框的样式</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule-width.html">column-rule-width</a></td>
<td>指定两列间边框的厚度</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-span.html">column-span</a></td>
<td>指定元素要跨越多少列</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-width.html">column-width</a></td>
<td>指定列的宽度</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-columns.html">columns</a></td>
<td>设置 column-width 和 column-count 的简写</td>
</tr>
</tbody></table>
</li>
<li><p> 弹性盒布局</p>
</li>
<li><p> 栅格布局</p>
</li>
<li><p>盒模型</p>
<p> 在 CSS3 中, 增加了一些新的用户界面特性来调整元素尺寸，框尺寸和外边框，主要包括以下用户界面属性：</p>
<ul>
<li>  resize：none | both | horizontal | vertical | inherit</li>
<li>  box-sizing: content-box | border-box | inherit</li>
<li>  outline:outline-color outline-style outline-width outine-offset</li>
<li>  overflow-x：横向溢出处理方式</li>
<li>  overflow-y：纵向溢出处理方式</li>
</ul>
<p> resize属性指定一个元素是否应该由用户去调整大小。</p>
<p> box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。</p>
<p> outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</p>
</li>
<li><p>媒体查询</p>
<p> 从 CSS 版本 2 开始，就可以通过媒体类型在 CSS 中获得媒体支持。如果您曾经使用过打印样式表，那么您可能已经使用过媒体类型。清单 1 展示了一个示例。</p>
<p> <strong>清单 1. 使用媒体类型</strong></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;site.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;print.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p> <strong>清单 2. 媒体查询规则</strong></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">800px</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  <code>@media all</code> 是媒体类型，也就是说，将此 CSS 应用于所有媒体类型。</p>
</li>
<li><p>  <code>(min-width:800px)</code> 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 CSS。</p>
</li>
</ul>
<p> <strong>清单 3.</strong> <code>and</code> <strong>条件</strong></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>:<span class="number">800px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">1200px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>:portrait) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>清单 4.</strong> <code>or</code> <strong>关键词</strong></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>:<span class="number">800px</span>) <span class="keyword">or</span> (<span class="attribute">orientation</span>:portrait) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>清单 5. 使用</strong> <code>not</code></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="keyword">not</span> <span class="attribute">min-width</span>:<span class="number">800px</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其它</p>
<ul>
<li>  自定义属性和变量</li>
<li>  calc 函数</li>
<li>  <code>opacity </code> 属性</li>
</ul>
</li>
</ol>
<h3 id="15-替换元素的概念及计算规则"><a href="#15-替换元素的概念及计算规则" class="headerlink" title="15. 替换元素的概念及计算规则"></a>15. 替换元素的概念及计算规则</h3><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p>
<p>替换元素除了内容可替换这一特性以外，还有以下特性：</p>
<ul>
<li>  <strong>内容的外观不受页面上的CSS的影响</strong>：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li>
<li>  <strong>有自己的尺寸</strong>：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如</li>
<li>  <strong>在很多CSS属性上有自己的一套表现规则</strong>：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li>
<li>  <strong>所有的替换元素都是内联水平元素</strong>：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li>
</ul>
<p>替换元素的尺寸从内而外分为三类：</p>
<ul>
<li>  <strong>固有尺寸：</strong> 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li>
<li>  <strong>HTML尺寸：</strong> 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li>
<li>  <strong>CSS尺寸：</strong> 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</li>
</ul>
<p>这三层结构的计算规则具体如下： （1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。 （2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。 （3）如果有CSS尺寸，则最终尺寸由CSS属性决定。 （4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。 （5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。 （6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p>
<h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><ol>
<li> <strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</li>
<li> <strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</li>
<li> <strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</li>
<li> <strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</li>
<li> <strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</li>
<li> <strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</li>
<li><strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。<ul>
<li>  在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li>
<li>  在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li>
<li>  WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li>
</ul>
</li>
</ol>
<h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p>
<p><strong>优点：</strong></p>
<ul>
<li>  利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li>
<li>  <code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li>
<li>  <code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li>
<li>  维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li>
</ul>
<h3 id="18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？"><a href="#18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？" class="headerlink" title="18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？"></a>18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h3><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p>
<p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p>
<p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p>
<p>当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。</p>
<p>还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">my-image &#123; <span class="attr">background</span>: (low.png); &#125;</span><br><span class="line">@media only screen and (min-device-pixel-ratio: <span class="number">1.5</span>) &#123;</span><br><span class="line">  #my-image &#123; <span class="attr">background</span>: (high.png); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-margin-和-padding-的使用场景"><a href="#19-margin-和-padding-的使用场景" class="headerlink" title="19. margin 和 padding 的使用场景"></a>19. margin 和 padding 的使用场景</h3><ul>
<li>  需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li>
<li>  需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li>
</ul>
<h3 id="20-对line-height-的理解及其赋值方式"><a href="#20-对line-height-的理解及其赋值方式" class="headerlink" title="20. 对line-height 的理解及其赋值方式"></a>20. 对line-height 的理解及其赋值方式</h3><ol>
<li><strong>line-height的概念：</strong><ul>
<li>  line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；</li>
<li>  如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</li>
<li>  一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</li>
<li>  把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</li>
<li>  line-height 和 height 都能撑开一个高度；</li>
</ul>
</li>
<li><strong>line-height 的赋值方式：</strong><ul>
<li>  带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li>
<li>  纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li>
<li>  百分比：将计算后的值传递给后代</li>
</ul>
</li>
</ol>
<h3 id="21-CSS-优化和提高性能的方法有哪些？"><a href="#21-CSS-优化和提高性能的方法有哪些？" class="headerlink" title="21. CSS 优化和提高性能的方法有哪些？"></a>21. CSS 优化和提高性能的方法有哪些？</h3><ul>
<li><strong>加载性能：</strong><ol>
<li> css压缩：将写好的css进行打包压缩，可以减小文件体积。</li>
<li> css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。</li>
<li> 减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li>
</ol>
</li>
<li><strong>选择器性能：</strong><ol>
<li> 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li>
<li> 如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li>
<li> 避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</li>
<li> 尽量少的去对标签进行选择，而是用class。</li>
<li> 尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li>
<li> 了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li>
</ol>
</li>
<li><strong>渲染性能：</strong><ol>
<li> 慎重使用高性能属性：浮动、定位。</li>
<li> 尽量减少页面重排、重绘。</li>
<li> 去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li>
<li> 属性值为0时，不加单位。</li>
<li> 属性值为浮动小数0.**，可以省略小数点之前的0。</li>
<li> 标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li>
<li> 不使用@import前缀，它会影响css的加载速度。</li>
<li> 选择器优化嵌套，尽量避免层级过深。</li>
<li> css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li>
<li> 正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li>
<li> 不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li>
</ol>
</li>
<li><strong>可维护性、健壮性：</strong><ol>
<li> 将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li>
<li> 样式与内容分离：将css代码定义到外部css中。</li>
</ol>
</li>
</ul>
<h3 id="22-CSS预处理器-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器/后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器/后处理器是什么？为什么要使用它们？</h3><p>参考：<a href="https://juejin.cn/post/7005755782926958605#heading-4%EF%BC%8Chttps://juejin.cn/post/7001860784586227720#heading-8">https://juejin.cn/post/7005755782926958605#heading-4，https://juejin.cn/post/7001860784586227720#heading-8</a></p>
<p><strong>预处理器，</strong> 如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p>
<p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p>
<p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p>
<p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p>
<p>使用原因：</p>
<ul>
<li>  结构清晰， 便于扩展</li>
<li>  可以很方便的屏蔽浏览器私有语法的差异</li>
<li>  可以轻松实现多重继承</li>
<li>  完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li>
</ul>
<h3 id="23-before-和-after-的双冒号和单冒号有什么区别？"><a href="#23-before-和-after-的双冒号和单冒号有什么区别？" class="headerlink" title="23. ::before 和 :after 的双冒号和单冒号有什么区别？"></a>23. ::before 和 :after 的双冒号和单冒号有什么区别？</h3><p>参考：<a href="https://juejin.cn/post/6992961262560739364#heading-7">https://juejin.cn/post/6992961262560739364#heading-7</a></p>
<ol>
<li> 冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素。 </li>
<li> <code>::before</code>就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在于页面之中。</li>
</ol>
<p><strong>注意：</strong> <code>:before </code>和 <code>:after</code> 这两个伪元素，是在<code>CSS2.1</code>里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着<code>Web</code>的进化，在<code>CSS3</code>的规范里，伪元素的语法被修改成使用双冒号，成为<code>::before</code>、<code>::after</code>。</p>
<h3 id="24-display-inline-block-什么时候会显示间隙？"><a href="#24-display-inline-block-什么时候会显示间隙？" class="headerlink" title="24. display:inline-block 什么时候会显示间隙？"></a>24. display:inline-block 什么时候会显示间隙？</h3><p>参考：<a href="https://juejin.cn/post/6979864063257870344">https://juejin.cn/post/6979864063257870344</a></p>
<ul>
<li>  元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据white-space的处理方式（默认是normal，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，空白符占据一定宽度，所以inline-block的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素font-size:16px时，间距为8px。</li>
<li>解决：<ol>
<li> 将html标签要display:inline-block 的元素写在一行。缺点：代码可读性差。</li>
<li> 给父元素设置font-size:0,给子元素设置需要的font-size值。缺点:是子元素如果里面有文字，文字会消失不见，所以又要给子元素设置font-size,增加了代码量。</li>
<li> 给元素设置float:left。缺点:高度塌陷，要清楚浮动。</li>
<li> 设置子元素的margin-left为负值，但是元素之间的间隙大小是根据上下文的字体大小确定的，而每个浏览器的换行空隙大小不同，所以这个方法不通用。</li>
<li> 设置父元素 display:table;word-spacing:-1em;目前这个方法可以完美解决，且兼容其他浏览器。</li>
</ol>
</li>
</ul>
<h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul>
<li><p> 单行文本溢出：</p>
   <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure></li>
<li><p>多行文本溢出：<a href="https://juejin.cn/post/6963904955262435336">https://juejin.cn/post/6963904955262435336</a></p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-line-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure>

<p>  注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p>
</li>
</ul>
<h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p>
<p><strong>为什么要使用它们？</strong></p>
<ul>
<li>  结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</li>
<li>  可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li>
</ul>
<h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p><a href="https://juejin.cn/post/6971013190524076069">https://juejin.cn/post/6971013190524076069</a></p>
<p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。</p>
<p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- link元素中的CSS媒体查询 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 800px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;example.css&quot;</span> /&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 样式表中的CSS媒体查询 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> </span></span><br><span class="line"><span class="css"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123; </span></span><br><span class="line"><span class="css">  <span class="selector-class">.facet_sidebar</span> &#123; </span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: none; </span></span><br><span class="line"><span class="css">  &#125; </span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p>
<h3 id="28-对-CSS-工程化的理解"><a href="#28-对-CSS-工程化的理解" class="headerlink" title="28. 对 CSS 工程化的理解"></a>28. 对 CSS 工程化的理解</h3><p>CSS 工程化是为了解决以下问题：</p>
<ol>
<li> <strong>宏观设计</strong>：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li>
<li> <strong>编码优化</strong>：怎样写出更好的 CSS？</li>
<li> <strong>构建</strong>：如何处理我的 CSS，才能让它的打包结果最优？</li>
<li> <strong>可维护性</strong>：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li>
</ol>
<p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p>
<ul>
<li>  预处理器：Less、 Sass 等；</li>
<li>  重要的工程化插件： PostCss；</li>
<li>  Webpack loader 等 。</li>
</ul>
<p>基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：</p>
<p><strong>（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？</strong></p>
<p>预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码： </p>
<p><img src="/2021/11/27/css/02-28-1.png"></p>
<p>那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：</p>
<ol>
<li> 宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；</li>
<li> 编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；</li>
<li> 可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。</li>
</ol>
<p>这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：</p>
<ul>
<li>  嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；</li>
<li>  支持定义 css 变量；</li>
<li>  提供计算函数；</li>
<li>  允许对代码片段进行 extend 和 mixin；</li>
<li>  支持循环语句的使用；</li>
<li>  支持将 CSS 文件模块化，实现复用。</li>
</ul>
<p><strong>（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</strong></p>
<p><img src="/2021/11/27/css/02-28-2.png" alt="img"> 它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。</p>
<p>PostCss 在业务中的使用场景非常多：</p>
<ul>
<li>  提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li>
<li>  当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 <a href="https://link.juejin.cn/?target=https://github.com/postcss/autoprefixer">Autoprefixer</a> 插件可以帮助我们自动增加浏览器前缀；</li>
<li>  允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li>
</ul>
<p><strong>（3）Webpack 能处理 CSS 吗？如何实现？</strong> Webpack 能处理 CSS 吗：</p>
<ul>
<li>  <strong>Webpack 在裸奔的状态下，是不能处理 CSS 的</strong>，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；</li>
<li>  Webpack 在 loader 的辅助下，是可以处理 CSS 的。</li>
</ul>
<p>如何用 Webpack 实现对 CSS 的处理：</p>
<ul>
<li>  Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</li>
<li>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：<ul>
<li>  css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；</li>
<li>  style-loader：创建style标签，把 CSS 内容写入标签。</li>
</ul>
</li>
</ul>
<p>在实际使用中，<strong>css-loader 的执行顺序一定要安排在 style-loader 的前面</strong>。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</p>
<h3 id="29-如何判断元素是否到达可视区域"><a href="#29-如何判断元素是否到达可视区域" class="headerlink" title="29. 如何判断元素是否到达可视区域"></a>29. 如何判断元素是否到达可视区域</h3><p>以图片显示为例：</p>
<ul>
<li>  <code>window.innerHeight</code> 是浏览器可视区的高度；</li>
<li>  <code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离；</li>
<li>  <code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）；</li>
<li>  内容达到显示区域的：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></li>
</ul>
<p><img src="/2021/11/27/css/02-29.png"></p>
<h3 id="30-z-index属性在什么情况下会失效"><a href="#30-z-index属性在什么情况下会失效" class="headerlink" title="30. z-index属性在什么情况下会失效"></a>30. z-index属性在什么情况下会失效</h3><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p>
<p>z-index属性在下列情况下会失效：</p>
<ul>
<li>  父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li>
<li>  元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li>
<li>  元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li>
</ul>
<h3 id="31-CSS3中的transform有哪些属性"><a href="#31-CSS3中的transform有哪些属性" class="headerlink" title="31. CSS3中的transform有哪些属性"></a>31. CSS3中的transform有哪些属性</h3><p>见14</p>
<h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><ul>
<li><p>绝对单位</p>
<ol>
<li> in（英寸）</li>
<li> cm（厘米）</li>
<li> mm（毫米）</li>
<li> pt（points）</li>
<li> pc（Picas）</li>
</ol>
<p>  1in = 2.54cm = 25.4 mm = 72pt = 6pc</p>
</li>
<li><p>相对单位</p>
<ol>
<li><p>像素（px），是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p>
<ul>
<li>  CSS像素：为web开发者提供，在CSS中使用的一个抽象单位；</li>
<li>  物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的。（绝对单位）</li>
</ul>
<p> px是相对单位，因为1px在不同设备上渲染的物理像素数量不一致，不同设备上一个物理像素的大小也不一致。为保证阅读体验一致，CSS的px 相对 物理像素 是动态的，px和物理像素之间的关系根据设备像素比（DPR）确定。</p>
</li>
<li><p> 百分比（%），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p>
</li>
<li><p>em和rem相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：em相对于父元素，rem相对于根元素。</p>
<ul>
<li>  em： 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li>
<li>  rem： rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。当根元素未设置font-size值时，默认取16px。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li>
</ul>
</li>
<li><p>vw/vh是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p>
<ul>
<li>  vw：相对于视窗的宽度，视窗宽度是100vw；</li>
<li>  vh：相对于视窗的高度，视窗高度是100vh；</li>
<li>  vmin：vw和vh中的较小值；</li>
<li>  vmax：vw和vh中的较大值；</li>
</ul>
</li>
<li><p> ex：表示元素内字符x的高度，一个小写字母，比如“d”，它会有一部分高出来，ex不包括高出来的这一部分的。</p>
</li>
<li><p> ch：表示元素内数字0的宽度</p>
</li>
</ol>
</li>
</ul>
<p>注意：</p>
<ul>
<li>  影响em变化的因素只有font-size，而影响 ex、ch 变化的因素除font-size外还有font-family，因为font-family的改变也会使得x或者0字符的大小发生变化。</li>
<li>vw/vh 和百分比很类似，两者的区别：<ul>
<li>  百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li>
<li>  vw/vm：相对于视窗的尺寸</li>
</ul>
</li>
</ul>
<h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p>
<ul>
<li>  px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li>
<li>  em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li>
<li>  em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>  对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li>
<li>  对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li>
</ul>
<h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>基本样式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>123-边框图片<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: <span class="number">1px</span> dashed <span class="number">#ff6c60</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">    左边固定宽度，高度不固定 <span class="tag">&lt;/<span class="name">br</span>&gt;</span> <span class="tag">&lt;/<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span>高度有可能会很小，也可能很大。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">    这里的内容可能比左侧高，也可能比左侧低。宽度需要自适应。<span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    基本的样式是，两个div相距20px, 左侧div宽 120px</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>双<code>inline-block</code>方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-inline-block</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;	// 消除空格的影响</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-inline-block</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.wrapper-inline-block</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;	// 顶端对齐</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-inline-block</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">140px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这种方法是通过<code>width: calc(100% - 140px)</code>来动态计算右侧盒子的宽度。需要知道右侧盒子距离左边的距离，以及左侧盒子具体的宽度(content+padding+border)，以此计算父容器宽度的<code>100%</code>需要减去的数值。同时，还需要知道右侧盒子的宽度是否包含<code>border</code>的宽度。 在这里，为了简单的计算右侧盒子准确的宽度，设置了子元素的<code>box-sizing:border-box;</code>以及父元素的<code>box-sizing: content-box;</code>。 同时，作为两个<code>inline-block</code>的盒子，必须设置<code>vertical-align</code>来使其顶端对齐。 另外，为了<strong>准确地应用</strong>计算出来的宽度，需要消除<code>div</code>之间的空格，需要通过设置父容器的<code>font-size: 0;</code>,或者用注释消除<code>html</code>中的空格等方法。 <strong>缺点:</strong></p>
<ul>
<li>  需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的<code>box-sizing</code></li>
<li>  需要消除空格字符的影响</li>
<li>  需要设置<code>vertical-align: top</code>满足顶端对齐。</li>
</ul>
</li>
<li><p>双<code>float</code>方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-double-float</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;		// 清除浮动</span><br><span class="line">    <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-double-float</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.wrapper-double-float</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-double-float</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">140px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 本方案和双<code>float</code>方案原理相同，都是通过动态计算宽度来实现自适应。但是，由于浮动的<code>block</code>元素在有空间的情况下会<a href="https://www.w3.org/TR/CSS21/visuren.html#bfc-next-to-float">依次紧贴，排列在一行</a>，所以无需设置<code>display: inline-block;</code>，自然也就少了顶端对齐，空格字符占空间等问题。</p>
<p> 不过由于应用了浮动，父元素需要清除浮动。 <strong>缺点:</strong></p>
<ul>
<li>  需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的<code>box-sizing</code>。</li>
<li>  父元素需要清除浮动。</li>
</ul>
</li>
<li><p><code>float+margin-left</code>方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-float</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;   // 清除浮动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面两种方案都是利用了CSS的<code>calc()</code>函数来计算宽度值。下面两种方案则是利用了<code>block</code>级别的元素盒子的宽度具有<strong>填满父容器，并随着父容器的宽度自适应</strong>的<strong>流动特性</strong>。 但是<code>block</code>级别的元素都是独占一行的，所以要想办法让两个<code>block</code>排列到一起。 我们知道，<code>block</code>级别的元素会认为浮动的元素不存在，但是<code>inline</code>级别的元素能识别到浮动的元素。这样，<code>block</code>级别的元素就可以和浮动的元素同处一行了。 为了让右侧盒子和左侧盒子保持距离，需要为左侧盒子留出足够的距离。这个距离的大小为左侧盒子的宽度以及两个盒子之间的距离之和。然后将该值设置为右侧盒子的<code>margin-left</code>。 <strong>缺点：</strong></p>
<ul>
<li>  需要清除浮动</li>
<li>  需要计算右侧盒子的<code>margin-left</code></li>
</ul>
</li>
<li><p>使用absolute+margin-left方法</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-absolute</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-absolute</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>缺点:</strong></p>
<ul>
<li>  使用了绝对定位，若是用在某个div中，需要更改父容器的<code>position</code>。</li>
<li>  没有清除浮动的方法，若左侧盒子高于右侧盒子，就会超出父容器的高度。因此只能通过设置父容器的<code>min-height</code>来放置这种情况。</li>
</ul>
</li>
<li><p>使用float+BFC方法</p>
<p> 上面的方法都需要通过左侧盒子的宽度，计算某个值，下面三种方法都是不需要计算的。只需要设置两个盒子之间的间隔。</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-float-bfc</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float-bfc</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float-bfc</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个方案同样是利用了左侧浮动，但是右侧盒子通过<code>overflow: auto;</code>形成了BFC，因此右侧盒子不会与浮动的元素重叠。</p>
<p> 这种情况下，只需要为左侧的浮动盒子设置<code>margin-right</code>，就可以实现两个盒子的距离了。而右侧盒子是<code>block</code>级别的，所以宽度能实现自适应。 <strong>缺点:</strong></p>
<ul>
<li>  父元素需要清除浮动</li>
</ul>
</li>
<li><p>flex方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-flex</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-flex</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-flex</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> flex可以说是最好的方案了，代码少，使用简单。有朝一日，大家都改用现代浏览器，就可以使用了。 需要注意的是，flex容器的一个默认属性值:align-items: stretch;。这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start;</p>
</li>
<li><p>grid方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-grid</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">120px</span> <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    grid-column: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    grid-column: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意:</p>
<ul>
<li>  grid布局也有列等高的默认效果。需要设置: align-items: start;。</li>
<li>  grid布局还有一个值得注意的小地方和flex不同:在使用margin-left的时候，grid布局默认是box-sizing设置的盒宽度之间的位置。而flex则是使用两个div的border或者padding外侧之间的距离。</li>
</ul>
</li>
</ol>
<p><strong>极限情况</strong></p>
<p>最后可以再看一下在父容器极限小的情况下，不同方案的表现。主要分成四种情况：</p>
<ul>
<li><p>动态计算宽度的情况</p>
<p>  两种方案: 双inline-block方案和双float方案。宽度极限小时，右侧的div宽度会非常小，由于遵循流动布局，所以右侧div会移动到下一行。</p>
</li>
<li><p>动态计算右侧margin-left的情况</p>
<p>  两种方案: float+margin-left方案和absolute+margin-left方案。宽度极限小时，由于右侧的div忽略了文档流中左侧div的存在，所以其依旧会存在于这一行，并被隐藏。</p>
</li>
<li><p><code>float+BFC</code>方案的情况</p>
<p>  这种情况下，由于BFC与float的特殊关系，右侧div在宽度减小到最小后，也会掉落到下一行。</p>
</li>
<li><p><code>flex</code>和<code>grid</code>的情况</p>
<p>  这种情况下，默认两种布局方式都不会放不下的div移动到下一行。不过 flex布局可以通过 flex-flow: wrap;来设置多余的div移动到下一行。 grid布局暂不支持。</p>
</li>
</ul>
<p>参考：<a href="https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/">https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/</a></p>
<h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><ol>
<li><p>float 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.output</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">min-width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.side</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.side-left</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.side-right</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">          <span class="comment">/* width: calc(100%-600px); */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">600px</span>);</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- calc() 函数用于动态计算长度值。</span></span><br><span class="line"><span class="comment">需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)； --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;output&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;side side-left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;div class=&quot; mid&quot;&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;side side-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>position 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.output</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="comment">/* left: 300px;</span></span></span><br><span class="line"><span class="comment"><span class="css">          width: calc(100% - 600px); */</span></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">          <span class="comment">/* 兼容性最好的写法： */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">right</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;output&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>table 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>:orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>:lightblue;</span></span><br><span class="line"><span class="css">          <span class="comment">/* 继承父类的剩余部分 */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>flex 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orchid;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="comment">/* flex: 1; */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">flex</span>: auto;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>grid 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="css">          grid-template-rows: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          grid-template-<span class="attribute">columns</span>:<span class="number">300px</span> auto <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="comment">/* grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 */</span></span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: lightgoldenrodyellow;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>圣杯布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>144-圣杯布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      *&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">min-width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background</span>: purple;</span></span><br><span class="line"><span class="css">          <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1.什么是圣杯布局和双飞翼布局</span></span><br><span class="line"><span class="comment">两者实现的功能都一样, 都是用于实现两侧的宽度不变, 中间的宽度自适应的三栏布局的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.圣杯布局的步骤</span></span><br><span class="line"><span class="comment">2.1搞一个容器, 里面放三个盒子</span></span><br><span class="line"><span class="comment">2.2设置两侧盒子的宽度(固定)</span></span><br><span class="line"><span class="comment">2.3设置中间盒子的宽度等于容器的宽度(100%)</span></span><br><span class="line"><span class="comment">2.4设置容器的padding等于两侧盒子的宽度</span></span><br><span class="line"><span class="comment">2.5让三个盒子都在同一个方向上浮动</span></span><br><span class="line"><span class="comment">2.6设置左边盒子的margin-left=-100%</span></span><br><span class="line"><span class="comment">2.7通过定位调整左边的盒子, 让左边的盒子不要盖住中间的区域</span></span><br><span class="line"><span class="comment">2.8设置右边盒子的margin-left=-自身的宽度</span></span><br><span class="line"><span class="comment">2.9通过定位调整右边的盒子, 让右边的盒子不要盖住中间的区域</span></span><br><span class="line"><span class="comment">3.0给容器设置一个最小的宽度, 防止缩小后变形</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>双飞翼布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>145-双飞翼布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        *&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span>&gt;<span class="selector-class">.center-in</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: purple;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1.双飞翼布局的实现步骤</span></span><br><span class="line"><span class="comment">1.1搞一个容器, 里面放三个盒子</span></span><br><span class="line"><span class="comment">1.2设置两侧盒子的宽度(固定)</span></span><br><span class="line"><span class="comment">1.3设置中间盒子的宽度等于容器的宽度(100%)</span></span><br><span class="line"><span class="comment">1.4让三个盒子都在同一个方向上浮动</span></span><br><span class="line"><span class="comment">1.5给中间的盒子添加一个子盒子</span></span><br><span class="line"><span class="comment">1.6给子盒子设置margin 0 两侧盒子的宽度</span></span><br><span class="line"><span class="comment">   由于是给子盒子设置margin,所以不会对父盒子排版产生任何影响</span></span><br><span class="line"><span class="comment">1.7设置左边盒子的margin-left=-100%</span></span><br><span class="line"><span class="comment">1.8设置右边盒子的margin-left=-自身的宽度</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center-in&quot;</span>&gt;</span>中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-水平垂直居中的实现"><a href="#5-水平垂直居中的实现" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul>
<li><p>水平居中</p>
<ul>
<li><p>行内元素</p>
<ol>
<li> 给父元素设置 text-align:center,即可实现行内元素水平居中</li>
</ol>
</li>
<li><p>块级元素</p>
<ol>
<li><p> 该元素设置 margin:0 auto即可</p>
</li>
<li><p>若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: -moz-fit-content;</span><br><span class="line">    <span class="attribute">width</span>: -webkit-fit-content;</span><br><span class="line">    <span class="attribute">width</span>:fit-content;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器</p>
</li>
<li><p>使用flex 2012年版本布局, 可以轻松的实现水平居中, 子元素设置如下</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用flex 2009年版本, 父元素display: box;box-pack: center;如下设置:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    -webkit-box-orient: horizontal;</span><br><span class="line">    -webkit-box-pack: center;</span><br><span class="line">    <span class="attribute">display</span>: -moz-box;</span><br><span class="line">    -moz-box-orient: horizontal;</span><br><span class="line">    -moz-box-pack: center;</span><br><span class="line">    <span class="attribute">display</span>: -o-box;</span><br><span class="line">      -o-box-orient: horizontal;</span><br><span class="line">      -o-box-pack: center;</span><br><span class="line">      <span class="attribute">display</span>: -ms-box;</span><br><span class="line">      -ms-box-orient: horizontal;</span><br><span class="line">      -ms-box-pack: center;</span><br><span class="line">      <span class="attribute">display</span>: box;</span><br><span class="line">      box-orient: horizontal;</span><br><span class="line">      box-pack: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用CSS3中新增的transform属性, 子元素设置如下:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">      <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用绝对定位方式, 以及负值的margin-left, 子元素设置如下:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">width</span>:固定;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">0.5</span>宽度;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">width</span>:固定;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>垂直居中</p>
<ul>
<li><p>单行文本</p>
<ol>
<li> 设置 line-height 等于父元素高度</li>
</ol>
</li>
<li><p>行内块级元素</p>
<ol>
<li><p>若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span>, <span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>元素高度不定</p>
<ol>
<li><p>可用 <strong>vertical-align</strong> 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的。 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle;</p>
<ul>
<li>  <strong>优点</strong>：元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断。</li>
<li>  <strong>缺点</strong>：IE6~7, 甚至IE8 beta中无效。</li>
</ul>
</li>
<li><p>可用 <strong>Flex 2012版</strong>, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《<a href="https://link.juejin.cn/?target=http://louiszhai.github.io/2017/01/13/flex/">弹性盒模型Flex指南</a>》</p>
<p> 父元素做如下设置即可保证子元素垂直居中:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>优点</strong></p>
<ul>
<li><p>  内容块的宽高任意, 优雅的溢出.</p>
</li>
<li><p>  可用于更复杂高级的布局技术中.</p>
</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li>  IE8/IE9不支持</li>
<li>  需要浏览器厂商前缀</li>
<li>  渲染上可能会有一些问题</li>
</ul>
</li>
</ul>
</li>
<li><p>使用flex 2009版.</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: box;</span><br><span class="line">      box-orient: vertical;</span><br><span class="line">      box-pack: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>优点</strong>：实现简单, 扩展性强</li>
<li>  <strong>缺点</strong>：兼容性差, 不支持IE</li>
</ul>
</li>
<li><p>可用 <strong>transform</strong> , 设置父元素相对定位(position:relative), 子元素如下css样式：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);  </span><br><span class="line">    -ms-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>优点</strong>：代码量少</li>
<li>  <strong>缺点</strong>：IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象</li>
</ul>
</li>
</ol>
</li>
<li><p>元素高度固定</p>
<ol>
<li><p>设置父元素相对定位(position:relative), 子元素如下css样式:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>:固定;</span><br><span class="line">    <span class="attribute">margin-top</span>:-<span class="number">0.5</span>高度;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>优点</strong>：适用于所有浏览器.</li>
<li>  <strong>缺点</strong>：父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条</li>
</ul>
</li>
<li><p>  设置父元素相对定位(position:relative), 子元素如下css样式:</p>
</li>
</ol>
<pre><code>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">height</span>:固定;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>:auto <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  -   **优点**：简单
  -   **缺点**：没有足够空间时, 子元素会被截断, 但不会有滚动条.
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p>
<ul>
<li>  <strong>适配不同像素密度，</strong> 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li>
<li>  <strong>适配不同屏幕大小，</strong> 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li>
</ul>
<p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p>
<p><a href="https://www.cnblogs.com/zhangnan35/p/12682925.html">https://www.cnblogs.com/zhangnan35/p/12682925.html</a></p>
<h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p>
<p>以下6个属性设置在<strong>容器上</strong>：</p>
<ul>
<li>  flex-direction属性决定主轴的方向（即项目的排列方向）。</li>
<li>  flex-wrap属性定义，如果一条轴线排不下，如何换行。</li>
<li>  flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li>
<li>  justify-content属性定义了项目在主轴上的对齐方式。</li>
<li>  align-items属性定义项目在交叉轴上如何对齐。</li>
<li>  align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>
</ul>
<p>以下6个属性设置在<strong>项目上</strong>：</p>
<ul>
<li>  order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>
<li>  flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>
<li>  flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>  flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li>
<li>  flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li>
<li>  align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
<p><strong>简单来说：</strong> flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p>
<h3 id="8-响应式设计的概念及基本原理"><a href="#8-响应式设计的概念及基本原理" class="headerlink" title="8. 响应式设计的概念及基本原理"></a>8. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p>
<p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。 关于兼容： 页面头部必须有meta声明的<code>viewport</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;’viewport’&quot;</span> <span class="attr">content</span>=<span class="string">&quot;”width=device-width,&quot;</span> <span class="attr">initial-scale</span>=<span class="string">&quot;1.&quot;</span> <span class="attr">maximum-scale</span>=<span class="string">&quot;1,user-scalable=no”&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p>
<p><strong>浮动的工作原理：</strong></p>
<ul>
<li>  浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li>
<li>  浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li>
</ul>
<p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p>
<p><strong>浮动元素引起的问题？</strong></p>
<ul>
<li>  父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>  与浮动元素同级的非浮动元素会跟随其后</li>
<li>  若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li>
</ul>
<p><strong>清除浮动的方式如下：</strong><a href="https://juejin.cn/post/6992534186347216909#heading-3">https://juejin.cn/post/6992534186347216909#heading-3</a></p>
<ul>
<li>  给父级div定义<code>height</code>属性</li>
<li>  最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li>
<li>  包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li>
<li>  使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout，从而使元素获得清除浮动的特性。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">    content: <span class="string">&quot;\200B&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用-clear-属性清除浮动的原理？"><a href="#2-使用-clear-属性清除浮动的原理？" class="headerlink" title="2. 使用 clear 属性清除浮动的原理？"></a>2. 使用 clear 属性清除浮动的原理？</h3><p>使用clear属性清除浮动，其语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clear</span>:none|left|right|both</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p>
<p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p>
<p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p>
<p>一般使用伪元素的方式清除浮动：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;  </span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;  </span><br><span class="line">    <span class="attribute">display</span>: block;   </span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p>
<h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p>
<ul>
<li>  Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。</li>
<li>  Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li>
</ul>
<p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p>
<p><strong>创建BFC的条件：</strong></p>
<ul>
<li>  根元素：body；</li>
<li>  元素设置浮动：float 除 none 以外的值；</li>
<li>  元素设置绝对定位：position (absolute、fixed)；</li>
<li>  display 值为：inline-block、table-cell、table-caption、flex等；</li>
<li>  overflow 值为：hidden、auto、scroll；</li>
</ul>
<p><strong>BFC的特点：</strong></p>
<ul>
<li>  垂直方向上，自上而下排列，和文档流的排列方式一致。</li>
<li>  在BFC中上下相邻的两个容器的margin会重叠</li>
<li>  计算BFC的高度时，需要计算浮动元素的高度</li>
<li>  BFC区域不会与浮动的容器发生重叠</li>
<li>  BFC是独立的容器，容器内部元素不会影响外部元素</li>
<li>  每个元素的左margin值和容器的左border相接触</li>
</ul>
<p><strong>BFC的作用：</strong></p>
<ul>
<li>  <strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li>
<li>  <strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li>
<li>  <strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p>
<h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong> 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p>
<p><strong>计算原则：</strong> 折叠合并后外边距的计算原则如下：</p>
<ul>
<li>  如果两者都是正数，那么就去最大者</li>
<li>  如果是一正一负，就会正值减去负值的绝对值</li>
<li>  两个都是负值时，用0减去两个中绝对值大的那个</li>
</ul>
<p><strong>解决办法：</strong> 对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong> </p>
<ol>
<li>兄弟之间重叠<ul>
<li>  底部元素变为行内盒子：<code>display: inline-block</code></li>
<li>  底部元素设置浮动：<code>float</code></li>
<li>  底部元素的position的值为<code>absolute/fixed</code></li>
</ul>
</li>
<li>父子之间重叠<ul>
<li>  父元素加入：<code>overflow: hidden</code></li>
<li>  父元素添加透明边框：<code>border:1px solid transparent</code></li>
<li>  子元素变为行内盒子：<code>display: inline-block</code></li>
<li>  子元素加入浮动属性或定位</li>
</ul>
</li>
</ol>
<h3 id="5-元素的层叠顺序"><a href="#5-元素的层叠顺序" class="headerlink" title="5. 元素的层叠顺序"></a>5. 元素的层叠顺序</h3><p>参考：<a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/</a></p>
<p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p>
<p><img src="/2021/11/27/css/02-3-5.png" alt="02-3-5"></p>
<p>上图，由上到下分别是： </p>
<ol>
<li> 背景和边框：建立当前层叠上下文元素的背景和边框。 </li>
<li> 负的z-index：当前层叠上下文中，z-index属性值为负的元素。 </li>
<li> 块级盒：文档流内非行内级非定位后代元素。</li>
<li> 浮动盒：非定位浮动元素。 </li>
<li> 行内盒：文档流内行内级非定位后代元素。 </li>
<li> z-index:0：层叠级数为0的定位元素。 </li>
<li> 正z-index：z-index属性值为正的定位元素。</li>
</ol>
<p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p>
<h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><table>
<thead>
<tr>
<th>属性值</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>absolute</td>
<td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td>
</tr>
<tr>
<td>fixed</td>
<td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td>
</tr>
<tr>
<td>static</td>
<td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定从父元素继承position属性的值</td>
</tr>
<tr>
<td>sticky</td>
<td>元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。<br />该值总是创建一个新的<a href="https://developer.mozilla.org/en/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context">层叠上下文（stacking context</a>）。注意，一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的<code>overflow</code> 是 <code>hidden</code>, <code>scroll</code>, <code>auto</code>, 或 <code>overlay</code>时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为</td>
</tr>
</tbody></table>
<p>前面三者的定位方式如下：</p>
<ul>
<li><p>  <strong>relative：</strong> 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</p>
</li>
<li><p>  <strong>fixed：</strong> 元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</p>
</li>
<li><p>  <strong>absolute：</strong> 元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。</p>
</li>
</ul>
<h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. display、float、position的关系</h3><ol>
<li> 首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</li>
<li> 然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</li>
<li> 如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</li>
<li> 如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</li>
</ol>
<p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p>
<h3 id="8-absolute与fixed共同点与不同点"><a href="#8-absolute与fixed共同点与不同点" class="headerlink" title="8. absolute与fixed共同点与不同点"></a>8. absolute与fixed共同点与不同点</h3><p><strong>共同点：</strong></p>
<ul>
<li>  改变行内元素的呈现方式，将display置为inline-block </li>
<li>  使元素脱离普通文档流，不再占据文档物理空间</li>
<li>  覆盖非定位文档元素</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>  abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</li>
<li>  在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</li>
</ul>
<h3 id="9-对-sticky-定位的理解"><a href="#9-对-sticky-定位的理解" class="headerlink" title="9. 对 sticky 定位的理解"></a>9. 对 sticky 定位的理解</h3><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：<strong>position: sticky;</strong> 基于用户的滚动位置来定位。</p>
<p>粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>
<p><strong>参考</strong>：<a href="https://juejin.cn/post/6844903973627887624#comment">https://juejin.cn/post/6844903973627887624#comment</a></p>
<p><strong>基本概念</strong></p>
<ul>
<li><p>流盒</p>
<p>  指的是粘性定位元素最近的<code>可滚动元素</code>（overflow属性值不是visible的元素）的尺寸盒子，如果没有可滚动元素，则表示浏览器视窗盒子。</p>
</li>
<li><p>粘性约束矩形</p>
<p>  即粘性布局元素的父级元素矩形</p>
</li>
</ul>
<p><strong>特性</strong></p>
<ul>
<li>  当粘性约束矩形在可视范围内为<code>relative</code>，反之，则为<code>fixed</code></li>
<li>  粘性定位元素如果和它的父元素一样高，则垂直滚动的时候，粘性定位效果是不会出现的</li>
<li>  它的定位效果完全受限于父级元素们。如果父元素的<code>overflow</code>属性设置了<code>scroll</code>，<code>auto</code>,<code>overlay</code>值，那么，粘性定位将会失效</li>
<li>  同一容器中多个粘贴定位元素独立偏移，因此可能重叠；位置上下靠在一起的不同容器中的粘贴定位元素则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li>
</ul>
<h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><ol>
<li><p>border：平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是由三角形组成的，将其它边的边框设置成透明即可</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid green;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>clip-path剪裁</p>
<p> <code>clip-path</code>属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</p>
<p> <code>clip-path</code>的语法有四种：</p>
<ul>
<li>  inset（定义矩形）</li>
<li>  circle（定义圆）</li>
<li>  ellipse（定义椭圆）</li>
<li>  polygon（定义多边形）</li>
</ul>
<p> polygon的值为多个坐标点组成，坐标第一个值是x方向，第二个值是y方向。左上角是原点，右下角是(100%,100%)的点</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: cyan;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">100%</span>, <span class="number">50%</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">100%</span>);    // 对应三角形三个顶点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    heigt: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-top-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现一个宽高自适应的正方形"><a href="#3-实现一个宽高自适应的正方形" class="headerlink" title="3. 实现一个宽高自适应的正方形"></a>3. 实现一个宽高自适应的正方形</h3><ol>
<li><p>利用vw来实现：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用元素的margin/padding百分比是相对父元素width的性质来实现：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用子元素的margin-top的值来实现：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-画一条0-5px的线"><a href="#4-画一条0-5px的线" class="headerlink" title="4. 画一条0.5px的线"></a>4. 画一条0.5px的线</h3><ul>
<li><p>  <strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：<code>transform: scale(0.5,0.5);</code></p>
</li>
<li><p>  <strong>采用meta viewport的方式</strong>，<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;/&gt;</code>，这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p>
</li>
</ul>
<h3 id="5-设置小于12px的字体"><a href="#5-设置小于12px的字体" class="headerlink" title="5. 设置小于12px的字体"></a>5. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>  使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li>
<li>  使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</li>
<li>  使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li>
</ul>
<h3 id="6-如何解决-1px-问题？"><a href="#6-如何解决-1px-问题？" class="headerlink" title="6. 如何解决 1px 问题？"></a>6. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">window.devicePixelRatio = 设备的物理像素 / CSS像素。</span><br></pre></td></tr></table></figure>

<p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2。 这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 </p>
<p><strong>解决1px 问题的三种思路：</strong></p>
<p><strong>思路一</strong>：直接写 0.5px</p>
<p>如果之前 1px 的样式这样写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span></span><br></pre></td></tr></table></figure>

<p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="built_in">window</span>.devicePixelRatio&#125;&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">0.5px</span> solid <span class="number">#333</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p>
<p><strong>思路二</strong>：伪元素先放大后缩小</p>
<p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p>
<p>思路是<strong>先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。</strong></p>
<p>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">      <span class="attribute">position</span>:absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">      <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">      <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路三</strong>：viewport 缩放来解决</p>
<p>这个思路就是对 meta 标签里几个关键属性下手：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span></span><br><span class="line">metaEl.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">`width=device-width,user-scalable=no,initial-scale=<span class="subst">$&#123;scale&#125;</span>,maximum-scale=<span class="subst">$&#123;scale&#125;</span>,minimum-scale=<span class="subst">$&#123;scale&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>
<h3 id="7-纯CSS实现圆角三角形"><a href="#7-纯CSS实现圆角三角形" class="headerlink" title="7. 纯CSS实现圆角三角形"></a>7. 纯CSS实现圆角三角形</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.rounded-triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">30%</span>;    // 圆角弧度</span><br><span class="line">    <span class="attribute">background</span>: cyan;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">60</span>edg) <span class="built_in">skewX</span>(-<span class="number">30</span>edg) <span class="built_in">scale</span>(<span class="number">1</span>, .<span class="number">866</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.rounded-triangle</span>:before,</span><br><span class="line">    .rounded-triangle:after &#123;</span><br><span class="line">      content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">background-color</span>: inherit;</span><br><span class="line">      <span class="attribute">width</span>:  <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">border-top-right-radius</span>: <span class="number">30%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.rounded-triangle</span>:before &#123;</span><br><span class="line">      transform: <span class="built_in">rotate</span>(-<span class="number">135deg</span>) <span class="built_in">skewX</span>(-<span class="number">45deg</span>) <span class="built_in">scale</span>(<span class="number">1.414</span>, .<span class="number">707</span>) <span class="built_in">translate</span>(<span class="number">0</span>,-<span class="number">50%</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.rounded-triangle</span>:after &#123;</span><br><span class="line">      transform: <span class="built_in">rotate</span>(<span class="number">135deg</span>) <span class="built_in">skewY</span>(-<span class="number">45deg</span>) <span class="built_in">scale</span>(.<span class="number">707</span>, <span class="number">1.414</span>) <span class="built_in">translate</span>(<span class="number">50%</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h3>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
