<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>script标签defer和async的区别，还有哪些属性？</title>
    <url>/2021/11/21/script-attribute/</url>
    <content><![CDATA[<h2 id="1-defer-和-async-属性出现的意义"><a href="#1-defer-和-async-属性出现的意义" class="headerlink" title="1. defer 和 async 属性出现的意义"></a>1. defer 和 async 属性出现的意义</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>
<h3 id="1-1-defer-属性"><a href="#1-1-defer-属性" class="headerlink" title="1.1 defer 属性"></a>1.1 defer 属性</h3><p>推迟执行脚本。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</p>
<ul>
<li>  在 &lt;script&gt; 标签上设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。</li>
<li>  HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，并且会在 DOMContentLoaded 事件之前执行。不过在实际当中，不一定总会按照顺序或者在 DOMContentLoaded 事件之前执行。</li>
</ul>
<h3 id="1-2-async-属性（HTML5）"><a href="#1-2-async-属性（HTML5）" class="headerlink" title="1.2 async 属性（HTML5）"></a>1.2 async 属性（<strong>HTML5</strong>）</h3><p>异步执行脚本。表示应该立即请求脚本，并尽快解析和执行，但不能阻止其它页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</p>
<ul>
<li>  告诉浏览器立即下载，但不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行完后在加载其它脚本。（因此，异步脚本不应该在加载期间修改 DOM）</li>
<li>  标记为 async 的脚本并不保证能按照它们出现的次序执行。异步脚本保证会在页面的的 <strong>load</strong> 事件前执行，但可能会在 <strong>DOMContentLoaded</strong> 之前或之后。</li>
</ul>
<h2 id="2-lt-script-gt-标签其它属性"><a href="#2-lt-script-gt-标签其它属性" class="headerlink" title="2. &lt;script&gt; 标签其它属性"></a>2. &lt;script&gt; 标签其它属性</h2><h3 id="2-1-charset-属性"><a href="#2-1-charset-属性" class="headerlink" title="2.1 charset 属性"></a>2.1 charset 属性</h3><p>使用 src 属性指定的代码字符集。很少使用，因为大多数浏览器不在乎它的值。</p>
<h3 id="2-2-crossorigin-属性"><a href="#2-2-crossorigin-属性" class="headerlink" title="2.2 crossorigin 属性"></a>2.2 crossorigin 属性</h3><p>那些没有通过标准CORS (跨域资源共享)检查的正常script 元素传递最少的信息到 window.onerror。可以使用本属性来使那些将静态资源放在另外一个域名的站点打印错误信息。默认不使用 CORS，“” 相当于 “anonymous” ，对此元素的 CORS 请求不设置凭据标志；“use-credentials”，对此元素的 CORS 请求将设置凭证标志，这意味着请求将提供凭据。</p>
<h3 id="2-3-integrity-属性"><a href="#2-3-integrity-属性" class="headerlink" title="2.3 integrity 属性"></a>2.3 integrity 属性</h3><p>允许对比接收到的资源和指定的加密签名以验证子资源完整性（SRI）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN）不会提供恶意内容。</p>
<h3 id="2-4-nomodule-属性"><a href="#2-4-nomodule-属性" class="headerlink" title="2.4 nomodule 属性"></a>2.4 nomodule 属性</h3><p>这个布尔属性被设置来标明这个脚本在支持 ES2015 modules 的浏览器中不执行。实际上，这可用于在不支持模块化 JavaScript 的旧浏览器中提供回退脚本。</p>
<h3 id="2-5-language-属性"><a href="#2-5-language-属性" class="headerlink" title="2.5 language 属性"></a>2.5 language 属性</h3><p>废弃。最初用于表示代码块中的脚本语言。大多数浏览器都会忽略这个属性，不应该再使用它。</p>
<h3 id="2-6-src-属性"><a href="#2-6-src-属性" class="headerlink" title="2.6 src 属性"></a>2.6 src 属性</h3><p>定义引用外部脚本的URI，这可以用来代替直接在文档中嵌入脚本。指定了 src 属性的script元素标签内不应该再有嵌入的脚本。</p>
<h3 id="2-7-type-属性"><a href="#2-7-type-属性" class="headerlink" title="2.7 type 属性"></a>2.7 type 属性</h3><p>代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型：<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></strong>）。支持的MIME类型包括text/javascript, text/ecmascript, application/javascript（非IE支持）, 和application/ecmascript（非IE支持）。如果没有定义这个属性，脚本会被视作JavaScript。如果MIME类型不是JavaScript类型（上述支持的类型），则该元素所包含的内容会被当作数据块而不会被浏览器执行。JS 文件中的MIME 类型通常是 “application/x-javascript” 。如果type属性为module，代码会被当作JavaScript模块 。</p>
<h3 id="2-8-text-属性"><a href="#2-8-text-属性" class="headerlink" title="2.8 text 属性"></a>2.8 text 属性</h3><p>和 textContent 属性类似，本属性用于设置元素的文本内容。但和 textContent 不一样的是，本属性在节点插入到DOM之后，此属性被解析为可执行代码。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>html语义化理解及SEO</title>
    <url>/2021/11/22/html-semantic-seo/</url>
    <content><![CDATA[<h2 id="1-语义化"><a href="#1-语义化" class="headerlink" title="1. 语义化"></a>1. 语义化</h2><h3 id="1-1-含义"><a href="#1-1-含义" class="headerlink" title="1.1 含义"></a>1.1 含义</h3><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗的来讲就是正确的标签做正确的事情。</p>
<h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul>
<li>  对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li>
<li>  对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li>
</ul>
<h3 id="1-3-常见的语义化标签"><a href="#1-3-常见的语义化标签" class="headerlink" title="1.3 常见的语义化标签"></a>1.3 常见的语义化标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span>  头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>  导航栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  区块（有语义化的div）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span>  主要区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span>  主要内容</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span>  侧边栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure>

<h3 id="1-4-写语义化代码应该注意什么"><a href="#1-4-写语义化代码应该注意什么" class="headerlink" title="1.4 写语义化代码应该注意什么"></a>1.4 写语义化代码应该注意什么</h3><ul>
<li>  尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li>
<li>  不要使用纯样式标签，如：b、font、u等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li>
<li>  使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li>
<li>  表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来</li>
</ul>
<h2 id="2-SEO"><a href="#2-SEO" class="headerlink" title="2. SEO"></a>2. SEO</h2><h3 id="2-1-TKD-设置"><a href="#2-1-TKD-设置" class="headerlink" title="2.1 TKD 设置"></a>2.1 TKD 设置</h3><ul>
<li><p>  页面 TKD 要包含品牌词及业务词，提升页面排名</p>
</li>
<li><p>例如：掘金的 TKD</p>
<ul>
<li>  Title：掘金 - 代码不止，掘金不停</li>
<li>  Keywords：掘金,稀土,Vue.js,前端面试题,nginx配置,Kotlin,RxJava,React Native,敏捷开发,Python</li>
<li>  Description：掘金是一个帮助开发者成长的社区,是给开发者用的 <code>Hacker News</code>,给设计师用的 <code>Designer News</code>,和给产品经理用的 <code>Medium</code>。掘金的技术文章由稀土上聚集的技术大牛和极客共同编辑为你筛选出最优质的干货,其中包括：<code>Android、iOS</code>、前端、后端等方面的内容。用户每天都可以在这里找到技术世界的头条内容。与此同时,掘金内还有沸点、掘金翻译计划、线下活动、专栏文章等内容。即使你是 <code>GitHub、StackOverflow、</code>开源中国的用户,我们相信你也可以在这里有所收获。</li>
</ul>
</li>
</ul>
<h3 id="2-2-页面内容优化"><a href="#2-2-页面内容优化" class="headerlink" title="2.2 页面内容优化"></a>2.2 页面内容优化</h3><ol>
<li> 网页代码语义化调整：多使用语义化标签，便于爬虫搜索。</li>
<li> 页面内容关键词强化：在页面大小标题和文案中重复关键词，以达到内容强化目的；关键词汇避免使用图片，便于爬虫检索，收录。</li>
<li> img 添加 alt 属性，用 h1 标签写内容关键字。</li>
</ol>
<p>引导链接</p>
<ul>
<li>  网站底部推荐部分保留产品介绍、常见问题汇总等降低跳出率的引导，提高页面留存与转化；或者与所推荐页面形成互链形式，以稳定页面流量权重。</li>
</ul>
<h3 id="2-3-移动端优化"><a href="#2-3-移动端优化" class="headerlink" title="2.3 移动端优化"></a>2.3 移动端优化</h3><ul>
<li>  设置移动页面，或者将 pc 页面设置为自适应，增加移动端搜索的体验和留存转化</li>
<li>移动页面设计需注意以下原则：<ol>
<li> 页面字体、字符大小、文本行间距等设计，应适合手机用户阅读，不可明显过大过小，正文文本字号不小于 10pt（pt：绝对单位，等于1/72英寸）。</li>
<li> 首屏主体内容必须占屏幕的 50% 以上。</li>
<li> 主体内容应与其它板块有明显区分，且位于屏幕的中心位置，使用户获取信息是不受任何干扰。</li>
<li> 导航的功能与位置明确，避免用户使用过程中被误导</li>
<li> 除以上提到的内容外，网站还应避免其他影响页面内容辨识的情况，例如页面出现大面积空白、文本无任何排版、段落/图片排版错乱不整齐、主体内容展示不全等。</li>
</ol>
</li>
</ul>
<h3 id="2-4-站外优化"><a href="#2-4-站外优化" class="headerlink" title="2.4 站外优化"></a>2.4 站外优化</h3><ol>
<li> 在搜索引擎排名较高的公众平台发布正面网站信息，以建设良好口碑；负面信息排名较高的需删除或者屏蔽处理。</li>
<li> 百度，互动，搜狗等百科的创建更新与维护，(互动百科在今日头条有着较高的排名，现在今日头条也在发展搜素引擎)，百科对树立品牌形象较为重要。</li>
<li> 公关舆情传播，宣传新闻源发布。</li>
<li> 站外推广与外链建设。</li>
<li> 根据竞争对手及品牌业务分析，拓展高质量、高权重的外链渠道、科技论坛、自媒体平台、分类信息网等，发布高质量锚文本外链，另进行友情链接交换，以提高关键词排名及自然流量。</li>
</ol>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>十大经典排序算法</title>
    <url>/2021/11/25/sort-algorithm/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><p>十大常见排序算法可以分为两大类：</p>
<ul>
<li>  比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$O(nlogn)$，因此也称为非线性时间比较类排序</li>
<li>  非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序</li>
</ul>
<span id="more"></span>

<p><img src="/2021/11/25/sort-algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li>  稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li>  不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li>  时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li>  空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>
<li>  In-place：占用常数内存，不占用额外内存。</li>
<li>  Out-place：占用额外内存。</li>
<li>  内排序：所有排序操作都在内存中完成，常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</li>
<li>  外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li>
</ul>
<h2 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h2><h3 id="1-1-思想"><a href="#1-1-思想" class="headerlink" title="1.1 思想"></a>1.1 思想</h3><ul>
<li>  比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>  对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>  针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>  持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
<li>  因此最多重复 n - 1 次，就完成了 n 个数据的排序工作。</li>
</ul>
<h3 id="1-2-动画演示"><a href="#1-2-动画演示" class="headerlink" title="1.2 动画演示"></a>1.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/bubbleSort.gif"></p>
<h3 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;  <span class="comment">// 扫描 n - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123; </span><br><span class="line">      <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;  <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">        <span class="keyword">const</span> temp = arr[j + <span class="number">1</span>]  <span class="comment">// 元素交换</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong>：上述代码不论什么情况下都会对数组扫描 n  - 1次，但是当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。下面是优化后的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSortPlus = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> hasChange = <span class="literal">false</span>  <span class="comment">// 增加一个标记位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">        hasChange = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!hasChange) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-性能分析"><a href="#1-4-性能分析" class="headerlink" title="1.4 性能分析"></a>1.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(N^2)$<br></li>
<li>  最佳时间复杂度：$O(N)$<br></li>
<li>  最差时间复杂度：$O(N^2)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2. 选择排序（Selection Sort）"></a>2. 选择排序（Selection Sort）</h2><h3 id="2-1-思想"><a href="#2-1-思想" class="headerlink" title="2.1 思想"></a>2.1 思想</h3><ul>
<li>  首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>  再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>  重复第二步，直到所有元素均排序完毕。</li>
</ul>
<h3 id="2-2-动画演示"><a href="#2-2-动画演示" class="headerlink" title="2.2 动画演示"></a>2.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/selectionSort.gif"></p>
<h3 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">let</span> minIndex, temp</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    minIndex = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">        minIndex = j  <span class="comment">// 将最小的索引保存</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minIndex !== i) &#123;</span><br><span class="line">      temp = arr[i]</span><br><span class="line">      arr[i] = arr[minIndex]</span><br><span class="line">      arr[minIndex] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-性能分析"><a href="#2-4-性能分析" class="headerlink" title="2.4 性能分析"></a>2.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(N^2)$<br></li>
<li>  最佳时间复杂度：$O(N^2)$<br></li>
<li>  最差时间复杂度：$O(N^2)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：不稳定</li>
</ul>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. 插入排序（Insertion Sort）</h2><h3 id="3-1-思想"><a href="#3-1-思想" class="headerlink" title="3.1 思想"></a>3.1 思想</h3><ul>
<li>  将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>  从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ul>
<h3 id="3-2-动画演示"><a href="#3-2-动画演示" class="headerlink" title="3.2 动画演示"></a>3.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/insertionSort.gif"></p>
<h3 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a>3.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i], j</span><br><span class="line">    <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;  <span class="comment">// 将当前元素和有序序列元素一一比较，寻找何时的插入位置</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; temp) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-性能分析"><a href="#3-4-性能分析" class="headerlink" title="3.4 性能分析"></a>3.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(N^2)$<br></li>
<li>  最佳时间复杂度：$O(N)$<br></li>
<li>  最差时间复杂度：$O(N^2)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h2><h3 id="4-1-思想"><a href="#4-1-思想" class="headerlink" title="4.1 思想"></a>4.1 思想</h3><ul>
<li>  先将整个待排序的记录序列分割成为若干子序列。</li>
<li>  分别进行直接插入排序。</li>
<li>  待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。</li>
</ul>
<h3 id="4-2-动画演示"><a href="#4-2-动画演示" class="headerlink" title="4.2 动画演示"></a>4.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/shellSort.gif"></p>
<h3 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shellSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">let</span> gap = <span class="number">1</span>, temp</span><br><span class="line">  <span class="keyword">while</span> (gap &lt; length / <span class="number">3</span>) &#123;  <span class="comment">// 动态定义间隔序列</span></span><br><span class="line">    gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">      temp = arr[i]</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">        arr[j + gap] = arr[j]</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + gap] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-性能分析"><a href="#4-4-性能分析" class="headerlink" title="4.4 性能分析"></a>4.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(nlogn)$<br></li>
<li>  最佳时间复杂度：$O(nlog^2n)$<br></li>
<li>  最差时间复杂度：$O(nlog^2n)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：不稳定</li>
</ul>
<h2 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5. 归并排序（Merge Sort）"></a>5. 归并排序（Merge Sort）</h2><h3 id="5-1-思想"><a href="#5-1-思想" class="headerlink" title="5.1 思想"></a>5.1 思想</h3><ul>
<li>  把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>  对这两个子序列分别采用归并排序；</li>
<li>  将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<h3 id="5-2-动画演示"><a href="#5-2-动画演示" class="headerlink" title="5.2 动画演示"></a>5.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/mergeSort.gif"></p>
<h3 id="5-3-实现"><a href="#5-3-实现" class="headerlink" title="5.3 实现"></a>5.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> left = arr.slice(<span class="number">0</span>, mid)</span><br><span class="line">  <span class="keyword">let</span> right = arr.slice(mid)</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="comment">// 注意: 判断的条件是小于或等于，如果只是小于，那么排序将不稳定.</span></span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">    result.push(left.shift())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">    result.push(right.shift())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-性能分析"><a href="#5-4-性能分析" class="headerlink" title="5.4 性能分析"></a>5.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(nlogn)$<br></li>
<li>  最佳时间复杂度：$O(nlogn)$<br></li>
<li>  最差时间复杂度：$O(nlogn)$<br></li>
<li>  空间复杂度：$O(n)$<br></li>
<li>  排序方式：Out-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6. 快速排序（Quick Sort）"></a>6. 快速排序（Quick Sort）</h2><h3 id="6-1-思想"><a href="#6-1-思想" class="headerlink" title="6.1 思想"></a>6.1 思想</h3><ul>
<li>  先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。</li>
<li>  左右分别用一个空数组去存储比较后的数据。</li>
<li>  最后递归执行上述操作，直到数组长度 &lt;= 1;</li>
</ul>
<h3 id="6-2-动画演示"><a href="#6-2-动画演示" class="headerlink" title="6.2 动画演示"></a>6.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/quickSort.gif"></p>
<h3 id="6-3-实现"><a href="#6-3-实现" class="headerlink" title="6.3 实现"></a>6.3 实现</h3><ul>
<li><p>方法一：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort1 = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//取基准点</span></span><br><span class="line">  <span class="keyword">const</span> midIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>)</span><br><span class="line">  <span class="comment">//取基准点的值，splice(index,1) 则返回的是含有被删除的元素的数组。</span></span><br><span class="line">  <span class="keyword">const</span> valArr = arr.splice(midIndex, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> midIndexVal = valArr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> left = [], right = []</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; midIndexVal) &#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//递归执行以上操作，对左右两个数组进行操作，直到数组长度为 &lt;= 1</span></span><br><span class="line">  <span class="keyword">return</span> quickSort1(left).concat(midIndexVal, quickSort1(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort2 = <span class="function"><span class="keyword">function</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = arr.length, partitionIndex</span><br><span class="line">  left = <span class="keyword">typeof</span> left !== <span class="string">&#x27;number&#x27;</span> ? <span class="number">0</span> : left</span><br><span class="line">  right = <span class="keyword">typeof</span>  right !== <span class="string">&#x27;number&#x27;</span> ? length - <span class="number">1</span> : right</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    partitionIndex = partition(arr, left, right)</span><br><span class="line">    quickSort2(arr, left, partitionIndex - <span class="number">1</span>)</span><br><span class="line">    quickSort2(arr, partitionIndex + <span class="number">1</span>, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partition = <span class="function">(<span class="params">arr, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//分区操作</span></span><br><span class="line">  <span class="keyword">let</span> pivot = left  <span class="comment">// //设定基准值（pivot）</span></span><br><span class="line">  <span class="keyword">let</span> index = pivot + <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">      swap(arr, i, index)</span><br><span class="line">      index++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, pivot, index - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> index - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">  arr[i] = arr[j]</span><br><span class="line">  arr[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-4-性能分析"><a href="#6-4-性能分析" class="headerlink" title="6.4 性能分析"></a>6.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(nlogn)$<br></li>
<li>  最佳时间复杂度：$O(nlogn)$<br></li>
<li>  最差时间复杂度：$O(n^2)$<br></li>
<li>  空间复杂度：$O(logn)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：不稳定</li>
</ul>
<h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7. 堆排序（Heap Sort）"></a>7. 堆排序（Heap Sort）</h2><h3 id="7-1-思想"><a href="#7-1-思想" class="headerlink" title="7.1 思想"></a>7.1 思想</h3><p>堆其实是一种特殊的树。只要满足这两点，它就是一个堆。</p>
<ul>
<li>  堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li>
<li>  堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</li>
</ul>
<p>对于每个节点的值都<code>大于等于</code>子树中每个节点值的堆，我们叫作<code>大顶堆</code>。 对于每个节点的值都<code>小于等于</code>子树中每个节点值的堆，我们叫作<code>小顶堆</code>。</p>
<ul>
<li>  将初始待排序关键字序列 (R1, R2 …. Rn) 构建成大顶堆，此堆为初始的无序区；</li>
<li>  将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1, R2, ….. Rn-1) 和新的有序区 (Rn) ，且满足 R[1, 2 … n-1] &lt;= R[n]。</li>
<li>  由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1, R2 …… Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1, R2 …. Rn-2) 和新的有序区 (Rn-1, Rn)。不断重复此过程，直到有序区的元素个数为 n - 1，则整个排序过程完成。</li>
</ul>
<h3 id="7-2-动画演示"><a href="#7-2-动画演示" class="headerlink" title="7.2 动画演示"></a>7.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/heapSort.gif"></p>
<h3 id="7-3-实现"><a href="#7-3-实现" class="headerlink" title="7.3 实现"></a>7.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> len</span><br><span class="line"><span class="keyword">const</span> heapSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  buildMaxHeap(arr)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i)</span><br><span class="line">    len--</span><br><span class="line">    heapify(arr, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildMaxHeap = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  len = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">    heapify(arr, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function"><span class="keyword">function</span>(<span class="params">arr, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">2</span> * i + <span class="number">1</span>, right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">  <span class="keyword">let</span> largest = i</span><br><span class="line">  <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = right</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">    swap(arr, largest, i)</span><br><span class="line">    heapify(arr, largest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">  arr[i] = arr[j]</span><br><span class="line">  arr[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-性能分析"><a href="#7-4-性能分析" class="headerlink" title="7.4 性能分析"></a>7.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(nlogn)$<br></li>
<li>  最佳时间复杂度：$O(nlogn)$<br></li>
<li>  最差时间复杂度：$O(nlogn)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：不稳定</li>
</ul>
<h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8. 计数排序（Counting Sort）"></a>8. 计数排序（Counting Sort）</h2><h3 id="8-1-思想"><a href="#8-1-思想" class="headerlink" title="8.1 思想"></a>8.1 思想</h3><ul>
<li>  找出待排序的数组中最大和最小的元素</li>
<li>  统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>
<li>  对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>  反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ul>
<h3 id="8-2-动画演示"><a href="#8-2-动画演示" class="headerlink" title="8.2 动画演示"></a>8.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/countingSort.gif"></p>
<h3 id="8-3-实现"><a href="#8-3-实现" class="headerlink" title="8.3 实现"></a>8.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countingSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">      max = arr[i]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min &gt; arr[i]) &#123;</span><br><span class="line">      min = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> countArr = <span class="keyword">new</span> <span class="built_in">Array</span>(max - min + <span class="number">1</span>).fill(<span class="number">0</span>)  <span class="comment">// 找出最大值，最小值，根据两者的差来确定计数数组的长度。而不是直接根据最大值开辟数组，节省空间</span></span><br><span class="line">  <span class="keyword">if</span> (countArr.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    countArr[arr[i] - min]++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; max - min + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    countArr[i] += countArr[i - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(length)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[countArr[arr[i] - min] - <span class="number">1</span>] = arr[i]</span><br><span class="line">    countArr[arr[i] - min]--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-性能分析"><a href="#8-4-性能分析" class="headerlink" title="8.4 性能分析"></a>8.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(n+k)$<br></li>
<li>  最佳时间复杂度：$O(n+k)$<br></li>
<li>  最差时间复杂度：$O(n+k)$<br></li>
<li>  空间复杂度：$O(k)$<br></li>
<li>  排序方式：Out-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9. 桶排序（Bucket Sort）"></a>9. 桶排序（Bucket Sort）</h2><h3 id="9-1-思想"><a href="#9-1-思想" class="headerlink" title="9.1 思想"></a>9.1 思想</h3><ul>
<li>  设置一个定量的数组当作空桶；</li>
<li>  遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>  对每个不是空的桶进行排序；</li>
<li>  从不是空的桶里把排好序的数据拼接起来。</li>
</ul>
<h3 id="9-2-动画演示"><a href="#9-2-动画演示" class="headerlink" title="9.2 动画演示"></a>9.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/bucketSort.gif"></p>
<h3 id="9-3-实现"><a href="#9-3-实现" class="headerlink" title="9.3 实现"></a>9.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bucketSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr, bucketSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> length = arr.length</span><br><span class="line">  <span class="keyword">let</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    max = max &lt; arr[i] ? arr[i] : max</span><br><span class="line">    min = min &gt; arr[i] ? arr[i] : min</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bucketSize = bucketSize || <span class="number">5</span> <span class="comment">// 默认一个桶容纳的范围是5</span></span><br><span class="line">  <span class="keyword">let</span> bucketCount = <span class="built_in">Math</span>.floor((max - min)/bucketSize) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(bucketCount)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">    buckets[i] = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    buckets[<span class="built_in">Math</span>.floor((arr[i]-min)/bucketSize)].push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  arr.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">    insertionSort(buckets[i])</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">      arr.push(buckets[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-性能分析"><a href="#9-4-性能分析" class="headerlink" title="9.4 性能分析"></a>9.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(n+k)$<br></li>
<li>  最佳时间复杂度：$O(n+k)$<br></li>
<li>  最差时间复杂度：$O(n^2)$<br></li>
<li>  空间复杂度：$O(n+k)$<br></li>
<li>  排序方式：Out-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10. 基数排序（Radix Sort）"></a>10. 基数排序（Radix Sort）</h2><h3 id="10-1-思想"><a href="#10-1-思想" class="headerlink" title="10.1 思想"></a>10.1 思想</h3><ul>
<li>  取得数组中的最大数，并取得位数；</li>
<li>  arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>  对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<h3 id="10-2-动画演示"><a href="#10-2-动画演示" class="headerlink" title="10.2 动画演示"></a>10.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/radixSort.gif"></p>
<h3 id="10-3-实现"><a href="#10-3-实现" class="headerlink" title="10.3 实现"></a>10.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> radixSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> max = arr[<span class="number">0</span>], length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    max = <span class="built_in">Math</span>.max(max, arr[i], -arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> maxDigit = max.toString().length</span><br><span class="line">  <span class="keyword">let</span> mod = <span class="number">10</span>, dev = <span class="number">1</span>, counter = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>)</span><br><span class="line">  <span class="comment">//  考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    counter[i] = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev) + <span class="number">10</span></span><br><span class="line">      counter[bucket].push(arr[j])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> len = counter[j].length</span><br><span class="line">      <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        arr[pos++] = counter[j].shift()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4-性能分析"><a href="#10-4-性能分析" class="headerlink" title="10.4 性能分析"></a>10.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(n*k)$<br></li>
<li>  最佳时间复杂度：$O(n*k)$<br></li>
<li>  最差时间复杂度：$O(n*k)$<br></li>
<li>  空间复杂度：$O(n+k)$<br></li>
<li>  排序方式：Out-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="11-复杂度对比"><a href="#11-复杂度对比" class="headerlink" title="11. 复杂度对比"></a>11. 复杂度对比</h2><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
<th align="center">排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlog^2n)$</td>
<td align="center">$O(nlog^2n)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(n)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(logn)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="12-练习地址"><a href="#12-练习地址" class="headerlink" title="12. 练习地址"></a>12. 练习地址</h2><p>可以在力扣912测试代码：<a href="https://leetcode-cn.com/problems/sort-an-array/">https://leetcode-cn.com/problems/sort-an-array/</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML面试题</title>
    <url>/2021/11/24/html/</url>
    <content><![CDATA[<p>绝大部分内容来自：<a href="https://juejin.cn/user/3544481220801815">https://juejin.cn/user/3544481220801815</a></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2021/11/24/html/01.HTML%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="01.HTML面试题"></p>
<h2 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h2><p>src 和 href 都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p>
<ul>
<li>  <strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。常在 img、script、iframe 等元素上使用。</li>
<li>  <strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。这也是为什么建议使用 link 方式加载 css，而不是使用 @import 方式。</li>
</ul>
<h2 id="2-对HTML语义化的理解，SEO优化"><a href="#2-对HTML语义化的理解，SEO优化" class="headerlink" title="2. 对HTML语义化的理解，SEO优化"></a>2. 对HTML语义化的理解，SEO优化</h2><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗的来讲就是正确的标签做正确的事情。</p>
<p>语义化的优点如下：</p>
<ul>
<li>  对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li>
<li>  对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li>
</ul>
<p>常见的语义化标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span>  头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>  导航栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  区块（有语义化的div）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span>  主要区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span>  主要内容</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span>  侧边栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure>

<p>写语义化代码应该注意什么：</p>
<ul>
<li>  尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li>
<li>  不要使用纯样式标签，如：b、font、u等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li>
<li>  使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li>
<li>  表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来</li>
</ul>
<p>SEO：</p>
<ol>
<li><p>TKD 设置</p>
<ul>
<li><p>  页面 TKD 要包含品牌词及业务词，提升页面排名</p>
</li>
<li><p>例如：掘金的 TKD</p>
<ul>
<li>  Title：掘金 - 代码不止，掘金不停</li>
<li>  Keywords：掘金,稀土,Vue.js,前端面试题,nginx配置,Kotlin,RxJava,React Native,敏捷开发,Python</li>
<li>  Description：掘金是一个帮助开发者成长的社区,是给开发者用的 <code>Hacker News</code>,给设计师用的 <code>Designer News</code>,和给产品经理用的 <code>Medium</code>。掘金的技术文章由稀土上聚集的技术大牛和极客共同编辑为你筛选出最优质的干货,其中包括：<code>Android、iOS</code>、前端、后端等方面的内容。用户每天都可以在这里找到技术世界的头条内容。与此同时,掘金内还有沸点、掘金翻译计划、线下活动、专栏文章等内容。即使你是 <code>GitHub、StackOverflow、</code>开源中国的用户,我们相信你也可以在这里有所收获。</li>
</ul>
</li>
</ul>
</li>
<li><p>页面内容优化</p>
<ol>
<li> 网页代码语义化调整：多使用语义化标签，便于爬虫搜索。</li>
<li> 页面内容关键词强化：在页面大小标题和文案中重复关键词，以达到内容强化目的；关键词汇避免使用图片，便于爬虫检索，收录。</li>
<li> img 添加 alt 属性，用 h1 标签写内容关键字。</li>
</ol>
</li>
<li><p>引导链接</p>
<ul>
<li>  网站底部推荐部分保留产品介绍、常见问题汇总等降低跳出率的引导，提高页面留存与转化；或者与所推荐页面形成互链形式，以稳定页面流量权重。</li>
</ul>
</li>
<li><p>移动端优化</p>
<ul>
<li>  设置移动页面，或者将 pc 页面设置为自适应，增加移动端搜索的体验和留存转化</li>
<li>移动页面设计需注意以下原则：<ol>
<li> 页面字体、字符大小、文本行间距等设计，应适合手机用户阅读，不可明显过大过小，正文文本字号不小于 10pt（pt：绝对单位，等于1/72英寸）。</li>
<li> 首屏主体内容必须占屏幕的 50% 以上。</li>
<li> 主体内容应与其它板块有明显区分，且位于屏幕的中心位置，使用户获取信息是不受任何干扰。</li>
<li> 导航的功能与位置明确，避免用户使用过程中被误导</li>
<li> 除以上提到的内容外，网站还应避免其他影响页面内容辨识的情况，例如页面出现大面积空白、文本无任何排版、段落/图片排版错乱不整齐、主体内容展示不全等。</li>
</ol>
</li>
</ul>
</li>
<li><p>站外优化</p>
<ol>
<li> 在搜索引擎排名较高的公众平台发布正面网站信息，以建设良好口碑；负面信息排名较高的需删除或者屏蔽处理。</li>
<li> 百度，互动，搜狗等百科的创建更新与维护，(互动百科在今日头条有着较高的排名，现在今日头条也在发展搜素引擎)，百科对树立品牌形象较为重要。</li>
<li> 公关舆情传播，宣传新闻源发布。</li>
<li> 站外推广与外链建设。</li>
<li> 根据竞争对手及品牌业务分析，拓展高质量、高权重的外链渠道、科技论坛、自媒体平台、分类信息网等，发布高质量锚文本外链，另进行友情链接交换，以提高关键词排名及自然流量。</li>
</ol>
</li>
</ol>
<h2 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h2><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p>
<p>浏览器渲染页面的两种模式（可通过<strong>document.compatMode</strong>获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p>
<ul>
<li>  <strong>CSS1Compat：标准模式（Standards mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li>
<li>  **BackCompat：怪异模式(混杂模式)(Quicks mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li>
</ul>
<blockquote>
<p>  MDN：在 HTML5 中，DOCTYPE 唯一的作用是启用标准模式。更早期的 HTML 标准中，DOCTYPE 会附加其他意义，但没有任何浏览器会将 DOCTYPE 用于怪异模式和标准模式之间互换以外的用途。</p>
<p>  《JavaScript高级程序设计》：</p>
<p>  ​    IE5.5 发明了文档模式的概念，即可以使用 doctype 切换文档模式。最初的文档模式有两种：混杂模式和标准模式。前者让 IE 像 IE5 一样（支持一些非标准的特性），后者让 IE 具有兼容标准的行为。</p>
<p>  ​    IE 初次支持文档模式切换以后，其它浏览器用也跟着实现了。随着浏览器的普遍出现，又出现了第三种文档模式：准标准模式。这种模式下的浏览器支持很多标准的特性，但是没有标准规定的那么严格。主要区别在于如何对待图片元素周围的空白（在表格中使用图片最为明显）。</p>
</blockquote>
<h2 id="4-script标签中defer和async的区别，还有哪些属性？"><a href="#4-script标签中defer和async的区别，还有哪些属性？" class="headerlink" title="4. script标签中defer和async的区别，还有哪些属性？"></a>4. script标签中defer和async的区别，还有哪些属性？</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>
<p>下图可以直观的看出三者之间的区别:</p>
<p><img src="/2021/11/24/html/01-4.png" alt="01-4"></p>
<ul>
<li>defer 属性：推迟执行脚本。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。<ul>
<li>  在 &lt;script&gt; 标签上设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。</li>
<li>  HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，并且会在 DOMContentLoaded 事件之前执行。不过在实际当中，不一定总会按照顺序或者在 DOMContentLoaded 事件之前执行。</li>
</ul>
</li>
<li>async 属性（<strong>HTML5</strong>）：异步执行脚本。表示应该立即请求脚本，并尽快解析和执行，但不能阻止其它页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。<ul>
<li>  告诉浏览器立即下载，但不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行完后在加载其它脚本。（因此，异步脚本不应该在加载期间修改 DOM）</li>
<li>  标记为 async 的脚本并不保证能按照它们出现的次序执行。异步脚本保证会在页面的的 <strong>load</strong> 事件前执行，但可能会在 <strong>DOMContentLoaded</strong> 之前或之后。</li>
</ul>
</li>
</ul>
<p>除上述外，&lt;script&gt; 标签还有以下属性：</p>
<ul>
<li>  charset：使用 src 属性指定的代码字符集。很少使用，因为大多数浏览器不在乎它的值。</li>
<li>  crossorigin：那些没有通过标准CORS (跨域资源共享)检查的正常script 元素传递最少的信息到 window.onerror。可以使用本属性来使那些将静态资源放在另外一个域名的站点打印错误信息。默认不使用 CORS，“” 相当于 “anonymous” ，对此元素的 CORS 请求不设置凭据标志；“use-credentials”，对此元素的 CORS 请求将设置凭证标志，这意味着请求将提供凭据。</li>
<li>  integrity：允许对比接收到的资源和指定的加密签名以验证子资源完整性（SRI）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN）不会提供恶意内容。</li>
<li>  nomodule：这个布尔属性被设置来标明这个脚本在支持 ES2015 modules 的浏览器中不执行。实际上，这可用于在不支持模块化 JavaScript 的旧浏览器中提供回退脚本。</li>
<li>  language：废弃。最初用于表示代码块中的脚本语言。大多数浏览器都会忽略这个属性，不应该再使用它。</li>
<li>  src：定义引用外部脚本的URI，这可以用来代替直接在文档中嵌入脚本。指定了 src 属性的script元素标签内不应该再有嵌入的脚本。</li>
<li>  type：代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型：<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></strong>）。支持的MIME类型包括text/javascript, text/ecmascript, application/javascript（非IE支持）, 和application/ecmascript（非IE支持）。如果没有定义这个属性，脚本会被视作JavaScript。如果MIME类型不是JavaScript类型（上述支持的类型），则该元素所包含的内容会被当作数据块而不会被浏览器执行。JS 文件中的MIME 类型通常是 “application/x-javascript” 。如果type属性为module，代码会被当作JavaScript模块 。</li>
<li>  text：和 textContent 属性类似，本属性用于设置元素的文本内容。但和 textContent 不一样的是，本属性在节点插入到DOM之后，此属性被解析为可执行代码。</li>
</ul>
<h2 id="5-meta，常⽤的meta（元数据）标签有哪些"><a href="#5-meta，常⽤的meta（元数据）标签有哪些" class="headerlink" title="5. meta，常⽤的meta（元数据）标签有哪些"></a>5. meta，常⽤的meta（元数据）标签有哪些</h2><blockquote>
<p>  每个 meta 只能用于一种用途。如果在这些特性中想要使用的不值一个，那就应该在 head 元素中添加多个 meta 元素。</p>
</blockquote>
<p><code>meta</code> <strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。放在 head 元素中。</p>
<p><code>meta</code> 元素定义的元数据的类型包括以下几种：</p>
<ul>
<li>  如果设置了 <code>name</code> 属性，<code>meta</code> 元素提供的是文档级别（<em>document-level</em>）的元数据，应用于整个页面。</li>
<li>  如果设置了 <code>http-equiv</code> 属性，<code>meta</code> 元素则是编译指令，提供的信息与类似命名的HTTP头部相同。</li>
<li>  如果设置了 <code>charset </code> 属性（<strong>HTML5</strong>），<code>meta</code> 元素是一个字符集声明，告诉文档使用哪种字符编码。</li>
<li>  如果设置了 <code>itemprop</code> 属性，<code>meta</code> 元素提供用户定义的元数据。</li>
</ul>
<p><code>meta</code> 包含的属性：</p>
<blockquote>
<p>  注意: 全局属性 <code>name</code> 在 &lt;meta&gt; 元素中具有特殊的语义；另外， 在同一个 &lt;meta&gt; 标签中，<code>name</code>, <code>http-equiv</code> 或者 <code>charset</code> 三者中任何一个属性存在时，<code>itemprop</code> 属性不能被使用。</p>
</blockquote>
<ul>
<li><p>  <code>charset</code>：这个属性声明了文档的字符编码。如果使用了这个属性，其值必须是与ASCII大小写无关（ASCII case-insensitive）的”<code>utf-8</code>“。</p>
</li>
<li><p>  <code>content</code>：此属性包含 <code>http-equiv</code> 或 <code>name</code> 属性的值，具体取决于所使用的值。</p>
</li>
<li><p><code>http-equiv</code>：属性定义了一个编译指示指令。这个属性叫做 <code>http-equiv(alent)</code> 是因为所有允许的值都是特定HTTP头部的名称，如下：</p>
<ul>
<li><p><code>content-security-policy</code><br>  它允许页面作者定义当前页的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">内容策略</a>。 内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。</p>
</li>
<li><p><code>content-type</code><br>  如果使用这个属性，其值必须是”<code>text/html; charset=utf-8</code>“。注意：该属性只能用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a> 为 <code>text/html</code> 的文档，不能用于MIME类型为XML的文档。</p>
</li>
<li><p><code>default-style</code></p>
<p>  设置默认 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS 样式表</a>组的名称。</p>
</li>
<li><p><code>x-ua-compatible</code><br>  如果指定，则 <code>content</code> 属性必须具有值 “<code>IE=edge</code>“。用户代理必须忽略此指示。</p>
</li>
<li><p><code>refresh</code></p>
<p>  这个属性指定:</p>
<ul>
<li>  如果 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content"><code>content</code></a> 只包含一个正整数，则为重新载入页面的时间间隔(秒)；</li>
<li>  如果 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content"><code>content</code></a> 包含一个正整数，并且后面跟着字符串 ‘<code>;url=</code>‘ 和一个合法的 URL，则是重定向到指定链接的时间间隔(秒)</li>
</ul>
</li>
</ul>
</li>
<li><p><code>name</code></p>
<ul>
<li>  <code>name</code> 和 <code>content</code> 属性可以一起使用，以名-值对的方式给文档提供元数据，其中 name 作为元数据的名称，content 作为元数据的值。</li>
<li>  在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name">标准元数据名称</a>（见下方元数据名称）中查看 HTML 规范等规范中定义的标准元数据名称。</li>
</ul>
</li>
</ul>
<p><code>meta</code> 用途：</p>
<ul>
<li>  指定名/值元数据对</li>
<li>  声明字符编码</li>
<li>  模拟 HTTP 标头字段</li>
</ul>
<p>常用的 <code>meta</code> 标签：</p>
<ol>
<li><p><code>charset</code>，用来描述 HTML 文档的编码类型：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>keywords</code>，页面关键词：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>description</code>，页面描述：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;页面描述内容&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>refresh</code>，页面重定向和刷新：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li>  <code>width viewport</code> ：宽度(数值/device-width)</li>
<li>  <code>height viewport</code> ：高度(数值/device-height)</li>
<li>  <code>initial-scale</code> ：初始缩放比例</li>
<li>  <code>maximum-scale</code> ：最大缩放比例</li>
<li>  <code>minimum-scale</code> ：最小缩放比例</li>
<li>  <code>user-scalable</code> ：是否允许用户缩放(yes/no）</li>
</ul>
</li>
<li><p>搜索引擎索引方式：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p> 其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li>  <code>all</code>：文件将被检索，且页面上的链接可以被查询；</li>
<li>  <code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li>
<li>  <code>index</code>：文件将被检索；</li>
<li>  <code>follow</code>：页面上的链接可以被查询；</li>
<li>  <code>noindex</code>：文件将不被检索；</li>
<li>  <code>nofollow</code>：页面上的链接不可以被查询。</li>
</ul>
</li>
</ol>
<p>元数据名称（参考）：</p>
<ol>
<li><p>HTML 规范定义的标准元数据名称</p>
<ul>
<li><p>  application-name：网页中所运行的应用程序的名称</p>
</li>
<li><p>  author：文档作者的名字</p>
</li>
<li><p>  description：一段简短而精确的、对页面内容的描述。一些浏览器，比如 Firefox 和 Opera，将其用作书签的默认描述。</p>
</li>
<li><p>  generator：用来生成 HTML 的软件名称</p>
</li>
<li><p>  keywords：与页面内容相关的关键词，常以逗号分隔</p>
</li>
<li><p>referrer：控制有当前文档发出的请求的 HTTP Referer 请求头</p>
<ul>
<li><p>  &lt;meta name=”referrer”&gt; 的 content 属性的值</p>
</li>
<li><table>
<thead>
<tr>
<th align="left">content</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">no-referrer</td>
<td align="left">不发送 HTTP <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 请求头。</td>
</tr>
<tr>
<td align="left">origin</td>
<td align="left">只发送当前文档的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a>。</td>
</tr>
<tr>
<td align="left">no-referrer-when-downgrade</td>
<td align="left">如果请求目标与当前页面一样安全或者更加安全（HTTP(S)→HTTPS），则发送完整 URL；<br />如果请求目标更加不安全（HTTPS→HTTP），则不发送 referrer。这是默认行为。</td>
</tr>
<tr>
<td align="left">origin-when-cross-origin</td>
<td align="left">对同源请求发送完整 URL（不含 URL 参数），其他情况下，只发送 origin。</td>
</tr>
<tr>
<td align="left">same-origin</td>
<td align="left">对同源请求发送完整 URL（不含 URL 参数），其他情况下，请求不包含 referrer 请求头。</td>
</tr>
<tr>
<td align="left">strict-origin</td>
<td align="left">如果请求目标与当前页面一样安全或者更加安全（HTTP(S)→HTTPS），则发送 origin；<br />如果请求目标更加不安全（HTTPS→HTTP），则不发送 referrer。</td>
</tr>
<tr>
<td align="left">strict-origin-when-cross-origin</td>
<td align="left">对同源请求发送完整 URL（不含 URL 参数）；<br />其他情况下，如果请求目标与当前页面一样安全或者更加安全（HTTP(S)→HTTPS），则发送 origin；<br />如果请求目标更加不安全（HTTPS→HTTP），则不发送 referrer。</td>
</tr>
<tr>
<td align="left">unsafe-URL</td>
<td align="left">对同源请求和跨源请求发送完整 URL（不含 URL 参数）。</td>
</tr>
</tbody></table>
</li>
<li><blockquote>
<p>  备注：<br>  动态插入 &lt;meta name=”referrer”&gt;（使用 document.write() 方法或者 appendChild() 等方法）会使 referrer 行为变得不可预测。<br>  如果定义了互相冲突的策略，则会转而使用 no-referrer 策略。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>  theme-color：表示当前页面的建议颜色，在自定义当前页面从或页面周围的用户界面的显示时，用户代理应当使用此颜色。content 属性应当包含一个有效的 CSS &lt;color&gt; 值。</p>
</li>
</ul>
</li>
<li><p>CSS 颜色调整规范定义的元数据名称</p>
<ul>
<li><p><code>color-scheme</code>: 指定与当前文档兼容的一种或多种配色方案。</p>
<p>  浏览器将优先采用此元数据的值，然后再使用用户的浏览器或设备设置，来确定页面上的各种默认颜色和元素外观，例如背景色、前景色、窗体控件和滚动条。<code>&lt;meta name=&quot;color-scheme&quot;&gt;</code> 的主要用途是指示当前页面与浅色模式和深色模式的兼容性，以及选用这两种模式时的优先顺序。</p>
<p>  <code>color-scheme</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content"><code>content</code></a> 属性的值应当为以下值中的一个：</p>
<ul>
<li><p><code>normal</code></p>
<p>  该文档未指定（unaware of）配色方案，应当仅使用默认配色进行渲染。</p>
</li>
<li><p>[<code>light</code> | <code>dark</code>]+</p>
<p>  文档所支持的一种或多种配色方案。如果多次指定同一个配色方案，则与仅指定一次效果相同。如果指定了多种配色方案，则表示文档优先选择第一种方案——如果用户更倾向于选择第二种配色方案，则可以接受第二种。</p>
</li>
<li><p><code>only light</code></p>
<p>  表示文档<em>仅</em>支持浅色模式，也就是浅色背景色和深色前景色。按照规范，<code>only dark</code> <em>是无效的</em>。如果在文档不支持深色模式的情况下强迫其以深色模式进行渲染，会导致内容不可读。所以，在未经配置的情况下，所有主要浏览器均默认使用浅色模式。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CSS 设备适配规范定义的元数据名称</p>
<ul>
<li><p><code>viewport</code>: 为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport">viewport</a>（视口）的初始大小提供指示（hint）。目前仅用于移动设备。</p>
<ul>
<li><p>  &lt;meta name=”viewport”&gt; 的 content 属性的值</p>
</li>
<li><table>
<thead>
<tr>
<th>值</th>
<th>可能附加的值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>一个正整数，或者字符串 <code>device-width</code></td>
<td>定义 viewport 的宽度，如果值为正整数，则单位为像素。</td>
</tr>
<tr>
<td>height</td>
<td>一个正整数，或者字符串 <code>device-height</code></td>
<td>定义 viewport 的高度。未被任何浏览器使用。</td>
</tr>
<tr>
<td>initial-scale</td>
<td>一个 <code>0.0</code> 和 <code>10.0</code> 之间的正数</td>
<td>定义设备宽度（宽度和高度中更小的那个：如果是纵向屏幕，就是 <code>device-width</code>，如果是横向屏幕，就是 <code>device-height</code>）与 viewport 大小之间的缩放比例。</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>一个 <code>0.0</code> 和 <code>10.0</code> 之间的正数</td>
<td>定义缩放的最大值，必须大于等于 <code>minimum-scale</code>，否则表现将不可预测。<br />浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>一个 <code>0.0</code> 和 <code>10.0</code> 之间的正数</td>
<td>定义缩放的最小值，必须小于等于 <code>maximum-scale</code>，否则表现将不可预测。<br />浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。</td>
</tr>
<tr>
<td>user-scalable</td>
<td><code>yes</code> 或者 <code>no</code></td>
<td>默认为 <code>yes</code>，如果设置为 <code>no</code>，用户将无法缩放当前页面。<br />浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。</td>
</tr>
<tr>
<td>viewport-fit</td>
<td><code>auto</code>、<code>contain</code> 或者 <code>cover</code></td>
<td>该<code>auto</code>值不影响初始布局视口，整个网页都是可见的。<br />该<code>contain</code>值表示视口被缩放以适应显示中内接的最大矩形。<br />该<code>cover</code>值意味着缩放视口以填充设备显示。强烈建议使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/env()">安全区域插入</a>变量来确保重要内容不会出现在显示之外。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>其它元数据名称</p>
<ul>
<li><p>  <code>creator</code>：当前文档的创建者，例如某个组织或者机构。如果有不止一个创建者，则应当使用多个名称为 <code>creator</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">``</a> 元素。（而不是像关键词一样使用逗号分隔：关键词不应包含逗号，但创建者名称可能含有逗号。）</p>
</li>
<li><p>  <code>googlebot</code>：<code>robots</code> 的替代名称，只被 Googlebot（Google 的网页爬虫/索引搜寻器）使用。</p>
</li>
<li><p>  <code>publisher</code>：当前文档的发布者/出版者。</p>
</li>
<li><p><code>robots</code>：爬虫、协作搜寻器，或者“机器人”，对此页面的处理行为，或者说，应当遵守的规则。是一个使用逗号分隔的、由下列值构成的列表：</p>
<ul>
<li><p>  &lt;meta name=”robots”&gt; 的 content 属性的值</p>
</li>
<li><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>被用于</th>
</tr>
</thead>
<tbody><tr>
<td><code>index</code></td>
<td>允许机器人索引此页面（默认）。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>noindex</code></td>
<td>要求机器人不索引此页面。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>follow</code></td>
<td>允许机器人跟随此页面上的链接（默认）。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>nofollow</code></td>
<td>要求机器人不跟随此页面上的链接。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>all</code></td>
<td>与 <code>index, follow</code> 等价</td>
<td><a href="https://support.google.com/webmasters/answer/79812">谷歌</a></td>
</tr>
<tr>
<td><code>none</code></td>
<td>与 <code>noindex, nofollow</code> 等价</td>
<td><a href="https://support.google.com/webmasters/answer/79812">谷歌</a></td>
</tr>
<tr>
<td><code>noarchive</code></td>
<td>要求搜索引擎不缓存页面内容。</td>
<td><a href="https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives">谷歌</a>、<a href="https://help.yahoo.com/kb/search-for-desktop/SLN2213.html">雅虎</a>、<a href="https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240">Bing</a></td>
</tr>
<tr>
<td><code>nosnippet</code></td>
<td>防止在搜索引擎结果中显示页面的任何描述。</td>
<td><a href="https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives">谷歌</a>、<a href="https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240">Bing</a></td>
</tr>
<tr>
<td><code>noimageindex</code></td>
<td>要求此页面不显示为索引图像的引用页面。</td>
<td><a href="https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives">谷歌</a></td>
</tr>
<tr>
<td><code>nocache</code></td>
<td><code>noarchive</code> 的替代名称。</td>
<td><a href="https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240">Bing</a></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h2><p><strong>1.新的 DOCTYPE 和字符集</strong></p>
<ul>
<li><p>HTML4</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>HTML5</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 语义化标签</strong></p>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">address</td>
<td align="center">表示文档或article的联系信息</td>
</tr>
<tr>
<td align="center">article</td>
<td align="center">表示一段独立的内容</td>
</tr>
<tr>
<td align="center">aside</td>
<td align="center">表示与周边内容稍有牵涉的内容，相关内容或引文</td>
</tr>
<tr>
<td align="center">details</td>
<td align="center">生成一个区域，用户将其展开可以获得更多细节知识</td>
</tr>
<tr>
<td align="center">footer</td>
<td align="center">表示尾部</td>
</tr>
<tr>
<td align="center">header</td>
<td align="center">表示首部</td>
</tr>
<tr>
<td align="center">hgroup</td>
<td align="center">将一组标题组织在一起，以便文档大纲只显示其中第一个标题</td>
</tr>
<tr>
<td align="center">nav</td>
<td align="center">表示有意集中在一起的导航元素</td>
</tr>
<tr>
<td align="center">section</td>
<td align="center">表示一个重要的概念或主题</td>
</tr>
<tr>
<td align="center">summary</td>
<td align="center">用在 details 元素中，表示该元素内容的标题或说明</td>
</tr>
</tbody></table>
<p><strong>3. 媒体标签</strong></p>
<ol>
<li><p>audio：在网页里嵌入音频内容</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">autoplay</td>
<td align="center">如果存在，此属性会使浏览器尽可能立刻开始播放视频</td>
</tr>
<tr>
<td align="center">preload</td>
<td align="center">告诉浏览器是否要预先载入视频<br />none：用户开始播放之前不会载入视频<br />metadata：用户开始播放之前只能载入视频的元数据（音频长度和其它此类信息）<br />auto：请求浏览器尽快下载整个视频。浏览器可以忽略这个请求。这是默认行为</td>
</tr>
<tr>
<td align="center">controls</td>
<td align="center">除非此属性存在，否则浏览器不会显示播放控件</td>
</tr>
<tr>
<td align="center">loop</td>
<td align="center">如果存在，此属性会让浏览器反复播放视频</td>
</tr>
<tr>
<td align="center">muted</td>
<td align="center">如果此属性存在，视频从一开始就会处于静音状态</td>
</tr>
<tr>
<td align="center">src</td>
<td align="center">指定要显示的视频</td>
</tr>
</tbody></table>
</li>
<li><p>video：在网页里嵌入视频内容</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">poster</span>=<span class="string">&#x27;imgs/aa.jpg&#x27;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">autoplay</td>
<td align="center">如果存在，此属性会使浏览器尽可能立刻开始播放视频</td>
</tr>
<tr>
<td align="center">preload</td>
<td align="center">告诉浏览器是否要预先载入视频<br />none：用户开始播放之前不会载入视频<br />metadata：用户开始播放之前只能载入视频的元数据（宽度、高度、第一帧、长度和其它此类信息）<br />auto：请求浏览器尽快下载整个视频。浏览器可以忽略这个请求。这是默认行为</td>
</tr>
<tr>
<td align="center">controls</td>
<td align="center">除非此属性存在，否则浏览器不会显示播放控件</td>
</tr>
<tr>
<td align="center">loop</td>
<td align="center">如果存在，此属性会让浏览器反复播放视频</td>
</tr>
<tr>
<td align="center">poster</td>
<td align="center">指定在视频数据载入时显示的图片</td>
</tr>
<tr>
<td align="center">height</td>
<td align="center">指定视频的高度</td>
</tr>
<tr>
<td align="center">width</td>
<td align="center">指定视频的宽度</td>
</tr>
<tr>
<td align="center">muted</td>
<td align="center">如果此属性存在，视频从一开始就会处于静音状态</td>
</tr>
<tr>
<td align="center">src</td>
<td align="center">指定要显示的视频</td>
</tr>
</tbody></table>
</li>
<li><p>source：因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p>
<p> 浏览器重点支持的视频格式：</p>
<table>
<thead>
<tr>
<th align="center">格式</th>
<th align="center">说明</th>
<th align="center">支持</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WebM</td>
<td align="center">此格式由谷歌提供支持，目标是创建一个无专利约束，免版税的格式</td>
<td align="center">Opera、Chrome、Firefox</td>
</tr>
<tr>
<td align="center">Ogg/Theora</td>
<td align="center">Ogg Theora 是一种开放、免版税和无专利约束的格式</td>
<td align="center">Opera、Chrome、Firefox</td>
</tr>
<tr>
<td align="center">MP4/H.264</td>
<td align="center">暂无</td>
<td align="center">IE、Chrome、Safari</td>
</tr>
</tbody></table>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;images/s1.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;images/s1.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;images/s1.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>track：提供了一套视频相关内容的实现机制。这些内容包括字幕、说明和章节标题。</p>
<p> MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track</a></p>
</li>
</ol>
<p><strong>4. 表单</strong></p>
<p><strong>表单类型：</strong></p>
<ul>
<li>  email ：能够验证当前输入的邮箱地址是否合法</li>
<li>  url ： 验证URL</li>
<li>  tel：验证电话号码</li>
<li>  number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li>
<li>  search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li>
<li>  range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li>
<li>  color ： 提供了一个颜色拾取器</li>
<li>  time ： 时分秒</li>
<li>  data ： 日期选择年月日</li>
<li>  datatime ： 时间和日期(目前只有Safari支持)</li>
<li>  datatime-local ：日期时间控件</li>
<li>  week ：周控件</li>
<li>  month：月控件</li>
</ul>
<p><strong>表单属性：</strong></p>
<ul>
<li>  placeholder ：提示信息</li>
<li>  autofocus ：自动获取焦点</li>
<li>autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：<ul>
<li>  表单必须提交过</li>
<li>  必须有name属性。</li>
</ul>
</li>
<li>  required：要求输入框不能为空，必须有值才能够提交。</li>
<li>  pattern=” “ 里面写入想要的正则模式，例如手机号patte=”^(+86)?\d{10}$”</li>
<li>  multiple：可以选择多个文件或者多个邮箱</li>
<li>  form=” form表单的ID”</li>
<li>  novalidate 不经输入验证就能提交表单</li>
</ul>
<p><strong>表单事件：</strong></p>
<ul>
<li>  oninput 每当input里的输入框内容发生变化都会触发此事件。</li>
<li>  oninvalid 当验证不通过时触发此事件。</li>
</ul>
<p><strong>附：</strong></p>
<p><img src="/2021/11/24/html/01-6.png" alt="01-6"></p>
<p><strong>5. 进度条、度量器</strong></p>
<ul>
<li>  progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</li>
<li>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）<ul>
<li>  high/low：规定被视作高/低的范围</li>
<li>  max/min：规定最大/小值</li>
<li>  value：规定当前度量值</li>
</ul>
</li>
</ul>
<p>设置规则：min &lt; low &lt; high &lt; max</p>
<p><strong>6.DOM查询操作</strong></p>
<ul>
<li>  document.querySelector()</li>
<li>  document.querySelectorAll()</li>
</ul>
<p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p>
<p><strong>7. Web存储</strong></p>
<p>HTML5 提供了两种在客户端存储数据的新方法：</p>
<ul>
<li>  localStorage - 没有时间限制的数据存储</li>
<li>  sessionStorage - 针对一个 session 的数据存储</li>
</ul>
<p><strong>8. 其他</strong></p>
<ul>
<li>  拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li>
<li>  Geolocation API（地理定位）用于定位用户的位置。</li>
<li>  WebSockets</li>
<li>  Web Workers</li>
<li>  Web Storage API</li>
<li>  Communication API</li>
<li>  History API</li>
</ul>
<p><strong>总结(不全，还没改)：</strong> （1）新增语义化标签：nav、header、footer、aside、section、article （2）音频、视频标签：audio、video （3）数据存储：localStorage、sessionStorage （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） （5）input标签新增属性：placeholder、autocomplete、autofocus、required （6）history API：go、forward、back、pushstate</p>
<p><strong>移除的元素有(<a href="https://html.spec.whatwg.org/multipage/obsolete.html)%EF%BC%9A">https://html.spec.whatwg.org/multipage/obsolete.html)：</a></strong></p>
<ul>
<li>  纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li>
<li>  对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<h2 id="7-img的srcset属性的作⽤？"><a href="#7-img的srcset属性的作⽤？" class="headerlink" title="7. img的srcset属性的作⽤？"></a>7. img的srcset属性的作⽤？</h2><p>H5中img有两个新属性，<code>srcset</code>和<code>sizes</code>，主要作用：</p>
<ul>
<li>  控制响应式图片，根据屏幕大小来选择显示不同图片</li>
<li>  根据屏幕的不同（视网膜屏幕还是普通屏），展示不同质量的图片，合理控制下载资源，以及带给用户高质量享受。</li>
</ul>
<p><strong>srcset：</strong></p>
<ol>
<li><p>格式一：图片源地址 空格 图片像素宽度[，图片源地址 空格 图片像素宽度，…]，如</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">srcset=&quot;1.jpg 580w, 2.png 618w&quot;</span><br></pre></td></tr></table></figure>

<p> 表示图片<code>1.jpg</code>的像素宽度为<code>580px</code>，图片<code>2.png</code>的像素宽度为<code>618px</code>，两个图片源之间用逗号隔开。</p>
<p> <strong>千万注意：描述图片的像素宽度是用’w’单位，且一定要是图片的真实像素宽度，如果私自改动，那么会影响浏览器对图片的选择！</strong><del>这里的以 w 后缀的值并不是 “真实” 大小，它只是对浏览器的一个提示，大致等于图片的 “CSS像素” 大小。</del></p>
<p> 其实上述例子类似给了个默认的<code>sizes</code>属性（具体下面再讲）</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">srcset=&quot;1.jpg 580w, 2.png 618w&quot; sizes=&quot;100vw&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>格式二：图片源地址 空格 屏幕像素密度[, 图片源地址 空格 屏幕像素密度, …]，如</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">srcset=&quot;1.jpg 1x, 2.png 2x&quot;</span><br></pre></td></tr></table></figure>

<p> 表示图片<code>1.jpg</code>为DPR（**DPR = 设备像素 / CSS像素(某一方向上)**）为1时下显示的图片；<code>2.png</code>为DPR为2时显示的图片，如果没有更大的DPR设置的图片源，那么当大于当前设置的DPR最高值时，会采用当前设置的最大DPR的图片源。如这里如果屏幕DPR为3，那么还是会用<code>2.png</code>。</p>
</li>
<li><p> 小结：在浏览器支持<code>srcset</code>的情况下，<code>src</code>值就成为了一个<code>1x</code>情况下的候选图片，在没有符合条件的情况下，会采用该值。</p>
</li>
</ol>
<p><strong>sizes：</strong>只有当设置了<code>srcset</code>，且单位为<code>w</code>时，<code>sizes</code>的设置才会起效。浏览器先根据<code>sizes</code>设定的条件下，找出此刻图片显示的宽度，然后根据这个宽度去<code>srcset</code>里找符合条件的图片。</p>
<ul>
<li><p>浏览器的选取规则</p>
<ul>
<li>  srcset中设置的图片像素宽度（’w’的值），组成了相应的半开半闭区间(a, b]。 图片的显示宽度（sizes规定的值）看落在哪个区间内，取区间中最大值对应的图片。若没有最大值（如∞），则取上个区间最大值。</li>
<li>如<code>&lt;img src=&quot;4.jpg&quot; srcset=&quot;3.jpg 229w,2.png 618w,1.jpg 1000w&quot;, sizes=&quot;300px&quot;&gt;</code><ul>
<li>  上面设置图片要显示成<code>300px</code>（<code>sizes</code>里的值），在<code>srcset</code>里的几个临界值中形成了<code>(0, 229px]</code>、<code>(229px, 618px]</code>、<code>(618px, 1000px]</code>、<code>(1000px, ∞]</code>。<code>300px</code>落在了<code>(229px, 618px]</code>中，取最大值<code>618</code>，因此最终选择的图片就是<code>2.png</code></li>
<li>  如果<code>sizes</code>改成<code>1200px</code>，按照上述规则，最终会选取<code>1000w</code>的<code>1.jpg</code></li>
<li>  注意：srcset里的顺序不重要，不会受到影响。</li>
</ul>
</li>
</ul>
</li>
<li><p>sizes 的语法结构</p>
<ul>
<li><p>[媒体查询 空格 ]图片显示宽度[, [媒体查询 空格 ]图片显示宽], …, 其余条件宽度值]</p>
<p>  图片的宽度值单位不能为<code>%</code>，其余正常单位可以使用</p>
</li>
<li><p>举例：<code>sizes=&quot;(max-width: 500px) 400px, (max-width: 900px) 700px, 1200px&quot;</code></p>
<ul>
<li>  上面的意思就是，在屏幕小于等于500px情况下，图片显示成400px宽；在屏幕小于等于900px情况下，图片显示成700px宽；其余情况显示成1200px宽。</li>
<li>  因此，可根据这种<code>sizes</code>值，判断在哪个屏幕大小下显示什么宽度的图片，然后根据这个宽度值去<code>srcset</code>里找满足条件的图片源。</li>
</ul>
</li>
<li><p>所以下面这个例子：<code>&lt;img src=&quot;4.jpg&quot; srcset=&quot;3.jpg 229w,2.png 618w,1.jpg 1000w&quot;, sizes=&quot;(max-width: 500px) 400px, (max-width: 900px) 700px, 1200px&quot;&gt;</code></p>
<ul>
<li>  在屏幕小于等于500px情况下，图片显示成400px宽，选取<code>2.png</code>；在屏幕小于等于900px情况下，图片显示成700px宽，选取<code>1.jpg</code>；其余情况显示成1200px宽，还是选取<code>1.jpg</code>。</li>
<li>  注意：sizes里的媒体查询条件顺序是很重要的，只要满足了越靠前的某个条件，那么后面的条件会被忽略的</li>
</ul>
</li>
</ul>
</li>
<li><p>如果<code>sizes</code>属性没有值，或者在有媒体条件下，其余条件宽度没有设值，那么默认是<code>100vw</code></p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;100vw&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span>, <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 500px) 400px&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span>, <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 500px) 400px, 100vw&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  这种时候，就是直接根据屏幕的宽度来决定选取哪个图片源了。</p>
</li>
</ul>
<p><strong>DPR的影响</strong></p>
<p>上述内容，都是在DPR为1的情况下说明的，主要针对PC端吧。那如果是手机端，DPR不单单是1，还有2，3的情况。这时候其实上述内容的规则还是不会变的，但是我们需要做一些值的转化才能套用上述规则。这里主要是说’w’的情况下浏览器如何去选择</p>
<p>例如：<code>&lt;img src=&quot;4.jpg&quot; srcset=&quot;3.jpg 229w,2.png 618w&quot; sizes=&quot;(max-width: 600px) 114px&quot;&gt;</code></p>
<p>首先我们要知道，srcset里的’w’符号，是代表的是图像的宽度像素，是个物理像素；sizes里的114px是表示逻辑像素！</p>
<p>而浏览器对图片的选择，是要转化为同一概念上的像素才能进行对比的，总不能拿着逻辑像素值去物理像素区间里做比较吧？</p>
<p>因此，在DPR不为1时，要转化一下像素值才能去区间里比较，套用上述规则。</p>
<p>如在DPR=2时，把114px转化为物理像素，即114px * 2 = 228px，用228px去(0, 229px]、(229px, 618px]、(618px, ∞]里做比较，落在了(0, 229px]中，取229px对应的3.jpg</p>
<h2 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><ul>
<li>  行内元素有：<code>a b span img input select strong</code>；</li>
<li>  块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li>
</ul>
<p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p>
<ul>
<li>  常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li>
<li>  鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li>
</ul>
<h2 id="9-说一下-web-worker"><a href="#9-说一下-web-worker" class="headerlink" title="9. 说一下 web worker"></a>9. 说一下 web worker</h2><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。web worker 是运行在后台的 js，独立于其他脚本，通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>
<p>在 Web Workers 中执行的脚本不能访问 Web 页面和 DOM API，虽然不会导致浏览器 UI 停止响应，但是仍然会消耗 CPU 周期，导致系统反应变慢。 </p>
<p>如何创建 web worker：</p>
<ol>
<li> 检测浏览器对于 web worker 的支持性</li>
<li> 创建 web worker 文件（js，回传函数等）</li>
<li> 创建 web worker 对象</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Workers<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Worker<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;support&quot;</span>&gt;</span>not support<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;stopButton&quot;</span>&gt;</span>Stop Task<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;helloButton&quot;</span>&gt;</span>Post a Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">stopWorker</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  worker.terminate()</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">messageHandler</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(e.data)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.warn(e.message, e)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">loadDemo</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (Worker) !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;support&quot;</span>).innerHTML = <span class="string">&quot;support&quot;</span></span></span><br><span class="line"><span class="javascript">    worker = <span class="keyword">new</span> Worker(<span class="string">&quot;echoWorker.js&quot;</span>)</span></span><br><span class="line"><span class="javascript">    worker.addEventListener(<span class="string">&quot;message&quot;</span>, messageHandler, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">    worker.addEventListener(<span class="string">&quot;error&quot;</span>, errorHandler, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;helloButton&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      worker.postMessage(<span class="string">&quot;for you&quot;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;stopButton&quot;</span>).onclick = stopWorker</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, loadDemo, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">messageHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  postMessage(<span class="string">&quot;say: &quot;</span> + e.data)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">&quot;message&quot;</span>, messageHandler, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h2 id="10-HTML5的离线缓存怎么使用，它的工作原理是什么"><a href="#10-HTML5的离线缓存怎么使用，它的工作原理是什么" class="headerlink" title="10. HTML5的离线缓存怎么使用，它的工作原理是什么"></a>10. HTML5的离线缓存怎么使用，它的工作原理是什么</h2><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>
<p><strong>原理：</strong>HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>
<p><strong>使用方法：</strong> （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">manifest</span>=<span class="string">&quot;index.manifest&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js/app.js</span><br><span class="line">    css/style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse/logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    / /offline.html</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>
<li>  <strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li>
<li>  <strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>
</ul>
<p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p>
<p><strong>如何更新缓存：</strong></p>
<p>（1）更新 manifest 文件</p>
<p>（2）通过 javascript 操作</p>
<p>（3）清除浏览器缓存</p>
<p><strong>注意事项：</strong></p>
<p>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p>
<p>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p>
<p>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p>
<p>（4）FALLBACK 中的资源必须和 manifest 文件同源。</p>
<p>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p>
<p>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p>
<p>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>
<h2 id="11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？"><a href="#11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？" class="headerlink" title="11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？"></a>11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h2><ul>
<li>  <strong>在线的情况下</strong>，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li>
<li>  <strong>离线的情况下</strong>，浏览器会直接使用离线存储的资源。</li>
</ul>
<h2 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h2><ul>
<li>title与h1的区别<ul>
<li>定义：<ul>
<li>  title是网站标题，一个页面只能有一个</li>
<li>  h1是文章主题</li>
</ul>
</li>
<li>作用：<ul>
<li>  title概括网站信息，可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的，是显示在网页Tab栏里的；</li>
<li>  h1突出文章主题，面对用户，更突出其视觉效果，指向页面主体信息，是显示在网页中的。</li>
</ul>
</li>
<li>注意：<ul>
<li>  如果title为空，但是页面存在h1,b,strong标签，搜索引擎会默认页面title为h1内的内容，所以得出结论h1是在没有外界干扰下除title以外第二个能强调页面主旨的标记，在一个页面中应该使用且只使用一次h1标记。</li>
</ul>
</li>
</ul>
</li>
<li>b与strong的区别<ul>
<li>定义：<ul>
<li>  b(bold)是实体标签，用来给文字加粗</li>
<li>  strong是逻辑标签，作用是加强字符语气</li>
</ul>
</li>
<li>区别：<ul>
<li>  b标签只是加粗的样式，没有实际含义，常用来表达无强调或着中意味的粗体文字</li>
<li>  strong表示标签内字符重要，用以强调，其默认格式是加粗，但是可以通过css添加样式，使用别的样式强调</li>
<li>  建议：为了符合css3的规范语义化，b应尽量少用而改用strong</li>
</ul>
</li>
</ul>
</li>
<li>i与em的区别<ul>
<li>定义：<ul>
<li>  i(italic)是实体标签，用来使字符倾斜</li>
<li>  em(emphasis)是逻辑标签，作用是强调文本内容</li>
</ul>
</li>
<li>区别：<ul>
<li>  i标签只是斜体的样式，没有实际含义，常用来表达无强调或着重意味的斜体，比如生物学名、术语、外来语；</li>
<li>  em表示标签内字符重要，用以强调，其默认格式是斜体，但是可以通过CSS添加样式。</li>
<li>  建议：为了符合CSS3的规 范，i应尽量少用而改用em</li>
</ul>
</li>
</ul>
</li>
<li>tips:<ul>
<li>  物理元素是告诉浏览器我应该以何种格式显示文字，逻辑元素告诉浏览器这些文字有怎么样的重要性。</li>
<li>  对于搜索引擎来说em和strong比i和b要重视的多。</li>
</ul>
</li>
</ul>
<h2 id="13-iframe-有那些优点和缺点？"><a href="#13-iframe-有那些优点和缺点？" class="headerlink" title="13. iframe 有那些优点和缺点？"></a>13. iframe 有那些优点和缺点？</h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">allow</td>
<td align="left">用于为<code>&lt;iframe&gt;</code>指定其<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Feature_Policy">特征策略</a>.</td>
</tr>
<tr>
<td align="left">allowfullscreen</td>
<td align="left">设置为<code>true</code>时，可以通过调用 <code>&lt;iframe&gt;</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/requestFullScreen"><code>requestFullscreen()</code></a> 方法激活全屏模式。<br />这是一个历史遗留属性，已经被重新定义为 <code>allow=&quot;fullscreen&quot;</code>。</td>
</tr>
<tr>
<td align="left">allowpaymentrequest</td>
<td align="left">设置为<code>true</code>时，跨域的 <code>&lt;iframe&gt;</code> 就可以调用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API">Payment Request API</a>。<br />这是一个历史遗留属性，已经被重新定义为 <code>allow=&quot;payment&quot;</code>.</td>
</tr>
<tr>
<td align="left">csp</td>
<td align="left">对嵌入的资源配置<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">内容安全策略</a>。</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left">以CSS像素格式<a href="https://developer.mozilla.org/zh-CN/docs/HTML/HTML5">HTML5</a>，或像素格式HTML 4.01，或百分比格式指定frame的高度。默认值为<code>150</code>。</td>
</tr>
<tr>
<td align="left">importance</td>
<td align="left">表示 <code>&lt;iframe&gt; </code>的 <code>src</code> 属性指定的资源的加载优先级。允许的值有：<br /><code>auto</code> (default)：不指定优先级。浏览器根据自身情况决定资源的加载顺序<br /><code>high</code>：资源的加载优先级较高<br /><code>low</code>：资源的加载优先级较低</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">用于定位嵌入的浏览上下文的名称。该名称可以用作 &lt;a&gt; 标签与 &lt;form&gt; 标签的 target 属性值，也可以用作 &lt;input&gt; 标签和 &lt;button&gt; 标签的 formtarget 属性值，还可以用作 window.open() 方法的 windowName 参数值。</td>
</tr>
<tr>
<td align="left">referrerpolicy</td>
<td align="left">表示在获取 iframe 资源时如何发送 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/referrer">referrer</a> 首部：<br /><code>no-referrer</code>: 不发送 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 首部。<br /><code>no-referrer-when-downgrade</code> (default): 向不受 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/TLS">TLS</a> (<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/https">HTTPS</a>) 保护的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a> 发送请求时，不发送 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 首部。<br /><code>origin</code>: referrer 首部中仅包含来源页面的源。换言之，仅包含来源页面的 <a href="https://developer.mozilla.org/en-US/docs/Archive/Mozilla/URIScheme">scheme</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">host</a>, 以及 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port (en-US)</a>。<br /><code>origin-when-cross-origin</code>: 发起跨域请求时，仅在 referrer 中包含来源页面的源。发起同源请求时，仍然会在 referrer 中包含来源页面在服务器上的路径信息。<br /><code>same-origin</code>: 对于 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Same-origin_policy">same origin</a> （同源）请求，发送 referrer 首部，否则不发送。<br /><code>strict-origin</code>: 仅当被请求页面和来源页面具有相同的协议安全等级时才发送 referrer 首部（比如从采用 HTTPS 协议的页面请求另一个采用 HTTPS 协议的页面）。如果被请求页面的协议安全等级较低，则不会发送 referrer 首部（比如从采用 HTTPS 协议的页面请求采用 HTTP 协议的页面）。<br /><code>strict-origin-when-cross-origin</code>: 当发起同源请求时，在 referrer 首部中包含完整的 URL。当被请求页面与来源页面不同源但是有相同协议安全等级时（比如 HTTPS→HTTPS），在 referrer 首部中仅包含来源页面的源。当被请求页面的协议安全等级较低时（比如 HTTPS→HTTP），不发送 referrer 首部。<br /><code>unsafe-url</code>: 始终在 referrer 首部中包含源以及路径 （但不包括 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash">fragment</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/password">密码</a>，或<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/username">用户名</a>）。<strong>这个值是不安全的</strong>, 因为这样做会暴露受 TLS 保护的资源的源和路径信息。</td>
</tr>
<tr>
<td align="left">sandbox</td>
<td align="left">该属性对呈现在 iframe 框架中的内容启用一些额外的限制条件。属性值可以为空字符串（这种情况下会启用所有限制），也可以是用空格分隔的一系列指定的字符串。有效的值有：<br /> <code>allow-downloads-without-user-activation</code> : 允许在没有征求用户同意的情况下下载文件.<br /> <code>allow-forms</code>: 允许嵌入的浏览上下文提交表单。如果没有使用该关键字，则无法提交表单。<br /> <code>allow-modals</code>: 允许嵌入的浏览上下文打开模态窗口。 <br /><code>allow-orientation-lock</code>: 允许嵌入的浏览上下文锁定屏幕方向（译者注：比如智能手机、平板电脑的水平朝向或垂直朝向）。<br /> <code>allow-pointer-lock</code>: 允许嵌入的浏览上下文使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Pointer_Lock_API">Pointer Lock API</a>.<br /> <code>allow-popups</code>: 允许弹窗 (例如 window.open, target=”_blank”, <code>showModalDialog</code>)。如果没有使用该关键字，相应的功能将自动被禁用。 <br /><code>allow-popups-to-escape-sandbox</code>:  允许沙箱化的文档打开新窗口，并且新窗口不会继承沙箱标记。例如，安全地沙箱化一个广告页面，而不会在广告链接到的新页面中启用相同的限制条件。<br /> <code>allow-presentation</code>: 允许嵌入的浏览上下文开始一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/PresentationRequest"> presentation session</a>。 <br /><code>allow-same-origin</code>: 如果没有使用该关键字，嵌入的浏览上下文将被视为来自一个独立的源，这将使 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Same-origin_policy">same-origin policy</a> 同源检查失败。<br /> <code>allow-scripts</code>: 允许嵌入的浏览上下文运行脚本（但不能创建弹窗）。如果没有使用该关键字，就无法运行脚本。 <br /><code>allow-storage-access-by-user-activation</code> : 允许嵌入的浏览上下文通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage_Access_API">Storage Access API</a> 使用父级浏览上下文的存储功能。<br /> <code>allow-top-navigation</code>: 允许嵌入的浏览上下文导航（加载）内容到顶级的浏览上下文。<br /> <code>allow-top-navigation-by-user-activation</code>: 允许嵌入的浏览上下文<strong>在经过用户允许后</strong>导航（加载）内容到顶级的浏览上下文。</td>
</tr>
<tr>
<td align="left">src</td>
<td align="left">被嵌套的页面的 URL 地址。使用 <code>about:blank</code> 值可以嵌入一个遵从<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>的空白页。在 Firefox （version 65及更高版本）、基于 Chromium 的浏览器、Safari/iOS 中使用代码移除 <code>iframe</code> 的 <code>src</code> 属性（例如通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/removeAttribute"><code>Element.removeAttribute()</code></a> ）会导致 <code>about:blank</code> 被载入 frame。</td>
</tr>
<tr>
<td align="left">srcdoc</td>
<td align="left">该属性是一段HTML代码，这些代码会被渲染到 iframe 中。如果浏览器不支持 <code>srcdoc</code> 属性，则会渲染 <code>src</code> 属性表示的内容。</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left">以CSS像素格式<a href="https://developer.mozilla.org/zh-CN/docs/HTML/HTML5">HTML5</a>，或以像素格式HTML 4.01，或以百分比格式指定的 frame 的宽度。默认值是<code>300</code>。</td>
</tr>
</tbody></table>
<p><strong>优点：</strong></p>
<ul>
<li>  用来加载速度较慢的内容（如广告）</li>
<li>  可以使脚本可以并行下载</li>
<li>  可以实现跨子域通信</li>
<li>  如果有多个网页引用iframe，那么只需要修改iframe的内容，就可以实现调用每一个页面的更改，方便快捷。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  iframe 会阻塞主页面的 onload 事件</li>
<li>  代码复杂，无法被一些搜索引擎索引到，搜索引擎爬虫还不能很好的处理iframe中的内容，所以不利于搜索引擎优化。</li>
<li>  会产生很多页面，不容易管理</li>
<li>  很多移动设备无法完全显示框架，设备兼容性差</li>
<li>  iframe框架页面会增加服务器的http请求，对于大型网站是不可取的</li>
</ul>
<h2 id="14-label-的作用是什么？如何使用？"><a href="#14-label-的作用是什么？如何使用？" class="headerlink" title="14. label 的作用是什么？如何使用？"></a>14. label 的作用是什么？如何使用？</h2><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>
<ul>
<li>  使用方法1：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mobile&quot;</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mobile&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  使用方法2：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h2><p><strong>（1）SVG：</strong> SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p>
<p>其特点如下：</p>
<ul>
<li>  不依赖分辨率</li>
<li>  支持事件处理器</li>
<li>  最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
<li>  复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>
<li>  不适合游戏应用</li>
</ul>
<p><strong>（2）Canvas：</strong> Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p>
<p>其特点如下：</p>
<ul>
<li>  依赖分辨率</li>
<li>  不支持事件处理器</li>
<li>  弱的文本渲染能力</li>
<li>  能够以 .png 或 .jpg 格式保存结果图像</li>
<li>  最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>
</ul>
<p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p>
<h2 id="16-head-标签有什么作用，其中什么标签必不可少？"><a href="#16-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="16. head 标签有什么作用，其中什么标签必不可少？"></a>16. head 标签有什么作用，其中什么标签必不可少？</h2><p>标签用于定义文档的头部，它是所有头部元素的容器。 标签中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p>
<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>
<p>下面这些标签可用在 head 部分：<code>&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;&lt;noscript&gt;</code>。</p>
<p><strong>经过测试，好像没有必需的标签</strong></p>
<table>
<thead>
<tr>
<th>元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;title&gt;</td>
<td align="left">定义文档的标题，显示在浏览器的标题栏或标签页上，一般会完整地概括整个网页的内容</td>
</tr>
<tr>
<td>&lt;base&gt;</td>
<td align="left">指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个 &lt;base&gt; 元素。</td>
</tr>
<tr>
<td>&lt;link&gt;</td>
<td align="left">规定外部资源与当前文档的关系，常用于链接样式表：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;xxx.css&quot; type=&quot;text/css&quot;&gt;</code><br />还有其它作用：<br />1. 用于 SEO ，主要是给搜索引擎看的：<code>&lt;link rel=&quot;canonical&quot; href=&quot;...&quot;&gt;</code><br />2. 提供 rss 订阅：<code>&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;...&quot;&gt;</code><br />3. 表示页面 icon ：<code>&lt;link rel=&quot;icon&quot; href=&quot;https://xxx.png&quot;&gt;</code><br />4. 对页面提供预处理：<code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//xxx.com&quot;&gt;</code>，提前对一个域名做 dns 查询。强制对域名进行预读取在有的情况下很有用。比如, 在网站的主页上，强制在整个网站上对频繁引用的域名做预解析处理，即使它们不在主页本身上使用。虽然主页的性能可能不受影响，但是会提高站点整体性能。</td>
</tr>
<tr>
<td>&lt;style&gt;</td>
<td align="left">包含文档的样式信息。</td>
</tr>
<tr>
<td>&lt;meta&gt;</td>
<td align="left">一种通用的元数据信息表示标签。见上述5</td>
</tr>
<tr>
<td>&lt;script&gt;</td>
<td align="left">用于嵌入或引用可执行脚本。见上述4</td>
</tr>
<tr>
<td>&lt;noscript&gt;</td>
<td align="left">如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在此中定义脚本未被执行时的替代内容。可以包含除&lt;script&gt;外任何可以出现在&lt;body&gt;标签中的内容</td>
</tr>
</tbody></table>
<h2 id="17-文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#17-文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="17. 文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>17. 文档声明（Doctype）和<code>&lt;!Doctype html&gt;</code>有何作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><p><strong>文档声明的作用：</strong> 文档声明是为了告诉浏览器，当前<code>HTML</code>文档使用什么版本的<code>HTML</code>来写的，这样浏览器才能按照声明的版本来正确的解析。</p>
<p><code>&lt;!Doctype html&gt;</code><strong>的作用：</strong><code>&lt;!doctype html&gt;</code> 的作用就是让浏览器进入标准模式，使用最新的 <code>HTML5</code> 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。</p>
<p><strong>严格模式与混杂模式的区分：</strong></p>
<ul>
<li>  <strong>严格模式</strong>： 又称为标准模式，指浏览器按照<code>W3C</code>标准解析代码；</li>
<li>  <strong>混杂模式</strong>： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；</li>
</ul>
<p><strong>区分</strong>：网页中的<code>DTD</code>，直接影响到使用的是严格模式还是浏览模式，可以说<code>DTD</code>的使用与这两种方式的区别息息相关。</p>
<ul>
<li>  如果文档包含严格的<code>DOCTYPE</code> ，那么它一般以严格模式呈现（<strong>严格 DTD ——严格模式</strong>）；</li>
<li>  包含过渡 <code>DTD</code> 和 <code>URI</code> 的 <code>DOCTYPE</code> ，也以严格模式呈现，但有过渡 <code>DTD</code> 而没有 <code>URI</code> （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（<strong>有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式</strong>）；</li>
<li>  <code>DOCTYPE</code> 不存在或形式不正确会导致文档以混杂模式呈现（<strong>DTD不存在或者格式不正确——混杂模式</strong>）；</li>
<li>  <code>HTML5</code> 没有 <code>DTD</code> ，因此也就没有严格模式与混杂模式的区别，<code>HTML5</code> 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(<strong>HTML5 没有严格和混杂之分</strong>在使用HTML5的时候，在开头只写了这一句话，浏览器也能解析，原因是：HTML5不基于 SGML，所以不需要引用DTD，但是需要DOCTYPE来规范浏览器的行为，让浏览器按照W3C的标准解析渲染页面。 而HTML4.01和XHTML1.0基于SGML，所以需要引用DTD，才能告诉浏览器使用哪种DTD来解析文档。)。</li>
</ul>
<p>总之，<strong>严格模式让各个浏览器统一执行一套规范，兼容模式保证了旧网站的正常运行。</strong></p>
<p>在怪异模式下，盒模型为IE模型 ；严格模式下为W3C标准的盒模型</p>
<p>参考：<a href="https://juejin.cn/post/6989264337143595044%EF%BC%9Bhttps://juejin.cn/post/6969072081308745764">https://juejin.cn/post/6989264337143595044；https://juejin.cn/post/6969072081308745764</a></p>
<h2 id="18-浏览器乱码的原因是什么？如何解决？"><a href="#18-浏览器乱码的原因是什么？如何解决？" class="headerlink" title="18. 浏览器乱码的原因是什么？如何解决？"></a>18. 浏览器乱码的原因是什么？如何解决？</h2><p><strong>产生乱码的原因：</strong></p>
<ul>
<li>  网页源代码是<code>gbk</code>的编码，而内容中的中文字是<code>utf-8</code>编码的，这样浏览器打开即会出现<code>html</code>乱码，反之也会出现乱码；</li>
<li>  <code>html</code>网页编码是<code>gbk</code>，而程序从数据库中调出呈现是<code>utf-8</code>编码的内容也会造成编码乱码；</li>
<li>  浏览器不能自动检测网页编码，造成网页乱码。</li>
</ul>
<p><strong>解决办法：</strong></p>
<ul>
<li>  使用软件编辑HTML网页内容；</li>
<li>  如果网页设置编码是<code>gbk</code>，而数据库储存数据编码格式是<code>UTF-8</code>，此时需要程序查询数据库数据显示数据前进程序转码；</li>
<li>  如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li>
</ul>
<h2 id="19-渐进增强和优雅降级之间的区别"><a href="#19-渐进增强和优雅降级之间的区别" class="headerlink" title="19. 渐进增强和优雅降级之间的区别"></a>19. 渐进增强和优雅降级之间的区别</h2><p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。 </p>
<p><strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p>
<p><strong>两者区别：</strong></p>
<ul>
<li>  优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li>
<li>  降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>
</ul>
<p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>
<p>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p>
<h2 id="20-说一下-HTML5-drag-API"><a href="#20-说一下-HTML5-drag-API" class="headerlink" title="20. 说一下 HTML5 drag API"></a>20. 说一下 HTML5 drag API</h2><p>参考：<a href="https://juejin.cn/post/7014414669221724190">https://juejin.cn/post/7014414669221724190</a></p>
<p><strong>draggable</strong></p>
<ul>
<li>  当我们想让元素变成可拖拽时，我们就需要设置 draggable 属性。</li>
<li>  属性值未设置的情况下，默认是 auto，此时拖拽行为为浏览器默认行为，只有选中的文字，链接，图片可以拖动。</li>
<li>  draggable 属性值不是 Boolean 类型，需要显式设置为 true 或者 false，true 为可拖动，false 为不可拖动</li>
</ul>
<p><strong>拖拽事件</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发时刻</th>
</tr>
</thead>
<tbody><tr>
<td>dragstart</td>
<td>当用户开始拖拽一个元素或选中的文本时触发</td>
</tr>
<tr>
<td>drag</td>
<td>当拖拽元素或选中的文本时触发</td>
</tr>
<tr>
<td>dragend</td>
<td>当拖拽操作结束时触发</td>
</tr>
<tr>
<td>dragenter</td>
<td>当拖拽元素或选中的文本到一个可放置的目标时触发</td>
</tr>
<tr>
<td>dragover</td>
<td>当元素或选中的文本被拖到一个可放置的目标上时触发（每100毫秒触发一次）</td>
</tr>
<tr>
<td>drop</td>
<td>当元素或选中的文本在可放置的目标上被释放时触发</td>
</tr>
<tr>
<td>dragleave</td>
<td>当拖拽元素或选中的文本离开一个可放置的目标时触发。</td>
</tr>
<tr>
<td>dragexit</td>
<td>和dragleave类似，但是兼容性不好，建议不要使用。</td>
</tr>
</tbody></table>
<p><strong>事件分类</strong>：</p>
<ul>
<li>  可拖拽元素：dragstart，drag，dragend</li>
<li>  可放置的元素：dragenter，dragover，drop，dragleave</li>
</ul>
<p>拖拽事件的 event 对象 dragEvent 继承 mouseEvent，dragEvent 有个属性 dataTransfer，dataTransfer 属性是一个 DataTransfer 对象</p>
<p><strong>拖拽数据对象</strong>涉及到三个类：DataTransfer, DataTransferItemList, DataTransferItem</p>
<ul>
<li>DataTransfer<ul>
<li>  DataTransfer 对象用于保存在拖放操作期间拖动的数据，同时还可以设置拖拽样式，读取拖拽文件等等。它可以包含一个或多个数据项，每个数据项包含一个或多个数据类型。</li>
<li>  所有拖拽事件中我们都可以通过 event.dataTransfer 访问到它。</li>
</ul>
</li>
<li>dropEffect 和 effectAllowed<ul>
<li>  <code>dropEffect</code> 用于表示放置区接受什么行为的拖放，一般在 dragenter 和 dragover 中设置；</li>
<li>  对应的 <code>effectAllowed</code> 表示这次拖拽的行为是什么行为，要在 dragstart 中设置。</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>拖放示例-文本<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#drop-area</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#660000</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#drag-el</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: palegoldenrod;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;drop-area&quot;</span>&gt;</span>423423423<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;drag-el&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> dragEl = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#drag-el&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> dropArea = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#drop-area&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    dragEl.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      event.dataTransfer.setData(<span class="string">&#x27;text/plain&#x27;</span>, event.target.id)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    dropArea.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 通知浏览器不要执行事件的常规内置操作</span></span></span><br><span class="line"><span class="javascript">      event.preventDefault()</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    dropArea.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> id = event.dataTransfer.getData(<span class="string">&#x27;text/plain&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      dropArea.appendChild(<span class="built_in">document</span>.getElementById(id))</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="21-为什么-script-标签放在-body-最后，css-放在-head-里面"><a href="#21-为什么-script-标签放在-body-最后，css-放在-head-里面" class="headerlink" title="21. 为什么 script 标签放在 body 最后，css 放在 head 里面"></a>21. 为什么 script 标签放在 body 最后，css 放在 head 里面</h2><h2 id="22-导入-css-的方式，为什么建议用-link-而不是-import（见02-CSS）"><a href="#22-导入-css-的方式，为什么建议用-link-而不是-import（见02-CSS）" class="headerlink" title="22. 导入 css 的方式，为什么建议用 link 而不是 @import（见02.CSS）"></a>22. 导入 css 的方式，为什么建议用 link 而不是 @import（见02.CSS）</h2><p>import会增加http请求（进而影响加载速度）</p>
<h2 id="23-HTML-的全局属性"><a href="#23-HTML-的全局属性" class="headerlink" title="23. HTML 的全局属性"></a>23. HTML 的全局属性</h2><h2 id="24-Geolocation-API（地理定位）用于定位用户的位置。"><a href="#24-Geolocation-API（地理定位）用于定位用户的位置。" class="headerlink" title="24. Geolocation API（地理定位）用于定位用户的位置。"></a>24. Geolocation API（地理定位）用于定位用户的位置。</h2><h2 id="25-WebSockets"><a href="#25-WebSockets" class="headerlink" title="25. WebSockets"></a>25. WebSockets</h2><h2 id="26-Communication-API"><a href="#26-Communication-API" class="headerlink" title="26. Communication API"></a>26. Communication API</h2><h2 id="27-lt-img-gt-title-和-alt-的区别"><a href="#27-lt-img-gt-title-和-alt-的区别" class="headerlink" title="27. &lt;img&gt; title 和 alt 的区别"></a>27. &lt;img&gt; title 和 alt 的区别</h2>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS面试题</title>
    <url>/2021/11/27/css/</url>
    <content><![CDATA[<p>绝大部分内容来自：<a href="https://juejin.cn/user/3544481220801815">https://juejin.cn/user/3544481220801815</a></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2021/11/27/css/02.CSS%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="02.CSS面试题"></p>
<h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><ol>
<li><p>基本选择器</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>通用选择器</td>
<td>*</td>
<td>所有元素</td>
<td>2</td>
</tr>
<tr>
<td>元素类型选择器</td>
<td>&lt;元素类型&gt;（例如：div）</td>
<td>所有指定类型的元素</td>
<td>1</td>
</tr>
<tr>
<td>元素类选择器</td>
<td>&lt;类型&gt;(或 *.&lt;类型&gt;)<br />&lt;元素类型&gt;.&lt;类名&gt;</td>
<td>属于指定类的元素；<br />当跟元素类型一起使用时，匹配属于指定类的特定类型的元素</td>
<td>1</td>
</tr>
<tr>
<td>ID选择器</td>
<td>#&lt;id值&gt;</td>
<td>具有指定全局属性 id 值的元素</td>
<td>1</td>
</tr>
<tr>
<td>属性选择器</td>
<td>[&lt;条件&gt;]<br />&lt;元素类型&gt;[&lt;条件&gt;]</td>
<td>具有匹配指定条件的属性的元素；<br />当跟元素类型一起使用时，匹配满足条件的特定类型的元素<br />条件说明（括号内为最低支持版本）：<br />1.[attr]：选择定义attr属性的元素，忽略属性值（2）<br />2.[attr=“val”]：选择定义attr属性，且属性值为val的元素（2）<br />3.[attr^=“val”]：选择定义attr属性，且属性值以字符串val打头的元素（3）<br />4.[attr$=“val”]：选择定义attr属性，且属性值以字符串val结尾的元素（3）<br />5.[attr*=“val”]：选择定义attr属性，且属性值包含字符串val的元素（3）<br />6.[attr~=“val”]：选择定义attr属性，且属性值具有多个值，其中一个为字符串val的元素（2）<br />7.[attr|=“val”]：选择定义attr属性，且属性值为连字符分割的多个值，其中第一个为字符串val的元素（2）</td>
<td>视情况定</td>
</tr>
</tbody></table>
</li>
<li><p>复合选择器</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>并集选择器</td>
<td>&lt;选择器&gt;,&lt;选择器&gt;,&lt;选择器&gt;</td>
<td>单个选择器匹配的所有元素的并集</td>
<td>1</td>
</tr>
<tr>
<td>后代选择器</td>
<td>&lt;第一个选择器&gt; &lt;第二个选择器&gt;</td>
<td>目标元素为匹配第一个选择器的元素的后代，且匹配第二个选择器</td>
<td>1</td>
</tr>
<tr>
<td>子代选择器</td>
<td>&lt;第一个选择器&gt; &gt; &lt;第二个选择器&gt;</td>
<td>目标元素为匹配第一个选择器的元素的直接后代，且匹配第二个选择器</td>
<td>2</td>
</tr>
<tr>
<td>相邻兄弟选择器</td>
<td>&lt;第一个选择器&gt; + &lt;第二个选择器&gt;</td>
<td>目标元素紧跟匹配第一个选择器的元素，且匹配第二个选择器</td>
<td>2</td>
</tr>
<tr>
<td>普通兄弟选择器</td>
<td>&lt;第一个选择器&gt; ~ &lt;第二个选择器&gt;</td>
<td>目标元素位于匹配第一个选择器的元素之后，且匹配第二个选择器</td>
<td>3</td>
</tr>
</tbody></table>
</li>
<li><p>伪元素选择器</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>::first-line 选择器</td>
<td>::first-line</td>
<td>文本内容的首行</td>
<td>1</td>
</tr>
<tr>
<td>::first-letter 选择器</td>
<td>::first-letter</td>
<td>文本内容的首字母</td>
<td>1</td>
</tr>
<tr>
<td>:before 选择器</td>
<td>:before</td>
<td>说明：在选中元素的内容之前插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:after 选择器</td>
<td>:after</td>
<td>说明：在选中元素的内容之后插入内容</td>
<td>2</td>
</tr>
</tbody></table>
<blockquote>
<p>  伪元素选择器的前缀是两个冒号（ :: ），但浏览器认为选择器只有一个冒号（也就是说将 ::first-line看做 ::first-line）。这样它的格式就跟伪类选择器的格式一致了，这是为了向后兼容。</p>
</blockquote>
</li>
<li><p>伪类选择器</p>
<ol>
<li><p>结构性伪类选择器</p>
 <table>
       <tr>
         <th>选择器类型</th>
         <th>选择器</th>
         <th>匹配/说明</th>
         <th>最低支持CSS版本</th>
     </tr>
     <tr>
         <td>:root 选择器</td>
         <td>:root</td>
         <td>选择文档中的根元素，总是返回html</td>
         <td>3</td>
     </tr>
     <tr>
         <td rowspan="4">子元素选择器</td>
         <td>:first-child</td>
         <td>选择元素的第一个元素</td>
         <td>2</td>
     </tr>
     <tr>
         <td>:last-child</td>
         <td>选择元素的最后一个元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:only-child</td>
         <td>选择元素的唯一子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:only-of-type</td>
         <td>选择元素指定类型的唯一子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td rowspan="4">:nth-child 选择器</td>
         <td>:nth-child(n)</td>
         <td>选择父元素的第n个子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:nth-last-child(n)</td>
         <td>选择父元素的倒数第n个子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:nth-of-type(n)</td>
         <td>选择父元素定义类型的第n个子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:nth-last-of-type(n)</td>
         <td>选择父元素定义类型的倒数第n个子元素</td>
         <td>3</td>
     </tr>
 </table></li>
<li><p>UI 伪类选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>:enabled</td>
<td>选择启用状态的元素</td>
<td>3</td>
</tr>
<tr>
<td>:disabled</td>
<td>选择禁用状态的元素</td>
<td>3</td>
</tr>
<tr>
<td>:checked</td>
<td>选择被选中的input的元素（只用于单选按钮和复选框）</td>
<td>3</td>
</tr>
<tr>
<td>:default</td>
<td>选择默认元素</td>
<td>3</td>
</tr>
<tr>
<td>:valid<br />:invalid</td>
<td>根据输入验证选择有效或者无效的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:in-range<br />:out-of-range</td>
<td>选择在指定范围之内或者之外受限的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:required<br />:optional</td>
<td>根据是否允许 :required 属性选择input元素</td>
<td>3</td>
</tr>
</tbody></table>
</li>
<li><p>动态伪类选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>匹配/说明</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>:link</td>
<td>选择链接元素</td>
<td>1</td>
</tr>
<tr>
<td>:visited</td>
<td>选择用户已访问的链接元素</td>
<td>1</td>
</tr>
<tr>
<td>:hover</td>
<td>鼠标悬停在其上的元素</td>
<td>2</td>
</tr>
<tr>
<td>:active</td>
<td>当前被用户激活的元素，通常意味着用户即将点击（或者按压）该元素</td>
<td>2</td>
</tr>
<tr>
<td>:focus</td>
<td>当前获得焦点的元素</td>
<td>2</td>
</tr>
</tbody></table>
</li>
<li><p>其它伪类选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>:not(&lt;选择器&gt;)</td>
<td>对括号内选择器的选择取反</td>
<td>3</td>
</tr>
<tr>
<td>:empty</td>
<td>没有子元素的元素</td>
<td>3</td>
</tr>
<tr>
<td>:lang(&lt;目标语言&gt;)</td>
<td>选择基于lang全局属性值的元素</td>
<td>1</td>
</tr>
<tr>
<td>:target</td>
<td>URL片段标识符指向的元素</td>
<td>3</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<p><strong>从层叠、继承、优先级来讨论如果有多个应用于某个元素的css样式时，为什么会显示这个样式，而不会显示另外一个样式：</strong></p>
<ul>
<li><p>层叠</p>
<ul>
<li>  层叠的概念是如果优先级相等，对于同一元素，后面的css样式会覆盖前面的css样式；</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li>  继承的概念是子元素会继承父元素的某些属性，从而表现出和父元素一样的样式；</li>
<li>  这里要注意的是有些元素可以被继承（eg：color，font-family）,有些则不能被继承（eg：height，width）；</li>
</ul>
</li>
<li><p>优先级</p>
<ul>
<li><p>选择器优先级的计算方式</p>
<ul>
<li>  第一位加1：如果某个元素具有内联样式，虽然没有选择器，具有内联样式时此位恒为1；</li>
<li>  第二位加1：如果选择器包含一个id选择器时；</li>
<li>  第三位加1：如果选择器包含一个类选择器、伪类选择器或属性选择器时；</li>
<li>  第四位加1：如果选择器包含一个元素选择器或伪元素选择器时；</li>
</ul>
<p>  注：通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ‘ ‘)，和否定伪类 (<code>:not</code>) 不会影响优先级。</p>
</li>
<li><p>注意事项</p>
<ul>
<li>  !important声明的样式的优先级最高，权重为正无穷；</li>
<li>  如果优先级相同，则最后出现的样式生效；</li>
<li>  继承得到的样式的优先级最低；</li>
<li>  通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li>
<li>  样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p>
<ol>
<li> <strong>display</strong>：规定元素应该生成的框的类型</li>
<li><strong>文本属性</strong>：<ul>
<li>  vertical-align：垂直文本对齐</li>
<li>  text-decoration：规定添加到文本的装饰</li>
<li>  text-shadow：文本阴影效果</li>
<li>  white-space：空白符的处理</li>
<li>  unicode-bidi：设置文本的方向</li>
</ul>
</li>
<li> <strong>盒子模型的属性</strong>：width、height、margin、border、padding</li>
<li> <strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li>
<li> <strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
<li> <strong>生成内容属性</strong>：content、counter-reset、counter-increment</li>
<li> <strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li>
<li> <strong>页面样式属性</strong>：size、page-break-before、page-break-after</li>
<li> <strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li>
</ol>
<p><strong>二、有继承性的属性</strong></p>
<ol>
<li><strong>字体系列属性</strong><ul>
<li>  font-family：字体系列</li>
<li>  font-weight：字体的粗细</li>
<li>  font-size：字体的大小</li>
<li>  font-style：字体的风格</li>
</ul>
</li>
<li><strong>文本系列属性</strong><ul>
<li>  text-indent：文本缩进</li>
<li>  text-align：文本水平对齐</li>
<li>  line-height：行高</li>
<li>  word-spacing：单词之间的间距</li>
<li>  letter-spacing：中文或者字母之间的间距</li>
<li>  text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li>
<li>  color：文本颜色</li>
</ul>
</li>
<li><strong>元素可见性</strong><ul>
<li>  visibility：控制元素显示隐藏</li>
</ul>
</li>
<li><strong>列表布局属性</strong><ul>
<li>  list-style：列表风格，包括list-style-type、list-style-image等</li>
</ul>
</li>
<li><strong>光标属性</strong><ul>
<li>  cursor：光标显示为何种形态</li>
</ul>
</li>
</ol>
<h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>此元素不会被显示。</td>
</tr>
<tr>
<td>block</td>
<td>此元素将显示为块级元素，此元素前后会带有换行符。</td>
</tr>
<tr>
<td>inline</td>
<td>默认。此元素会被显示为内联元素，元素前后没有换行符。</td>
</tr>
<tr>
<td>inline-block</td>
<td>行内块元素。（CSS2.1 新增的值）</td>
</tr>
<tr>
<td>list-item</td>
<td>此元素会作为列表显示。</td>
</tr>
<tr>
<td>run-in</td>
<td>此元素会根据上下文作为块级元素或内联元素显示。</td>
</tr>
<tr>
<td>compact</td>
<td>CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td>
</tr>
<tr>
<td>marker</td>
<td>CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。<br />1.inline-table: 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。<br />2.table-row-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。<br />3.table-header-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。<br />4.table-footer-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。<br />5.table-row: 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。<br />6.table-column-group: 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。<br />7.table-column: 此元素会作为一个单元格列显示（类似 &lt;col&gt;）<br />8.table-cell: 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;）<br />9.table-caption: 此元素会作为一个表格标题显示（类似 &lt;caption&gt;）</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 display 属性的值。</td>
</tr>
</tbody></table>
<h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><ol>
<li> <strong>block：</strong> 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</li>
<li> <strong>inline：</strong> 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li>
<li> <strong>inline-block：</strong> 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</li>
</ol>
<p>对于行内元素和块级元素，其特点如下：</p>
<ol>
<li><strong>行内元素</strong><ul>
<li>  设置宽高无效；</li>
<li>  可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li>
<li>  不会自动换行；</li>
</ul>
</li>
<li><strong>块级元素</strong><ul>
<li>  可以设置宽高；</li>
<li>  设置margin和padding都有效；</li>
<li>  可以自动换行；</li>
<li>  多个块状，默认排列从上到下。</li>
</ul>
</li>
</ol>
<h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul>
<li>  <strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li>
<li>  <strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li>
<li>  <strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li>
<li>  <strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li>
<li>  <strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li>
<li>  <strong>clip/clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li>
<li>  **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li>
</ul>
<h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p><strong>两者都是外部引用CSS的方式，它们的区别如下：</strong></p>
<ul>
<li>  link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li>
<li>  link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>  link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li>
<li>  link支持使用Javascript控制DOM去改变样式；而@import不支持。</li>
</ul>
<p><strong>link先于@import加载，为什么@import和link优先级相同，@import的样式没有覆盖link？</strong></p>
<ul>
<li>  浏览器渲染的动作一般会执行多次的。最后一次渲染，一定是基于之前加载过的所有样式整合后渲染树进行绘制页面的，已经被渲染过的页面元素，也会被重新渲染。</li>
<li>  那么我们就可以把@import这种导入 CSS 文件的方式理解成一种替换，CSS 解析引擎在对一个 CSS 文件进行解析时，如在文件顶部遇到@import，将被替换为该@import导入的 CSS 文件中的全部样式。</li>
<li>  @import引入的样式，其虽然后被加载，却会在加载完毕后置于样式表顶部，最终渲染时自然会被下面的同名样式层叠。</li>
</ul>
<p><strong>为什么建议用link而不是@import</strong></p>
<ul>
<li>  每个@import都会产生一个新的http请求，消耗服务器资源</li>
<li>  @import混合js文件时，在IE中引发资源文件的下载顺序被打乱（即使排列在@import后面的js文件先于@import下载），而且会打乱甚至破坏@import自身的并行下载 </li>
<li>  link混合@import会破坏并行下载，这会导致原本并行下载的样式变成一个一个的同步下载</li>
<li>  仅用link标签，可确保样式在所有浏览器里面都能被并行且按照顺序被下载</li>
<li>  如果import加载的样式比较大，容易出现加载延迟，甚至有闪屏的情况</li>
</ul>
<h3 id="7-transition和animation的区别"><a href="#7-transition和animation的区别" class="headerlink" title="7. transition和animation的区别"></a>7. transition和animation的区别</h3><ul>
<li>  <strong>transition是过渡属性</strong>，强调过渡，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</li>
<li>  <strong>animation是动画属性</strong>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</li>
</ul>
<h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者区别如下：</strong></p>
<ol>
<li><strong>在渲染树中</strong><ul>
<li>  <code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li>
<li>  <code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li>
</ul>
</li>
<li><strong>是否是继承属性</strong><ul>
<li>  <code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li>
<li>  <code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；</li>
</ul>
</li>
<li> 修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</li>
<li> 如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</li>
</ol>
<h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. 伪元素和伪类的区别和作用？</h3><p><strong>定义</strong></p>
<ul>
<li><p>  伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。</p>
</li>
<li><p>  伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</p>
</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><p>表示方法</p>
<p>  CSS2 中伪类、伪元素都是以单冒号<code>:</code>表示，CSS2.1 后规定伪类用单冒号表示，伪元素用双冒号<code>::</code>表示，浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first-line, :first-letter 等)的单冒号写法。对于 CSS2 之后所有新增的伪元素(如::selection)，应该采用双冒号的写法。但是因为兼容性问题，大部分还是用的单冒号。</p>
</li>
<li><p>定义不同</p>
<p>  伪类即假的类，通常可以添加类来达到效果，伪元素即假元素，需要通过添加元素才能达到效果。</p>
</li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li>  伪类和伪元素都是用来表示文档树以外的”元素”。</li>
<li>  伪类和伪元素分别用单冒号<code>:</code>和双冒号<code>::</code>来表示。</li>
<li>  伪类和伪元素的区别，最关键的点在于如果没有伪元素(或伪类)，是否需要添加元素才能达到目的，如果是则是伪元素，反之则是伪类。</li>
</ul>
<h3 id="10-对requestAnimationframe的理解"><a href="#10-对requestAnimationframe的理解" class="headerlink" title="10. 对requestAnimationframe的理解"></a>10. 对requestAnimationframe的理解</h3><p>参考：<a href="https://juejin.cn/post/6991297852462858277#heading-3">https://juejin.cn/post/6991297852462858277#heading-3</a></p>
<p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是<strong>请求动画帧</strong>。</p>
<p>MDN对该方法的描述：</p>
<blockquote>
<p>  window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
</blockquote>
<p><strong>语法：</strong> <code>window.requestAnimationFrame(callback);</code>  其中，callback是<strong>下一次重绘之前更新动画帧所调用的函数</strong>(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p>
<p><strong>取消动画：</strong> 使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p>
<p><strong>优势：</strong></p>
<ul>
<li>  <strong>CPU节能</strong>：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li>
<li>  <strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li>
<li>  <strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
</ul>
<p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p>
<ul>
<li>  settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li>
<li>  settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li>
</ul>
<h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><ul>
<li><p>盒⼦模型的概念</p>
<p>  盒⼦模型（boxmodel）。⽹⻚中，每⼀个元素都占有⼀定的空间，⽆论是div、h1~h6、还是p，都可以看成是盒⼦。</p>
</li>
<li><p>盒⼦模型的组成</p>
<ul>
<li><p>⼀个元素占有空间的⼤小由⼏个部分构成，其中包括</p>
<ul>
<li>  元素的内容（content），</li>
<li>  元素的内边距（padding），内容与边框之间的距离</li>
<li>  元素的边框（border），</li>
<li>  元素的外边距（margin），边框与外部元素之间的距离</li>
</ul>
<p>  四个部分，这四个部分⼀起构成了盒⼦模型。</p>
</li>
<li><p>注意：margin重叠，也叫margin塌陷</p>
<p>  标准⽂档流中，两个盒⼦，分别有上下外边距，竖直⽅向的margin不叠加，只取较⼤的值作为margin(⽔平⽅向的margin是可以叠加的)。</p>
</li>
<li><p>  margin这个属性，本质上描述的是兄弟和兄弟之间的距离；最好不要⽤这个marign表达⽗⼦之间的距离。如果向设置⽗⼦之间的距离，我们最好使⽤⽗元素的padding。</p>
</li>
</ul>
</li>
<li><p>盒⼦模型的分类</p>
<ul>
<li>  盒模型分为：W3C标准盒⼦、IE盒⼦</li>
<li>  W3C标准盒⼦（content-box）：⼜称内容盒⼦，是指块元素box-sizing属性为content-box的盒模型。⼀般在现代浏览器中使⽤的都是正常盒模型content-box。它所说的width⼀般只包含内容，不包含padding与margin，并且盒⼦的⼤小会以内容优先，⾃动扩展，⼦元素可以撑开⽗元素.</li>
<li>  IE盒⼦（border-box）：⼜称怪异盒模型（边框盒⼦），是指块元素box-sizing属性为border-box的盒模型。⼀般在IE浏览器中默认为这种怪异盒模型，但是由于其⾃⾝的特殊性，⼿机⻚⾯中也有使⽤怪异盒模型。怪异盒模型中，⽗元素的盒模型确定，⼦元素⽆法撑开⽗元素的盒模型。</li>
</ul>
</li>
</ul>
<h3 id="12-为什么有时候⽤translate来改变位置⽽不是定位？"><a href="#12-为什么有时候⽤translate来改变位置⽽不是定位？" class="headerlink" title="12. 为什么有时候⽤translate来改变位置⽽不是定位？"></a>12. 为什么有时候⽤translate来改变位置⽽不是定位？</h3><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p>
<p>参考：<a href="https://juejin.cn/post/6844904077394984968#heading-0">https://juejin.cn/post/6844904077394984968#heading-0</a></p>
<h3 id="13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？"><a href="#13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？" class="headerlink" title="13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？"></a>13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？</h3><p>浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个<code>&lt;li&gt;</code>放在一行，这导致<code>&lt;li&gt;</code>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p>
<p><strong>解决办法：</strong></p>
<p>（1）为<code>&lt;li&gt;</code>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p>
<p>（2）将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</p>
<p>（3）将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即font-size:0。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p>
<p>（4）消除<code>&lt;ul&gt;</code>的字符间隔letter-spacing:-8px，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符间隔设为默认letter-spacing:normal。</p>
<h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><p>参考：<a href="https://juejin.cn/post/6844903518520901639#heading-43%EF%BC%8Chttps://juejin.cn/post/6844903829679390728#heading-3">https://juejin.cn/post/6844903518520901639#heading-43，https://juejin.cn/post/6844903829679390728#heading-3</a></p>
<ol>
<li><p> 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）见1</p>
</li>
<li><p>边框</p>
 <table>
       <tr>
         <th>属性</th>
         <th  colspan="2">说明</th>
     </tr>
     <tr>
         <td rowspan="6">border-image</td>
         <td colspan="2">使用图像作为边框的简写属性</td>
     </tr>
     <tr>
         <td>border-image-outset</td>
         <td>指定图像向边框盒外部扩展的区域</td>
     </tr>
     <tr>
         <td>border-image-repeat</td>
         <td>指定边框图像的缩放和重复方式</td>
     </tr>
     <tr>
         <td>border-image-slice</td>
         <td>指定边框图像的切割方式</td>
     </tr>
     <tr>
         <td>border-image-source</td>
         <td>设置边框图片的来源路径</td>
     </tr>
     <tr>
         <td>border-image-width</td>
         <td>设置边框图像的宽度</td>
     </tr>
     <tr>
         <td rowspan="5">border-radius</td>
         <td colspan="2">使用圆角边框的简写属性</td>
     </tr>
     <tr>
         <td>border-top-left-radius</td>
         <td>将边框左上角设置为圆角</td>
     </tr>
     <tr>
         <td>border-top-right-radius</td>
         <td>将边框右上角设置为圆角</td>
     </tr>
     <tr>
         <td>border-bottom-left-radius</td>
         <td>将边框左下角设置为圆角</td>
     </tr>
     <tr>
         <td>border-bottom-right-radius</td>
         <td>将边框右下角设置为圆角</td>
     </tr>
     <tr>
         <td>box-shadow</td>
         <td colspan="2">设置元素的一个或多个阴影效果</td>
     </tr>
 </table>    </li>
<li><p>背景</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background-clip</td>
<td>规定背景的绘制区域。</td>
</tr>
<tr>
<td>background-origin</td>
<td>规定背景图片的定位区域。</td>
</tr>
<tr>
<td>background-size</td>
<td>规定背景图片的尺寸。</td>
</tr>
</tbody></table>
</li>
<li><p>渐变</p>
<ul>
<li><p>线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(direction, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure></li>
<li><p>径向渐变（Radial Gradients）- 由它们的中心定义</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(center, shape size, start-color, ..., last-color);</span><br></pre></td></tr></table></figure></li>
<li><p>圆锥渐变（Conic Gradient）</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">conic-gradient</span>(red, orange, yellow, green, teal, blue, purple);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>文本属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@font-face</td>
<td>指定网页使用的字体</td>
</tr>
<tr>
<td>hanging-punctuation</td>
<td>规定标点字符是否位于线框之外。</td>
</tr>
<tr>
<td>punctuation-trim</td>
<td>规定是否对标点字符进行修剪。</td>
</tr>
<tr>
<td>text-align-last</td>
<td>设置如何对齐最后一行或紧挨着强制换行符之前的行。</td>
</tr>
<tr>
<td>text-emphasis</td>
<td>向元素的文本应用重点标记以及重点标记的前景色。</td>
</tr>
<tr>
<td>text-justify</td>
<td>规定当 text-align 设置为 “justify” 时所使用的对齐方法。</td>
</tr>
<tr>
<td>text-outline</td>
<td>规定文本的轮廓。</td>
</tr>
<tr>
<td>text-overflow</td>
<td>规定当文本溢出包含元素时发生的事情。</td>
</tr>
<tr>
<td>text-shadow</td>
<td>向文本添加阴影。</td>
</tr>
<tr>
<td>text-wrap</td>
<td>规定文本的换行规则。</td>
</tr>
<tr>
<td>word-break</td>
<td>规定非中日韩文本的换行规则。</td>
</tr>
<tr>
<td>word-wrap</td>
<td>允许对长的不可分割的单词进行分割并换行到下一行。</td>
</tr>
</tbody></table>
</li>
<li><p>转换和变形</p>
<p> <strong>2D新转换属性</strong></p>
<p> 以下列出了所有的转换属性:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>适用于2D或3D转换的元素</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许您更改转化元素位置</td>
</tr>
</tbody></table>
<p> <strong>2D 转换方法</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>matrix(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td>定义 2D 转换，使用六个值的矩阵。</td>
</tr>
<tr>
<td>translate(<em>x</em>,<em>y</em>)</td>
<td>定义 2D 转换，沿着 X 和 Y 轴移动元素。</td>
</tr>
<tr>
<td>translateX(<em>n</em>)</td>
<td>定义 2D 转换，沿着 X 轴移动元素。</td>
</tr>
<tr>
<td>translateY(<em>n</em>)</td>
<td>定义 2D 转换，沿着 Y 轴移动元素。</td>
</tr>
<tr>
<td>scale(<em>x</em>,<em>y</em>)</td>
<td>定义 2D 缩放转换，改变元素的宽度和高度。</td>
</tr>
<tr>
<td>scaleX(<em>n</em>)</td>
<td>定义 2D 缩放转换，改变元素的宽度。</td>
</tr>
<tr>
<td>scaleY(<em>n</em>)</td>
<td>定义 2D 缩放转换，改变元素的高度。</td>
</tr>
<tr>
<td>rotate(<em>angle</em>)</td>
<td>定义 2D 旋转，在参数中规定角度。</td>
</tr>
<tr>
<td>skew(<em>x-angle</em>,<em>y-angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 X 和 Y 轴。</td>
</tr>
<tr>
<td>skewX(<em>angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 X 轴。</td>
</tr>
<tr>
<td>skewY(<em>angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 Y 轴。</td>
</tr>
</tbody></table>
<p> <strong>3D转换属性</strong></p>
<p> 下表列出了所有的转换属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>向元素应用 2D 或 3D 转换。</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许你改变被转换元素的位置。</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示。</td>
</tr>
<tr>
<td>perspective</td>
<td>规定 3D 元素的透视效果。</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>规定 3D 元素的底部位置。</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>定义元素在不面对屏幕时是否可见。</td>
</tr>
</tbody></table>
<p> <strong>3D 转换方法</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>, <em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td>
</tr>
<tr>
<td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>定义 3D 转化。</td>
</tr>
<tr>
<td>translateX(<em>x</em>)</td>
<td>定义 3D 转化，仅使用用于 X 轴的值。</td>
</tr>
<tr>
<td>translateY(<em>y</em>)</td>
<td>定义 3D 转化，仅使用用于 Y 轴的值。</td>
</tr>
<tr>
<td>translateZ(<em>z</em>)</td>
<td>定义 3D 转化，仅使用用于 Z 轴的值。</td>
</tr>
<tr>
<td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>定义 3D 缩放转换。</td>
</tr>
<tr>
<td>scaleX(<em>x</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 X 轴的值。</td>
</tr>
<tr>
<td>scaleY(<em>y</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 Y 轴的值。</td>
</tr>
<tr>
<td>scaleZ(<em>z</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 Z 轴的值。</td>
</tr>
<tr>
<td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td>
<td>定义 3D 旋转。</td>
</tr>
<tr>
<td>rotateX(<em>angle</em>)</td>
<td>定义沿 X 轴的 3D 旋转。</td>
</tr>
<tr>
<td>rotateY(<em>angle</em>)</td>
<td>定义沿 Y 轴的 3D 旋转。</td>
</tr>
<tr>
<td>rotateZ(<em>angle</em>)</td>
<td>定义沿 Z 轴的 3D 旋转。</td>
</tr>
<tr>
<td>perspective(<em>n</em>)</td>
<td>定义 3D 转换元素的透视视图。</td>
</tr>
</tbody></table>
</li>
<li><p>反射</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片</span><br></pre></td></tr></table></figure></li>
<li><p>颜色</p>
<ul>
<li><p>rgba：rgb为颜色值，a为透明度</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">1</span>);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,.<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>hsla：h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”。使用HSLA时，透明度不会影响其后代元素</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">hsla</span>( <span class="number">112</span>, <span class="number">72%</span>, <span class="number">33%</span>, <span class="number">0.68</span>);</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">hsla</span>( <span class="number">49</span>, <span class="number">65%</span>, <span class="number">60%</span>, <span class="number">0.68</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>滤镜</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>原图<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>黑白色filter: grayscale(100%)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter: grayscale(100%);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>褐色filter:sepia(1)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:sepia(1);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>饱和度saturate(2)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:saturate(2);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>色相旋转hue-rotate(90deg)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:hue-rotate(90deg);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>反色filter:invert(1)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:invert(1);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>透明度opacity(.5)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:opacity(.5);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>亮度brightness(.5)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:brightness(.5);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>对比度contrast(2)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:contrast(2);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>模糊blur(3px)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:blur(3px);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>阴影drop-shadow(5px 5px 5px #000)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:drop-shadow(5px 5px 5px #000);&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>过渡</p>
<p> 下表列出了所有的过渡属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition.html">transition</a></td>
<td>简写属性，用于在一个属性中设置四个过渡属性。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-property.html">transition-property</a></td>
<td>规定应用过渡的 CSS 属性的名称。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-duration.html">transition-duration</a></td>
<td>定义过渡效果花费的时间。默认是 0。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-timing-function.html">transition-timing-function</a></td>
<td>规定过渡效果的时间曲线。默认是 “ease”。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-delay.html">transition-delay</a></td>
<td>规定过渡效果何时开始。默认是 0。</td>
</tr>
</tbody></table>
</li>
<li><p>动画</p>
<p> 下面的表格列出了 @keyframes 规则和所有动画属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-keyframes.html">@keyframes</a></td>
<td>规定动画。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation.html">animation</a></td>
<td>所有动画属性的简写属性，除了 animation-play-state 属性。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-name.html">animation-name</a></td>
<td>规定 @keyframes 动画的名称。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-duration.html">animation-duration</a></td>
<td>规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-timing-function.html">animation-timing-function</a></td>
<td>规定动画的速度曲线。默认是 “ease”。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-delay.html">animation-delay</a></td>
<td>规定动画何时开始。默认是 0。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-iteration-count.html">animation-iteration-count</a></td>
<td>规定动画被播放的次数。默认是 1。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-direction.html">animation-direction</a></td>
<td>规定动画是否在下一周期逆向地播放。默认是 “normal”。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-play-state.html">animation-play-state</a></td>
<td>规定动画是否正在运行或暂停。默认是 “running”。</td>
</tr>
</tbody></table>
</li>
<li><p>多列布局</p>
<p> 下表列出了所有 CSS3 的多列属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-count.html">column-count</a></td>
<td>指定元素应该被分割的列数。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-fill.html">column-fill</a></td>
<td>指定如何填充列</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-gap.html">column-gap</a></td>
<td>指定列与列之间的间隙</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule.html">column-rule</a></td>
<td>所有 column-rule-* 属性的简写</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule-color.html">column-rule-color</a></td>
<td>指定两列间边框的颜色</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule-style.html">column-rule-style</a></td>
<td>指定两列间边框的样式</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule-width.html">column-rule-width</a></td>
<td>指定两列间边框的厚度</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-span.html">column-span</a></td>
<td>指定元素要跨越多少列</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-width.html">column-width</a></td>
<td>指定列的宽度</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-columns.html">columns</a></td>
<td>设置 column-width 和 column-count 的简写</td>
</tr>
</tbody></table>
</li>
<li><p> 弹性盒布局</p>
</li>
<li><p> 栅格布局</p>
</li>
<li><p>盒模型</p>
<p> 在 CSS3 中, 增加了一些新的用户界面特性来调整元素尺寸，框尺寸和外边框，主要包括以下用户界面属性：</p>
<ul>
<li>  resize：none | both | horizontal | vertical | inherit</li>
<li>  box-sizing: content-box | border-box | inherit</li>
<li>  outline:outline-color outline-style outline-width outine-offset</li>
<li>  overflow-x：横向溢出处理方式</li>
<li>  overflow-y：纵向溢出处理方式</li>
</ul>
<p> resize属性指定一个元素是否应该由用户去调整大小。</p>
<p> box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。</p>
<p> outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</p>
</li>
<li><p>媒体查询</p>
<p> 从 CSS 版本 2 开始，就可以通过媒体类型在 CSS 中获得媒体支持。如果您曾经使用过打印样式表，那么您可能已经使用过媒体类型。清单 1 展示了一个示例。</p>
<p> <strong>清单 1. 使用媒体类型</strong></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;site.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;print.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p> <strong>清单 2. 媒体查询规则</strong></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">800px</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  <code>@media all</code> 是媒体类型，也就是说，将此 CSS 应用于所有媒体类型。</p>
</li>
<li><p>  <code>(min-width:800px)</code> 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 CSS。</p>
</li>
</ul>
<p> <strong>清单 3.</strong> <code>and</code> <strong>条件</strong></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>:<span class="number">800px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">1200px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>:portrait) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>清单 4.</strong> <code>or</code> <strong>关键词</strong></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>:<span class="number">800px</span>) <span class="keyword">or</span> (<span class="attribute">orientation</span>:portrait) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>清单 5. 使用</strong> <code>not</code></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="keyword">not</span> <span class="attribute">min-width</span>:<span class="number">800px</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其它</p>
<ul>
<li>  自定义属性和变量</li>
<li>  calc 函数</li>
<li>  <code>opacity </code> 属性</li>
</ul>
</li>
</ol>
<h3 id="15-替换元素的概念及计算规则"><a href="#15-替换元素的概念及计算规则" class="headerlink" title="15. 替换元素的概念及计算规则"></a>15. 替换元素的概念及计算规则</h3><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p>
<p>替换元素除了内容可替换这一特性以外，还有以下特性：</p>
<ul>
<li>  <strong>内容的外观不受页面上的CSS的影响</strong>：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li>
<li>  <strong>有自己的尺寸</strong>：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如</li>
<li>  <strong>在很多CSS属性上有自己的一套表现规则</strong>：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li>
<li>  <strong>所有的替换元素都是内联水平元素</strong>：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li>
</ul>
<p>替换元素的尺寸从内而外分为三类：</p>
<ul>
<li>  <strong>固有尺寸：</strong> 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li>
<li>  <strong>HTML尺寸：</strong> 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li>
<li>  <strong>CSS尺寸：</strong> 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</li>
</ul>
<p>这三层结构的计算规则具体如下： （1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。 （2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。 （3）如果有CSS尺寸，则最终尺寸由CSS属性决定。 （4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。 （5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。 （6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p>
<h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><ol>
<li> <strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</li>
<li> <strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</li>
<li> <strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</li>
<li> <strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</li>
<li> <strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</li>
<li> <strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</li>
<li><strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。<ul>
<li>  在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li>
<li>  在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li>
<li>  WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li>
</ul>
</li>
</ol>
<h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p>
<p><strong>优点：</strong></p>
<ul>
<li>  利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li>
<li>  <code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li>
<li>  <code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li>
<li>  维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li>
</ul>
<h3 id="18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？"><a href="#18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？" class="headerlink" title="18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？"></a>18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h3><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p>
<p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p>
<p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p>
<p>当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。</p>
<p>还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">my-image &#123; <span class="attr">background</span>: (low.png); &#125;</span><br><span class="line">@media only screen and (min-device-pixel-ratio: <span class="number">1.5</span>) &#123;</span><br><span class="line">  #my-image &#123; <span class="attr">background</span>: (high.png); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-margin-和-padding-的使用场景"><a href="#19-margin-和-padding-的使用场景" class="headerlink" title="19. margin 和 padding 的使用场景"></a>19. margin 和 padding 的使用场景</h3><ul>
<li>  需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li>
<li>  需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li>
</ul>
<h3 id="20-对line-height-的理解及其赋值方式"><a href="#20-对line-height-的理解及其赋值方式" class="headerlink" title="20. 对line-height 的理解及其赋值方式"></a>20. 对line-height 的理解及其赋值方式</h3><ol>
<li><strong>line-height的概念：</strong><ul>
<li>  line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；</li>
<li>  如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</li>
<li>  一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</li>
<li>  把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</li>
<li>  line-height 和 height 都能撑开一个高度；</li>
</ul>
</li>
<li><strong>line-height 的赋值方式：</strong><ul>
<li>  带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li>
<li>  纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li>
<li>  百分比：将计算后的值传递给后代</li>
</ul>
</li>
</ol>
<h3 id="21-CSS-优化和提高性能的方法有哪些？"><a href="#21-CSS-优化和提高性能的方法有哪些？" class="headerlink" title="21. CSS 优化和提高性能的方法有哪些？"></a>21. CSS 优化和提高性能的方法有哪些？</h3><ul>
<li><strong>加载性能：</strong><ol>
<li> css压缩：将写好的css进行打包压缩，可以减小文件体积。</li>
<li> css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。</li>
<li> 减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li>
</ol>
</li>
<li><strong>选择器性能：</strong><ol>
<li> 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li>
<li> 如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li>
<li> 避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</li>
<li> 尽量少的去对标签进行选择，而是用class。</li>
<li> 尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li>
<li> 了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li>
</ol>
</li>
<li><strong>渲染性能：</strong><ol>
<li> 慎重使用高性能属性：浮动、定位。</li>
<li> 尽量减少页面重排、重绘。</li>
<li> 去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li>
<li> 属性值为0时，不加单位。</li>
<li> 属性值为浮动小数0.**，可以省略小数点之前的0。</li>
<li> 标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li>
<li> 不使用@import前缀，它会影响css的加载速度。</li>
<li> 选择器优化嵌套，尽量避免层级过深。</li>
<li> css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li>
<li> 正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li>
<li> 不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li>
</ol>
</li>
<li><strong>可维护性、健壮性：</strong><ol>
<li> 将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li>
<li> 样式与内容分离：将css代码定义到外部css中。</li>
</ol>
</li>
</ul>
<h3 id="22-CSS预处理器-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器/后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器/后处理器是什么？为什么要使用它们？</h3><p>参考：<a href="https://juejin.cn/post/7005755782926958605#heading-4%EF%BC%8Chttps://juejin.cn/post/7001860784586227720#heading-8">https://juejin.cn/post/7005755782926958605#heading-4，https://juejin.cn/post/7001860784586227720#heading-8</a></p>
<p><strong>预处理器，</strong> 如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p>
<p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p>
<p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p>
<p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p>
<p>使用原因：</p>
<ul>
<li>  结构清晰， 便于扩展</li>
<li>  可以很方便的屏蔽浏览器私有语法的差异</li>
<li>  可以轻松实现多重继承</li>
<li>  完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li>
</ul>
<h3 id="23-before-和-after-的双冒号和单冒号有什么区别？"><a href="#23-before-和-after-的双冒号和单冒号有什么区别？" class="headerlink" title="23. ::before 和 :after 的双冒号和单冒号有什么区别？"></a>23. ::before 和 :after 的双冒号和单冒号有什么区别？</h3><p>参考：<a href="https://juejin.cn/post/6992961262560739364#heading-7">https://juejin.cn/post/6992961262560739364#heading-7</a></p>
<ol>
<li> 冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素。 </li>
<li> <code>::before</code>就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在于页面之中。</li>
</ol>
<p><strong>注意：</strong> <code>:before </code>和 <code>:after</code> 这两个伪元素，是在<code>CSS2.1</code>里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着<code>Web</code>的进化，在<code>CSS3</code>的规范里，伪元素的语法被修改成使用双冒号，成为<code>::before</code>、<code>::after</code>。</p>
<h3 id="24-display-inline-block-什么时候会显示间隙？"><a href="#24-display-inline-block-什么时候会显示间隙？" class="headerlink" title="24. display:inline-block 什么时候会显示间隙？"></a>24. display:inline-block 什么时候会显示间隙？</h3><p>参考：<a href="https://juejin.cn/post/6979864063257870344">https://juejin.cn/post/6979864063257870344</a></p>
<ul>
<li>  元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据white-space的处理方式（默认是normal，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，空白符占据一定宽度，所以inline-block的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素font-size:16px时，间距为8px。</li>
<li>解决：<ol>
<li> 将html标签要display:inline-block 的元素写在一行。缺点：代码可读性差。</li>
<li> 给父元素设置font-size:0,给子元素设置需要的font-size值。缺点:是子元素如果里面有文字，文字会消失不见，所以又要给子元素设置font-size,增加了代码量。</li>
<li> 给元素设置float:left。缺点:高度塌陷，要清楚浮动。</li>
<li> 设置子元素的margin-left为负值，但是元素之间的间隙大小是根据上下文的字体大小确定的，而每个浏览器的换行空隙大小不同，所以这个方法不通用。</li>
<li> 设置父元素 display:table;word-spacing:-1em;目前这个方法可以完美解决，且兼容其他浏览器。</li>
</ol>
</li>
</ul>
<h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul>
<li><p> 单行文本溢出：</p>
   <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure></li>
<li><p>多行文本溢出：<a href="https://juejin.cn/post/6963904955262435336">https://juejin.cn/post/6963904955262435336</a></p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-line-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure>

<p>  注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p>
</li>
</ul>
<h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p>
<p><strong>为什么要使用它们？</strong></p>
<ul>
<li>  结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</li>
<li>  可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li>
</ul>
<h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p><a href="https://juejin.cn/post/6971013190524076069">https://juejin.cn/post/6971013190524076069</a></p>
<p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。</p>
<p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- link元素中的CSS媒体查询 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 800px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;example.css&quot;</span> /&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 样式表中的CSS媒体查询 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> </span></span><br><span class="line"><span class="css"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123; </span></span><br><span class="line"><span class="css">  <span class="selector-class">.facet_sidebar</span> &#123; </span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: none; </span></span><br><span class="line"><span class="css">  &#125; </span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p>
<h3 id="28-对-CSS-工程化的理解"><a href="#28-对-CSS-工程化的理解" class="headerlink" title="28. 对 CSS 工程化的理解"></a>28. 对 CSS 工程化的理解</h3><p>CSS 工程化是为了解决以下问题：</p>
<ol>
<li> <strong>宏观设计</strong>：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li>
<li> <strong>编码优化</strong>：怎样写出更好的 CSS？</li>
<li> <strong>构建</strong>：如何处理我的 CSS，才能让它的打包结果最优？</li>
<li> <strong>可维护性</strong>：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li>
</ol>
<p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p>
<ul>
<li>  预处理器：Less、 Sass 等；</li>
<li>  重要的工程化插件： PostCss；</li>
<li>  Webpack loader 等 。</li>
</ul>
<p>基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：</p>
<p><strong>（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？</strong></p>
<p>预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码： </p>
<p><img src="/2021/11/27/css/02-28-1.png"></p>
<p>那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：</p>
<ol>
<li> 宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；</li>
<li> 编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；</li>
<li> 可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。</li>
</ol>
<p>这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：</p>
<ul>
<li>  嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；</li>
<li>  支持定义 css 变量；</li>
<li>  提供计算函数；</li>
<li>  允许对代码片段进行 extend 和 mixin；</li>
<li>  支持循环语句的使用；</li>
<li>  支持将 CSS 文件模块化，实现复用。</li>
</ul>
<p><strong>（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</strong></p>
<p><img src="/2021/11/27/css/02-28-2.png" alt="img"> 它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。</p>
<p>PostCss 在业务中的使用场景非常多：</p>
<ul>
<li>  提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li>
<li>  当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 <a href="https://link.juejin.cn/?target=https://github.com/postcss/autoprefixer">Autoprefixer</a> 插件可以帮助我们自动增加浏览器前缀；</li>
<li>  允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li>
</ul>
<p><strong>（3）Webpack 能处理 CSS 吗？如何实现？</strong> Webpack 能处理 CSS 吗：</p>
<ul>
<li>  <strong>Webpack 在裸奔的状态下，是不能处理 CSS 的</strong>，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；</li>
<li>  Webpack 在 loader 的辅助下，是可以处理 CSS 的。</li>
</ul>
<p>如何用 Webpack 实现对 CSS 的处理：</p>
<ul>
<li>  Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</li>
<li>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：<ul>
<li>  css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；</li>
<li>  style-loader：创建style标签，把 CSS 内容写入标签。</li>
</ul>
</li>
</ul>
<p>在实际使用中，<strong>css-loader 的执行顺序一定要安排在 style-loader 的前面</strong>。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</p>
<h3 id="29-如何判断元素是否到达可视区域"><a href="#29-如何判断元素是否到达可视区域" class="headerlink" title="29. 如何判断元素是否到达可视区域"></a>29. 如何判断元素是否到达可视区域</h3><p>以图片显示为例：</p>
<ul>
<li>  <code>window.innerHeight</code> 是浏览器可视区的高度；</li>
<li>  <code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离；</li>
<li>  <code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）；</li>
<li>  内容达到显示区域的：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></li>
</ul>
<p><img src="/2021/11/27/css/02-29.png"></p>
<h3 id="30-z-index属性在什么情况下会失效"><a href="#30-z-index属性在什么情况下会失效" class="headerlink" title="30. z-index属性在什么情况下会失效"></a>30. z-index属性在什么情况下会失效</h3><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p>
<p>z-index属性在下列情况下会失效：</p>
<ul>
<li>  父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li>
<li>  元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li>
<li>  元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li>
</ul>
<h3 id="31-CSS3中的transform有哪些属性"><a href="#31-CSS3中的transform有哪些属性" class="headerlink" title="31. CSS3中的transform有哪些属性"></a>31. CSS3中的transform有哪些属性</h3><p>见14</p>
<h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><ul>
<li><p>绝对单位</p>
<ol>
<li> in（英寸）</li>
<li> cm（厘米）</li>
<li> mm（毫米）</li>
<li> pt（points）</li>
<li> pc（Picas）</li>
</ol>
<p>  1in = 2.54cm = 25.4 mm = 72pt = 6pc</p>
</li>
<li><p>相对单位</p>
<ol>
<li><p>像素（px），是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p>
<ul>
<li>  CSS像素：为web开发者提供，在CSS中使用的一个抽象单位；</li>
<li>  物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的。（绝对单位）</li>
</ul>
<p> px是相对单位，因为1px在不同设备上渲染的物理像素数量不一致，不同设备上一个物理像素的大小也不一致。为保证阅读体验一致，CSS的px 相对 物理像素 是动态的，px和物理像素之间的关系根据设备像素比（DPR）确定。</p>
</li>
<li><p> 百分比（%），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p>
</li>
<li><p>em和rem相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：em相对于父元素，rem相对于根元素。</p>
<ul>
<li>  em： 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li>
<li>  rem： rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。当根元素未设置font-size值时，默认取16px。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li>
</ul>
</li>
<li><p>vw/vh是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p>
<ul>
<li>  vw：相对于视窗的宽度，视窗宽度是100vw；</li>
<li>  vh：相对于视窗的高度，视窗高度是100vh；</li>
<li>  vmin：vw和vh中的较小值；</li>
<li>  vmax：vw和vh中的较大值；</li>
</ul>
</li>
<li><p> ex：表示元素内字符x的高度，一个小写字母，比如“d”，它会有一部分高出来，ex不包括高出来的这一部分的。</p>
</li>
<li><p> ch：表示元素内数字0的宽度</p>
</li>
</ol>
</li>
</ul>
<p>注意：</p>
<ul>
<li>  影响em变化的因素只有font-size，而影响 ex、ch 变化的因素除font-size外还有font-family，因为font-family的改变也会使得x或者0字符的大小发生变化。</li>
<li>vw/vh 和百分比很类似，两者的区别：<ul>
<li>  百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li>
<li>  vw/vm：相对于视窗的尺寸</li>
</ul>
</li>
</ul>
<h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p>
<ul>
<li>  px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li>
<li>  em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li>
<li>  em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>  对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li>
<li>  对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li>
</ul>
<h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>基本样式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>123-边框图片<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: <span class="number">1px</span> dashed <span class="number">#ff6c60</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">    左边固定宽度，高度不固定 <span class="tag">&lt;/<span class="name">br</span>&gt;</span> <span class="tag">&lt;/<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span>高度有可能会很小，也可能很大。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">    这里的内容可能比左侧高，也可能比左侧低。宽度需要自适应。<span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    基本的样式是，两个div相距20px, 左侧div宽 120px</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>双<code>inline-block</code>方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-inline-block</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;	// 消除空格的影响</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-inline-block</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.wrapper-inline-block</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;	// 顶端对齐</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-inline-block</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">140px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这种方法是通过<code>width: calc(100% - 140px)</code>来动态计算右侧盒子的宽度。需要知道右侧盒子距离左边的距离，以及左侧盒子具体的宽度(content+padding+border)，以此计算父容器宽度的<code>100%</code>需要减去的数值。同时，还需要知道右侧盒子的宽度是否包含<code>border</code>的宽度。 在这里，为了简单的计算右侧盒子准确的宽度，设置了子元素的<code>box-sizing:border-box;</code>以及父元素的<code>box-sizing: content-box;</code>。 同时，作为两个<code>inline-block</code>的盒子，必须设置<code>vertical-align</code>来使其顶端对齐。 另外，为了<strong>准确地应用</strong>计算出来的宽度，需要消除<code>div</code>之间的空格，需要通过设置父容器的<code>font-size: 0;</code>,或者用注释消除<code>html</code>中的空格等方法。 <strong>缺点:</strong></p>
<ul>
<li>  需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的<code>box-sizing</code></li>
<li>  需要消除空格字符的影响</li>
<li>  需要设置<code>vertical-align: top</code>满足顶端对齐。</li>
</ul>
</li>
<li><p>双<code>float</code>方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-double-float</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;		// 清除浮动</span><br><span class="line">    <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-double-float</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.wrapper-double-float</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-double-float</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">140px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 本方案和双<code>float</code>方案原理相同，都是通过动态计算宽度来实现自适应。但是，由于浮动的<code>block</code>元素在有空间的情况下会<a href="https://www.w3.org/TR/CSS21/visuren.html#bfc-next-to-float">依次紧贴，排列在一行</a>，所以无需设置<code>display: inline-block;</code>，自然也就少了顶端对齐，空格字符占空间等问题。</p>
<p> 不过由于应用了浮动，父元素需要清除浮动。 <strong>缺点:</strong></p>
<ul>
<li>  需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的<code>box-sizing</code>。</li>
<li>  父元素需要清除浮动。</li>
</ul>
</li>
<li><p><code>float+margin-left</code>方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-float</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;   // 清除浮动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面两种方案都是利用了CSS的<code>calc()</code>函数来计算宽度值。下面两种方案则是利用了<code>block</code>级别的元素盒子的宽度具有<strong>填满父容器，并随着父容器的宽度自适应</strong>的<strong>流动特性</strong>。 但是<code>block</code>级别的元素都是独占一行的，所以要想办法让两个<code>block</code>排列到一起。 我们知道，<code>block</code>级别的元素会认为浮动的元素不存在，但是<code>inline</code>级别的元素能识别到浮动的元素。这样，<code>block</code>级别的元素就可以和浮动的元素同处一行了。 为了让右侧盒子和左侧盒子保持距离，需要为左侧盒子留出足够的距离。这个距离的大小为左侧盒子的宽度以及两个盒子之间的距离之和。然后将该值设置为右侧盒子的<code>margin-left</code>。 <strong>缺点：</strong></p>
<ul>
<li>  需要清除浮动</li>
<li>  需要计算右侧盒子的<code>margin-left</code></li>
</ul>
</li>
<li><p>使用absolute+margin-left方法</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-absolute</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-absolute</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>缺点:</strong></p>
<ul>
<li>  使用了绝对定位，若是用在某个div中，需要更改父容器的<code>position</code>。</li>
<li>  没有清除浮动的方法，若左侧盒子高于右侧盒子，就会超出父容器的高度。因此只能通过设置父容器的<code>min-height</code>来放置这种情况。</li>
</ul>
</li>
<li><p>使用float+BFC方法</p>
<p> 上面的方法都需要通过左侧盒子的宽度，计算某个值，下面三种方法都是不需要计算的。只需要设置两个盒子之间的间隔。</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-float-bfc</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float-bfc</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float-bfc</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个方案同样是利用了左侧浮动，但是右侧盒子通过<code>overflow: auto;</code>形成了BFC，因此右侧盒子不会与浮动的元素重叠。</p>
<p> 这种情况下，只需要为左侧的浮动盒子设置<code>margin-right</code>，就可以实现两个盒子的距离了。而右侧盒子是<code>block</code>级别的，所以宽度能实现自适应。 <strong>缺点:</strong></p>
<ul>
<li>  父元素需要清除浮动</li>
</ul>
</li>
<li><p>flex方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-flex</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-flex</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-flex</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> flex可以说是最好的方案了，代码少，使用简单。有朝一日，大家都改用现代浏览器，就可以使用了。 需要注意的是，flex容器的一个默认属性值:align-items: stretch;。这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start;</p>
</li>
<li><p>grid方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-grid</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">120px</span> <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    grid-column: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    grid-column: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意:</p>
<ul>
<li>  grid布局也有列等高的默认效果。需要设置: align-items: start;。</li>
<li>  grid布局还有一个值得注意的小地方和flex不同:在使用margin-left的时候，grid布局默认是box-sizing设置的盒宽度之间的位置。而flex则是使用两个div的border或者padding外侧之间的距离。</li>
</ul>
</li>
</ol>
<p><strong>极限情况</strong></p>
<p>最后可以再看一下在父容器极限小的情况下，不同方案的表现。主要分成四种情况：</p>
<ul>
<li><p>动态计算宽度的情况</p>
<p>  两种方案: 双inline-block方案和双float方案。宽度极限小时，右侧的div宽度会非常小，由于遵循流动布局，所以右侧div会移动到下一行。</p>
</li>
<li><p>动态计算右侧margin-left的情况</p>
<p>  两种方案: float+margin-left方案和absolute+margin-left方案。宽度极限小时，由于右侧的div忽略了文档流中左侧div的存在，所以其依旧会存在于这一行，并被隐藏。</p>
</li>
<li><p><code>float+BFC</code>方案的情况</p>
<p>  这种情况下，由于BFC与float的特殊关系，右侧div在宽度减小到最小后，也会掉落到下一行。</p>
</li>
<li><p><code>flex</code>和<code>grid</code>的情况</p>
<p>  这种情况下，默认两种布局方式都不会放不下的div移动到下一行。不过 flex布局可以通过 flex-flow: wrap;来设置多余的div移动到下一行。 grid布局暂不支持。</p>
</li>
</ul>
<p>参考：<a href="https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/">https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/</a></p>
<h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><ol>
<li><p>float 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.output</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">min-width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.side</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.side-left</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.side-right</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">          <span class="comment">/* width: calc(100%-600px); */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">600px</span>);</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- calc() 函数用于动态计算长度值。</span></span><br><span class="line"><span class="comment">需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)； --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;output&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;side side-left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;div class=&quot; mid&quot;&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;side side-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>position 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.output</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="comment">/* left: 300px;</span></span></span><br><span class="line"><span class="comment"><span class="css">          width: calc(100% - 600px); */</span></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">          <span class="comment">/* 兼容性最好的写法： */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">right</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;output&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>table 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>:orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>:lightblue;</span></span><br><span class="line"><span class="css">          <span class="comment">/* 继承父类的剩余部分 */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>flex 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orchid;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="comment">/* flex: 1; */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">flex</span>: auto;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>grid 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="css">          grid-template-rows: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          grid-template-<span class="attribute">columns</span>:<span class="number">300px</span> auto <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="comment">/* grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 */</span></span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: lightgoldenrodyellow;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>圣杯布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>144-圣杯布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      *&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">min-width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background</span>: purple;</span></span><br><span class="line"><span class="css">          <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1.什么是圣杯布局和双飞翼布局</span></span><br><span class="line"><span class="comment">两者实现的功能都一样, 都是用于实现两侧的宽度不变, 中间的宽度自适应的三栏布局的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.圣杯布局的步骤</span></span><br><span class="line"><span class="comment">2.1搞一个容器, 里面放三个盒子</span></span><br><span class="line"><span class="comment">2.2设置两侧盒子的宽度(固定)</span></span><br><span class="line"><span class="comment">2.3设置中间盒子的宽度等于容器的宽度(100%)</span></span><br><span class="line"><span class="comment">2.4设置容器的padding等于两侧盒子的宽度</span></span><br><span class="line"><span class="comment">2.5让三个盒子都在同一个方向上浮动</span></span><br><span class="line"><span class="comment">2.6设置左边盒子的margin-left=-100%</span></span><br><span class="line"><span class="comment">2.7通过定位调整左边的盒子, 让左边的盒子不要盖住中间的区域</span></span><br><span class="line"><span class="comment">2.8设置右边盒子的margin-left=-自身的宽度</span></span><br><span class="line"><span class="comment">2.9通过定位调整右边的盒子, 让右边的盒子不要盖住中间的区域</span></span><br><span class="line"><span class="comment">3.0给容器设置一个最小的宽度, 防止缩小后变形</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>双飞翼布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>145-双飞翼布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        *&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span>&gt;<span class="selector-class">.center-in</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: purple;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1.双飞翼布局的实现步骤</span></span><br><span class="line"><span class="comment">1.1搞一个容器, 里面放三个盒子</span></span><br><span class="line"><span class="comment">1.2设置两侧盒子的宽度(固定)</span></span><br><span class="line"><span class="comment">1.3设置中间盒子的宽度等于容器的宽度(100%)</span></span><br><span class="line"><span class="comment">1.4让三个盒子都在同一个方向上浮动</span></span><br><span class="line"><span class="comment">1.5给中间的盒子添加一个子盒子</span></span><br><span class="line"><span class="comment">1.6给子盒子设置margin 0 两侧盒子的宽度</span></span><br><span class="line"><span class="comment">   由于是给子盒子设置margin,所以不会对父盒子排版产生任何影响</span></span><br><span class="line"><span class="comment">1.7设置左边盒子的margin-left=-100%</span></span><br><span class="line"><span class="comment">1.8设置右边盒子的margin-left=-自身的宽度</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center-in&quot;</span>&gt;</span>中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-水平垂直居中的实现"><a href="#5-水平垂直居中的实现" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul>
<li><p>水平居中</p>
<ul>
<li><p>行内元素</p>
<ol>
<li> 给父元素设置 text-align:center,即可实现行内元素水平居中</li>
</ol>
</li>
<li><p>块级元素</p>
<ol>
<li><p> 该元素设置 margin:0 auto即可</p>
</li>
<li><p>若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: -moz-fit-content;</span><br><span class="line">    <span class="attribute">width</span>: -webkit-fit-content;</span><br><span class="line">    <span class="attribute">width</span>:fit-content;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器</p>
</li>
<li><p>使用flex 2012年版本布局, 可以轻松的实现水平居中, 子元素设置如下</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用flex 2009年版本, 父元素display: box;box-pack: center;如下设置:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    -webkit-box-orient: horizontal;</span><br><span class="line">    -webkit-box-pack: center;</span><br><span class="line">    <span class="attribute">display</span>: -moz-box;</span><br><span class="line">    -moz-box-orient: horizontal;</span><br><span class="line">    -moz-box-pack: center;</span><br><span class="line">    <span class="attribute">display</span>: -o-box;</span><br><span class="line">      -o-box-orient: horizontal;</span><br><span class="line">      -o-box-pack: center;</span><br><span class="line">      <span class="attribute">display</span>: -ms-box;</span><br><span class="line">      -ms-box-orient: horizontal;</span><br><span class="line">      -ms-box-pack: center;</span><br><span class="line">      <span class="attribute">display</span>: box;</span><br><span class="line">      box-orient: horizontal;</span><br><span class="line">      box-pack: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用CSS3中新增的transform属性, 子元素设置如下:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">      <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用绝对定位方式, 以及负值的margin-left, 子元素设置如下:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">width</span>:固定;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">0.5</span>宽度;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">width</span>:固定;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>垂直居中</p>
<ul>
<li><p>单行文本</p>
<ol>
<li> 设置 line-height 等于父元素高度</li>
</ol>
</li>
<li><p>行内块级元素</p>
<ol>
<li><p>若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span>, <span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>元素高度不定</p>
<ol>
<li><p>可用 <strong>vertical-align</strong> 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的。 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle;</p>
<ul>
<li>  <strong>优点</strong>：元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断。</li>
<li>  <strong>缺点</strong>：IE6~7, 甚至IE8 beta中无效。</li>
</ul>
</li>
<li><p>可用 <strong>Flex 2012版</strong>, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《<a href="https://link.juejin.cn/?target=http://louiszhai.github.io/2017/01/13/flex/">弹性盒模型Flex指南</a>》</p>
<p> 父元素做如下设置即可保证子元素垂直居中:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>优点</strong></p>
<ul>
<li><p>  内容块的宽高任意, 优雅的溢出.</p>
</li>
<li><p>  可用于更复杂高级的布局技术中.</p>
</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li>  IE8/IE9不支持</li>
<li>  需要浏览器厂商前缀</li>
<li>  渲染上可能会有一些问题</li>
</ul>
</li>
</ul>
</li>
<li><p>使用flex 2009版.</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: box;</span><br><span class="line">      box-orient: vertical;</span><br><span class="line">      box-pack: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>优点</strong>：实现简单, 扩展性强</li>
<li>  <strong>缺点</strong>：兼容性差, 不支持IE</li>
</ul>
</li>
<li><p>可用 <strong>transform</strong> , 设置父元素相对定位(position:relative), 子元素如下css样式：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);  </span><br><span class="line">    -ms-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>优点</strong>：代码量少</li>
<li>  <strong>缺点</strong>：IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象</li>
</ul>
</li>
</ol>
</li>
<li><p>元素高度固定</p>
<ol>
<li><p>设置父元素相对定位(position:relative), 子元素如下css样式:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>:固定;</span><br><span class="line">    <span class="attribute">margin-top</span>:-<span class="number">0.5</span>高度;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>优点</strong>：适用于所有浏览器.</li>
<li>  <strong>缺点</strong>：父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条</li>
</ul>
</li>
<li><p>  设置父元素相对定位(position:relative), 子元素如下css样式:</p>
</li>
</ol>
<pre><code>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">height</span>:固定;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>:auto <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  -   **优点**：简单
  -   **缺点**：没有足够空间时, 子元素会被截断, 但不会有滚动条.
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p>
<ul>
<li>  <strong>适配不同像素密度，</strong> 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li>
<li>  <strong>适配不同屏幕大小，</strong> 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li>
</ul>
<p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p>
<p><a href="https://www.cnblogs.com/zhangnan35/p/12682925.html">https://www.cnblogs.com/zhangnan35/p/12682925.html</a></p>
<h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p>
<p>以下6个属性设置在<strong>容器上</strong>：</p>
<ul>
<li>  flex-direction属性决定主轴的方向（即项目的排列方向）。</li>
<li>  flex-wrap属性定义，如果一条轴线排不下，如何换行。</li>
<li>  flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li>
<li>  justify-content属性定义了项目在主轴上的对齐方式。</li>
<li>  align-items属性定义项目在交叉轴上如何对齐。</li>
<li>  align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>
</ul>
<p>以下6个属性设置在<strong>项目上</strong>：</p>
<ul>
<li>  order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>
<li>  flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>
<li>  flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>  flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li>
<li>  flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li>
<li>  align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
<p><strong>简单来说：</strong> flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p>
<h3 id="8-响应式设计的概念及基本原理"><a href="#8-响应式设计的概念及基本原理" class="headerlink" title="8. 响应式设计的概念及基本原理"></a>8. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p>
<p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。 关于兼容： 页面头部必须有meta声明的<code>viewport</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;’viewport’&quot;</span> <span class="attr">content</span>=<span class="string">&quot;”width=device-width,&quot;</span> <span class="attr">initial-scale</span>=<span class="string">&quot;1.&quot;</span> <span class="attr">maximum-scale</span>=<span class="string">&quot;1,user-scalable=no”&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p>
<p><strong>浮动的工作原理：</strong></p>
<ul>
<li>  浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li>
<li>  浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li>
</ul>
<p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p>
<p><strong>浮动元素引起的问题？</strong></p>
<ul>
<li>  父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>  与浮动元素同级的非浮动元素会跟随其后</li>
<li>  若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li>
</ul>
<p><strong>清除浮动的方式如下：</strong><a href="https://juejin.cn/post/6992534186347216909#heading-3">https://juejin.cn/post/6992534186347216909#heading-3</a></p>
<ul>
<li>  给父级div定义<code>height</code>属性</li>
<li>  最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li>
<li>  包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li>
<li>  使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout，从而使元素获得清除浮动的特性。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">    content: <span class="string">&quot;\200B&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用-clear-属性清除浮动的原理？"><a href="#2-使用-clear-属性清除浮动的原理？" class="headerlink" title="2. 使用 clear 属性清除浮动的原理？"></a>2. 使用 clear 属性清除浮动的原理？</h3><p>使用clear属性清除浮动，其语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clear</span>:none|left|right|both</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p>
<p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p>
<p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p>
<p>一般使用伪元素的方式清除浮动：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;  </span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;  </span><br><span class="line">    <span class="attribute">display</span>: block;   </span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p>
<h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p>
<ul>
<li>  Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。</li>
<li>  Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li>
</ul>
<p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p>
<p><strong>创建BFC的条件：</strong></p>
<ul>
<li>  根元素：body；</li>
<li>  元素设置浮动：float 除 none 以外的值；</li>
<li>  元素设置绝对定位：position (absolute、fixed)；</li>
<li>  display 值为：inline-block、table-cell、table-caption、flex等；</li>
<li>  overflow 值为：hidden、auto、scroll；</li>
</ul>
<p><strong>BFC的特点：</strong></p>
<ul>
<li>  垂直方向上，自上而下排列，和文档流的排列方式一致。</li>
<li>  在BFC中上下相邻的两个容器的margin会重叠</li>
<li>  计算BFC的高度时，需要计算浮动元素的高度</li>
<li>  BFC区域不会与浮动的容器发生重叠</li>
<li>  BFC是独立的容器，容器内部元素不会影响外部元素</li>
<li>  每个元素的左margin值和容器的左border相接触</li>
</ul>
<p><strong>BFC的作用：</strong></p>
<ul>
<li>  <strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li>
<li>  <strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li>
<li>  <strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p>
<h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong> 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p>
<p><strong>计算原则：</strong> 折叠合并后外边距的计算原则如下：</p>
<ul>
<li>  如果两者都是正数，那么就去最大者</li>
<li>  如果是一正一负，就会正值减去负值的绝对值</li>
<li>  两个都是负值时，用0减去两个中绝对值大的那个</li>
</ul>
<p><strong>解决办法：</strong> 对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong> </p>
<ol>
<li>兄弟之间重叠<ul>
<li>  底部元素变为行内盒子：<code>display: inline-block</code></li>
<li>  底部元素设置浮动：<code>float</code></li>
<li>  底部元素的position的值为<code>absolute/fixed</code></li>
</ul>
</li>
<li>父子之间重叠<ul>
<li>  父元素加入：<code>overflow: hidden</code></li>
<li>  父元素添加透明边框：<code>border:1px solid transparent</code></li>
<li>  子元素变为行内盒子：<code>display: inline-block</code></li>
<li>  子元素加入浮动属性或定位</li>
</ul>
</li>
</ol>
<h3 id="5-元素的层叠顺序"><a href="#5-元素的层叠顺序" class="headerlink" title="5. 元素的层叠顺序"></a>5. 元素的层叠顺序</h3><p>参考：<a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/</a></p>
<p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p>
<p><img src="/2021/11/27/css/02-3-5.png" alt="02-3-5"></p>
<p>上图，由上到下分别是： </p>
<ol>
<li> 背景和边框：建立当前层叠上下文元素的背景和边框。 </li>
<li> 负的z-index：当前层叠上下文中，z-index属性值为负的元素。 </li>
<li> 块级盒：文档流内非行内级非定位后代元素。</li>
<li> 浮动盒：非定位浮动元素。 </li>
<li> 行内盒：文档流内行内级非定位后代元素。 </li>
<li> z-index:0：层叠级数为0的定位元素。 </li>
<li> 正z-index：z-index属性值为正的定位元素。</li>
</ol>
<p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p>
<h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><table>
<thead>
<tr>
<th>属性值</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>absolute</td>
<td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td>
</tr>
<tr>
<td>fixed</td>
<td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td>
</tr>
<tr>
<td>static</td>
<td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定从父元素继承position属性的值</td>
</tr>
<tr>
<td>sticky</td>
<td>元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。<br />该值总是创建一个新的<a href="https://developer.mozilla.org/en/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context">层叠上下文（stacking context</a>）。注意，一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的<code>overflow</code> 是 <code>hidden</code>, <code>scroll</code>, <code>auto</code>, 或 <code>overlay</code>时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为</td>
</tr>
</tbody></table>
<p>前面三者的定位方式如下：</p>
<ul>
<li><p>  <strong>relative：</strong> 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</p>
</li>
<li><p>  <strong>fixed：</strong> 元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</p>
</li>
<li><p>  <strong>absolute：</strong> 元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。</p>
</li>
</ul>
<h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. display、float、position的关系</h3><ol>
<li> 首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</li>
<li> 然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</li>
<li> 如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</li>
<li> 如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</li>
</ol>
<p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p>
<h3 id="8-absolute与fixed共同点与不同点"><a href="#8-absolute与fixed共同点与不同点" class="headerlink" title="8. absolute与fixed共同点与不同点"></a>8. absolute与fixed共同点与不同点</h3><p><strong>共同点：</strong></p>
<ul>
<li>  改变行内元素的呈现方式，将display置为inline-block </li>
<li>  使元素脱离普通文档流，不再占据文档物理空间</li>
<li>  覆盖非定位文档元素</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>  abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</li>
<li>  在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</li>
</ul>
<h3 id="9-对-sticky-定位的理解"><a href="#9-对-sticky-定位的理解" class="headerlink" title="9. 对 sticky 定位的理解"></a>9. 对 sticky 定位的理解</h3><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：<strong>position: sticky;</strong> 基于用户的滚动位置来定位。</p>
<p>粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>
<p><strong>参考</strong>：<a href="https://juejin.cn/post/6844903973627887624#comment">https://juejin.cn/post/6844903973627887624#comment</a></p>
<p><strong>基本概念</strong></p>
<ul>
<li><p>流盒</p>
<p>  指的是粘性定位元素最近的<code>可滚动元素</code>（overflow属性值不是visible的元素）的尺寸盒子，如果没有可滚动元素，则表示浏览器视窗盒子。</p>
</li>
<li><p>粘性约束矩形</p>
<p>  即粘性布局元素的父级元素矩形</p>
</li>
</ul>
<p><strong>特性</strong></p>
<ul>
<li>  当粘性约束矩形在可视范围内为<code>relative</code>，反之，则为<code>fixed</code></li>
<li>  粘性定位元素如果和它的父元素一样高，则垂直滚动的时候，粘性定位效果是不会出现的</li>
<li>  它的定位效果完全受限于父级元素们。如果父元素的<code>overflow</code>属性设置了<code>scroll</code>，<code>auto</code>,<code>overlay</code>值，那么，粘性定位将会失效</li>
<li>  同一容器中多个粘贴定位元素独立偏移，因此可能重叠；位置上下靠在一起的不同容器中的粘贴定位元素则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li>
</ul>
<h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><ol>
<li><p>border：平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是由三角形组成的，将其它边的边框设置成透明即可</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid green;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>clip-path剪裁</p>
<p> <code>clip-path</code>属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</p>
<p> <code>clip-path</code>的语法有四种：</p>
<ul>
<li>  inset（定义矩形）</li>
<li>  circle（定义圆）</li>
<li>  ellipse（定义椭圆）</li>
<li>  polygon（定义多边形）</li>
</ul>
<p> polygon的值为多个坐标点组成，坐标第一个值是x方向，第二个值是y方向。左上角是原点，右下角是(100%,100%)的点</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: cyan;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">100%</span>, <span class="number">50%</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">100%</span>);    // 对应三角形三个顶点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    heigt: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-top-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现一个宽高自适应的正方形"><a href="#3-实现一个宽高自适应的正方形" class="headerlink" title="3. 实现一个宽高自适应的正方形"></a>3. 实现一个宽高自适应的正方形</h3><ol>
<li><p>利用vw来实现：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用元素的margin/padding百分比是相对父元素width的性质来实现：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用子元素的margin-top的值来实现：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-画一条0-5px的线"><a href="#4-画一条0-5px的线" class="headerlink" title="4. 画一条0.5px的线"></a>4. 画一条0.5px的线</h3><ul>
<li><p>  <strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：<code>transform: scale(0.5,0.5);</code></p>
</li>
<li><p>  <strong>采用meta viewport的方式</strong>，<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;/&gt;</code>，这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p>
</li>
</ul>
<h3 id="5-设置小于12px的字体"><a href="#5-设置小于12px的字体" class="headerlink" title="5. 设置小于12px的字体"></a>5. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>  使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li>
<li>  使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</li>
<li>  使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li>
</ul>
<h3 id="6-如何解决-1px-问题？"><a href="#6-如何解决-1px-问题？" class="headerlink" title="6. 如何解决 1px 问题？"></a>6. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">window.devicePixelRatio = 设备的物理像素 / CSS像素。</span><br></pre></td></tr></table></figure>

<p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2。 这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 </p>
<p><strong>解决1px 问题的三种思路：</strong></p>
<p><strong>思路一</strong>：直接写 0.5px</p>
<p>如果之前 1px 的样式这样写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span></span><br></pre></td></tr></table></figure>

<p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="built_in">window</span>.devicePixelRatio&#125;&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">0.5px</span> solid <span class="number">#333</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p>
<p><strong>思路二</strong>：伪元素先放大后缩小</p>
<p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p>
<p>思路是<strong>先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。</strong></p>
<p>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">      <span class="attribute">position</span>:absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">      <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">      <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路三</strong>：viewport 缩放来解决</p>
<p>这个思路就是对 meta 标签里几个关键属性下手：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span></span><br><span class="line">metaEl.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">`width=device-width,user-scalable=no,initial-scale=<span class="subst">$&#123;scale&#125;</span>,maximum-scale=<span class="subst">$&#123;scale&#125;</span>,minimum-scale=<span class="subst">$&#123;scale&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>
<h3 id="7-纯CSS实现圆角三角形"><a href="#7-纯CSS实现圆角三角形" class="headerlink" title="7. 纯CSS实现圆角三角形"></a>7. 纯CSS实现圆角三角形</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.rounded-triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">30%</span>;    // 圆角弧度</span><br><span class="line">    <span class="attribute">background</span>: cyan;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">60</span>edg) <span class="built_in">skewX</span>(-<span class="number">30</span>edg) <span class="built_in">scale</span>(<span class="number">1</span>, .<span class="number">866</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.rounded-triangle</span>:before,</span><br><span class="line">    .rounded-triangle:after &#123;</span><br><span class="line">      content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">background-color</span>: inherit;</span><br><span class="line">      <span class="attribute">width</span>:  <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">border-top-right-radius</span>: <span class="number">30%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.rounded-triangle</span>:before &#123;</span><br><span class="line">      transform: <span class="built_in">rotate</span>(-<span class="number">135deg</span>) <span class="built_in">skewX</span>(-<span class="number">45deg</span>) <span class="built_in">scale</span>(<span class="number">1.414</span>, .<span class="number">707</span>) <span class="built_in">translate</span>(<span class="number">0</span>,-<span class="number">50%</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.rounded-triangle</span>:after &#123;</span><br><span class="line">      transform: <span class="built_in">rotate</span>(<span class="number">135deg</span>) <span class="built_in">skewY</span>(-<span class="number">45deg</span>) <span class="built_in">scale</span>(.<span class="number">707</span>, <span class="number">1.414</span>) <span class="built_in">translate</span>(<span class="number">50%</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h3>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue面试题</title>
    <url>/2021/12/17/vue/</url>
    <content><![CDATA[<p>绝大部分内容来自：<a href="https://juejin.cn/user/3544481220801815">https://juejin.cn/user/3544481220801815</a></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/../../../Desktop/%E9%9D%A2%E8%AF%95/pic/04.Vue%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<h2 id="一、Vue-基础"><a href="#一、Vue-基础" class="headerlink" title="一、Vue 基础"></a>一、Vue 基础</h2><h3 id="1-Vue的基本原理"><a href="#1-Vue的基本原理" class="headerlink" title="1. Vue的基本原理"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p>
<p><img src="/../../../Desktop/%E9%9D%A2%E8%AF%95/pic/04/04-1-1.png"></p>
<h3 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2. 双向数据绑定的原理"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p>
<ol>
<li> 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>
<li> compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li> Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>
<li> MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>
<li> 如果是数组需要单独处理，重写所有能修改数组的方法，并覆盖掉数组原型上的对应方法。</li>
<li> 注意：defineProperty 只能监测到 getter/setter 操作，对于对象的增加删除属性操作监听不到（可以用 vm.$set$，vm.$delete$ 解决），对于数组直接用下标获取元素的方式（可以用 vm.$set$ 和 splice），和直接修改数组的 length 也无法监听（可以用 splice ）</li>
</ol>
<p><img src="/../../../Desktop/%E9%9D%A2%E8%AF%95/pic/04/04-1-2.png"></p>
<h3 id="3-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>defineProperty 只能监测到 getter/setter 操作，对于对象的增加删除属性操作监听不到（可以用 vm.$set$，vm.$delete$ 解决），对于数组直接用下标获取元素的方式（可以用 vm.$set$ 和 splice），和直接修改数组的 length 也无法监听（可以用 splice ）。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p>
<p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法，而且无法用 polyfill 实现。</p>
<h3 id="4-MVVM、MVC、MVP的区别"><a href="#4-MVVM、MVC、MVP的区别" class="headerlink" title="4. MVVM、MVC、MVP的区别"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p>
<p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p>
<ol>
<li><p>MVC</p>
<p> MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p>
<p> <img src="/../../../Desktop/%E9%9D%A2%E8%AF%95/pic/04/04-1-4-1.png"></p>
</li>
<li><p>MVVM</p>
<p> MVVM 分为 Model、View、ViewModel：</p>
<ul>
<li>  Model代表数据模型，数据和业务逻辑都在Model层中定义；</li>
<li>  View代表UI视图，负责数据的展示；</li>
<li>  ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li>
</ul>
<p> Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p>
<p> 这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。</p>
<p> <img src="/../../../Desktop/%E9%9D%A2%E8%AF%95/pic/04/04-1-4-2.png"></p>
</li>
<li><p>MVP</p>
<p> MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p>
<p> <img src="/../../../Desktop/%E9%9D%A2%E8%AF%95/pic/04/04-1-4-3.png"></p>
</li>
</ol>
<h3 id="5-Computed-和-Watch-的区别"><a href="#5-Computed-和-Watch-的区别" class="headerlink" title="5. Computed 和 Watch 的区别"></a>5. Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p>
<ul>
<li>  它支持缓存，只有依赖的数据发生了变化，才会重新计算,<strong>计算属性是基于它们的响应式依赖进行缓存的</strong></li>
<li>  不支持异步，当Computed中有异步操作时，无法监听数据的变化</li>
<li>  computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li>
<li>  如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li>
<li>  如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li>
</ul>
<p><strong>对于Watch：</strong></p>
<ul>
<li>  它不支持缓存，数据变化时，它就会触发相应的操作</li>
<li>  支持异步监听</li>
<li>  监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li>
<li>  当一个属性发生变化时，就需要执行相应的操作</li>
<li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<ul>
<li>  immediate：组件加载立即触发回调函数</li>
<li>  deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li>
</ul>
</li>
</ul>
<p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p>
<p><strong>总结：</strong></p>
<ul>
<li>  computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li>
<li>  watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li>
</ul>
<p><strong>运用场景：</strong></p>
<ul>
<li>  当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li>
<li>  当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h3 id="6-Computed-和-Methods-的区别"><a href="#6-Computed-和-Methods-的区别" class="headerlink" title="6. Computed 和 Methods 的区别"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的</p>
<p><strong>不同点：</strong></p>
<ul>
<li>  computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li>
<li>  method 调用总会执行该函数。</li>
</ul>
<h3 id="7-slot是什么？有什么作用？原理是什么？"><a href="#7-slot是什么？有什么作用？原理是什么？" class="headerlink" title="7. slot是什么？有什么作用？原理是什么？"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p>
<ul>
<li>  默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li>
<li>  具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽，默认是 default</li>
<li>  作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li>
</ul>
<p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p>
<h3 id="8-过滤器的作用，如何实现一个过滤器"><a href="#8-过滤器的作用，如何实现一个过滤器" class="headerlink" title="8. 过滤器的作用，如何实现一个过滤器"></a>8. 过滤器的作用，如何实现一个过滤器</h3><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>  需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</li>
<li>  比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用<code>fliters</code>过滤器来处理数据。</li>
</ul>
<p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在**插值表达式 **<code>&#123;&#123; &#125;&#125;</code> 和 <code>v-bind</code> <strong>表达式</strong> 中，然后放在操作符“ <code>|</code> ”后面进行指示。</p>
<p>例如，在显示金额，给商品价格添加单位：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;商品价格：&#123;&#123;item.price | filterPrice&#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line"> filters: &#123;</span><br><span class="line">    filterPrice (price) &#123;</span><br><span class="line">      <span class="keyword">return</span> price ? (<span class="string">&#x27;￥&#x27;</span> + price) : <span class="string">&#x27;--&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-如何保存页面的当前的状态"><a href="#9-如何保存页面的当前的状态" class="headerlink" title="9. 如何保存页面的当前的状态"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p>
<ul>
<li>  前组件会被卸载</li>
<li>  前组件不会被卸载</li>
</ul>
<p>那么可以按照这两种情况分别得到以下方法：</p>
<ul>
<li><p><strong>组件会被卸载：</strong></p>
<ol>
<li><p><strong>将状态存储在LocalStorage / SessionStorage</strong></p>
<p> 只需要在组件即将被销毁的生命周期 <code>componentWillUnmount</code> （react）中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p>
<p> 比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p>
<p> <strong>优点：</strong></p>
<ul>
<li>  兼容性好，不需要额外库或工具。</li>
<li>  简单快捷，基本可以满足大部分需求。</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li>  状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li>
<li>  如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li>
</ul>
</li>
<li><p><strong>路由传值</strong></p>
<p> 通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p>
<p> 在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p>
<p> <strong>优点：</strong></p>
<ul>
<li>  简单快捷，不会污染 LocalStorage / SessionStorage。</li>
<li>  可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li>  如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>组件不会被卸载：</strong></p>
<ol>
<li><p><strong>单页面渲染</strong></p>
<p> 要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p>
<p> <strong>优点：</strong></p>
<ul>
<li>  代码量少</li>
<li>  不需要考虑状态传递过程中的错误</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li>  增加 A 组件维护成本</li>
<li>  需要传入额外的 prop 到 B 组件</li>
<li>  无法利用路由定位页面</li>
</ul>
<p> 除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/kepp-alive&gt;</span><br></pre></td></tr></table></figure>

<p> <strong>router.js</strong></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../src/views/xxx.vue&#x27;</span>),</span><br><span class="line">  <span class="attr">meta</span>:&#123;</span><br><span class="line">    <span class="attr">keepAlive</span>: <span class="literal">true</span> <span class="comment">// 需要被缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10. 常见的事件修饰符及其作用"></a>10. 常见的事件修饰符及其作用</h3><ul>
<li>  <code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li>
<li>  <code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li>
<li>  <code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li>
<li>  <code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li>
<li>  <code>.once</code> ：只会触发一次。</li>
</ul>
<h3 id="11-v-if、v-show、v-html-的原理"><a href="#11-v-if、v-show、v-html-的原理" class="headerlink" title="11. v-if、v-show、v-html 的原理"></a>11. v-if、v-show、v-html 的原理</h3><ul>
<li>  v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li>
<li>  v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li>
<li>  v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li>
</ul>
<h3 id="12-v-if-和-v-show-的区别"><a href="#12-v-if-和-v-show-的区别" class="headerlink" title="12. v-if 和 v-show 的区别"></a>12. v-if 和 v-show 的区别</h3><ul>
<li>  <strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li>
<li>  <strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li>
<li>  <strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li>
<li>  <strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>
<li>  <strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li>
</ul>
<h3 id="13-v-model-是如何实现的，语法糖实际是什么？"><a href="#13-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="13. v-model 是如何实现的，语法糖实际是什么？"></a>13. v-model 是如何实现的，语法糖实际是什么？</h3><ol>
<li><p><strong>作用在表单元素上</strong> 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-on:input</span>=<span class="string">&quot;message=$event.target.value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">&gt;</span></span></span><br><span class="line"><span class="xml">//$event 指代当前触发的事件对象;</span></span><br><span class="line"><span class="xml">//$event.target 指代当前触发的事件对象的dom;</span></span><br><span class="line"><span class="xml">//$event.target.value 就是当前dom的value值;</span></span><br><span class="line"><span class="xml">//在@input方法中，value =&gt; sth;</span></span><br><span class="line"><span class="xml">//在:value中,sth =&gt; value;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>作用在组件上</strong> 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p>
<p> <strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong> 因此父组件 v-model 语法糖本质上可以修改为：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;child :value=<span class="string">&quot;message&quot;</span>  @input=<span class="string">&quot;function(e)&#123;message = e&#125;&quot;</span>&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>

<p> 在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;aa-input v-model=<span class="string">&quot;aa&quot;</span>&gt;&lt;/aa-input&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">aa-input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;aa=$event.target.value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;onmessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">props:&#123;<span class="attr">value</span>:aa,&#125;</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">onmessage</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        $emit(<span class="string">&#x27;input&#x27;</span>,e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input <code>$emit</code>过来的值。</p>
</li>
</ol>
<h3 id="14-v-model-可以被用在自定义组件上吗？如果可以，如何使用？"><a href="#14-v-model-可以被用在自定义组件上吗？如果可以，如何使用？" class="headerlink" title="14. v-model 可以被用在自定义组件上吗？如果可以，如何使用？"></a>14. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3><p>可以。v-model 实际上是一个语法糖，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;searchText&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>实际上相当于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-bind:value=<span class="string">&quot;searchText&quot;</span></span><br><span class="line">  v-on:input=<span class="string">&quot;searchText = $event.target.value&quot;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>用在自定义组件上也是同理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;custom-input v-model=<span class="string">&quot;searchText&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=<span class="string">&quot;searchText&quot;</span></span><br><span class="line">  v-on:input=<span class="string">&quot;searchText = $event&quot;</span></span><br><span class="line">&gt;&lt;/custom-input&gt;</span><br></pre></td></tr></table></figure>

<p>显然，custom-input 与父组件的交互如下：</p>
<ol>
<li> 父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；</li>
<li> custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；</li>
</ol>
<p>所以，custom-input 组件的实现应该类似于这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;custom-input&#x27;</span>, &#123;  <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],  <span class="attr">template</span>: <span class="string">`    &lt;input      v-bind:value=&quot;value&quot;      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;    &gt;  `</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="15-data-为什么是一个函数而不是对象"><a href="#15-data-为什么是一个函数而不是对象" class="headerlink" title="15. data 为什么是一个函数而不是对象"></a>15. data 为什么是一个函数而不是对象</h3><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p>
<p>而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p>
<p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p>
<h3 id="16-对-keep-alive-的理解，它是如何实现的，具体缓存的是什么？"><a href="#16-对-keep-alive-的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="16. 对 keep-alive 的理解，它是如何实现的，具体缓存的是什么？"></a>16. 对 keep-alive 的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p>
<ol>
<li><p><strong>keep-alive</strong></p>
<p> keep-alive有以下三个属性：</p>
<ul>
<li>  include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li>
<li>  exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li>
<li>  max 数字，最多可以缓存多少组件实例。</li>
</ul>
<p> 注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p>
<p> <strong>主要流程</strong></p>
<ol>
<li> 判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li>
<li> 获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li>
<li> key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li>
<li> 如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li>
</ol>
</li>
<li><p><strong>keep-alive 的实现</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patternTypes: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt; = [<span class="built_in">String</span>, <span class="built_in">RegExp</span>, <span class="built_in">Array</span>] <span class="comment">// 接收：字符串，正则，数组export default &#123;  name: &#x27;keep-alive&#x27;,  abstract: true, // 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。  props: &#123;    include: patternTypes, // 匹配的组件，缓存    exclude: patternTypes, // 不去匹配的组件，不缓存    max: [String, Number], // 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限  &#125;,  created() &#123;    // 用于初始化缓存虚拟DOM数组和vnode的key    this.cache = Object.create(null)    this.keys = []  &#125;,  destroyed() &#123;    // 销毁缓存cache的组件实例    for (const key in this.cache) &#123;      pruneCacheEntry(this.cache, key, this.keys)    &#125;  &#125;,  mounted() &#123;    // prune 削减精简[v.]    // 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容    this.$watch(&#x27;include&#x27;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; matches(val, name))    &#125;)    this.$watch(&#x27;exclude&#x27;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; !matches(val, name))    &#125;)  &#125;,&#125;</span></span><br></pre></td></tr></table></figure>

<p> <strong>render函数：</strong></p>
<ol>
<li> 会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li>
<li> keep-alive 只对第一个组件有效，所以获取第一个子组件。</li>
<li> 和 keep-alive 搭配使用的一般有：动态组件 和router-view</li>
</ol>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render () &#123;  <span class="comment">//  function getFirstComponentChild (children: ?Array&lt;VNode&gt;): ?VNode &#123;    if (Array.isArray(children)) &#123;  for (let i = 0; i &lt; children.length; i++) &#123;    const c = children[i]    if (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) &#123;      return c    &#125;  &#125;  &#125;  &#125;  const slot = this.$slots.default // 获取默认插槽  const vnode: VNode = getFirstComponentChild(slot)// 获取第一个子组件  const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions // 组件参数  if (componentOptions) &#123; // 是否有组件参数    // check pattern    const name: ?string = getComponentName(componentOptions) // 获取组件名    const &#123; include, exclude &#125; = this    if (      // not included      (include &amp;&amp; (!name || !matches(include, name))) ||      // excluded      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))    ) &#123;      // 如果不匹配当前组件的名字和include以及exclude      // 那么直接返回组件的实例      return vnode    &#125;    const &#123; cache, keys &#125; = this    // 获取这个组件的key    const key: ?string = vnode.key == null      // same constructor may get registered as different local components      // so cid alone is not enough (#3269)      ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;)      : vnode.key    if (cache[key]) &#123;      // LRU缓存策略执行      vnode.componentInstance = cache[key].componentInstance // 组件初次渲染的时候componentInstance为undefined      // make current key freshest      remove(keys, key)      keys.push(key)      // 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面    &#125; else &#123;      // 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除      // 使用时间间隔最长的一个      cache[key] = vnode      keys.push(key)      // prune oldest entry      if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;        pruneCacheEntry(cache, keys[0], keys, this._vnode)      &#125;    &#125;    // 将组件的keepAlive属性设置为true    vnode.data.keepAlive = true // 作用：判断是否要执行组件的created、mounted生命周期函数  &#125;  return vnode || (slot &amp;&amp; slot[0])&#125;</span></span><br></pre></td></tr></table></figure>

<p> keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p>
<p> <strong>实现步骤：</strong></p>
<ol>
<li> 获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li>
<li> 通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li>
<li>需要缓存，判断他当前是否在缓存数组里面：<ul>
<li>  存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li>
<li>  不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li>
</ul>
</li>
<li> 最后将这个组件的 keepAlive 设置为 true</li>
</ol>
</li>
<li><p><strong>keep-alive 本身的创建过程和 patch 过程</strong></p>
<p> 缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p>
<p> <strong>首次渲染</strong></p>
<ul>
<li>  组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/instance/lifecyclefunction initLifecycle (vm: Component) &#123;  const options = vm.$options  // locate first non-abstract parent  let parent = options.parent  if (parent &amp;&amp; !options.abstract) &#123; // 判断组件的abstract属性，才往父组件里面挂载DOM    while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;      parent = parent.$parent    &#125;    parent.$children.push(vm)  &#125;  vm.$parent = parent  vm.$root = parent ? parent.$root : vm  vm.$children = []  vm.$refs = &#123;&#125;  vm._watcher = null  vm._inactive = null  vm._directInactive = false  vm._isMounted = false  vm._isDestroyed = false  vm._isBeingDestroyed = false&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/vdom/create-componentinit (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123;    if (      vnode.componentInstance &amp;&amp;      !vnode.componentInstance._isDestroyed &amp;&amp;      vnode.data.keepAlive    ) &#123; // componentInstance在初次是undefined!!!      // kept-alive components, treat as a patch      const mountedNode: any = vnode // work around flow      componentVNodeHooks.prepatch(mountedNode, mountedNode) // prepatch函数执行的是组件更新的过程    &#125; else &#123;      const child = vnode.componentInstance = createComponentInstanceForVnode(        vnode,        activeInstance      )      child.$mount(hydrating ? vnode.elm : undefined, hydrating)    &#125;  &#125;,</span></span><br></pre></td></tr></table></figure>

<p> prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p>
</li>
<li><p><strong>LRU （least recently used）缓存策略</strong></p>
<p> LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 **”如果数据最近被访问过，那么将来被访问的几率也更高”**。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶</p>
<ul>
<li>  新数据插入到链表头部</li>
<li>  每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>
<li>  链表满的时候，将链表尾部的数据丢弃。</li>
</ul>
</li>
</ol>
<h3 id="17-nextTick-原理及作用"><a href="#17-nextTick-原理及作用" class="headerlink" title="17. $nextTick 原理及作用"></a>17. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p>
<p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p>
<p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p>
<p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p>
<ul>
<li>  如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</li>
<li>  同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li>
</ul>
<p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p>
<p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;    <span class="comment">// 获取数据的操作...&#125;)</span></span><br></pre></td></tr></table></figure>

<p>所以，在以下情况下，会用到nextTick：</p>
<ul>
<li>  在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li>
<li>  在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li>
</ul>
<p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p>
<h3 id="18-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#18-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="18. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a>18. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in obj&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;value&quot;</span>&gt;</span> &#123;&#123;value&#125;&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addObjB&quot;</span>&gt;</span>添加 obj.b<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">       data () &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">return</span> &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">obj</span>: &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">                  <span class="attr">a</span>: <span class="string">&#x27;obj.a&#x27;</span> </span></span></span><br><span class="line"><span class="javascript"><span class="xml">              &#125; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">       &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       <span class="attr">methods</span>: &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">          addObjB () &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="built_in">this</span>.obj.b = <span class="string">&#x27;obj.b&#x27;</span> </span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.obj) </span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addObjB () (</span><br><span class="line">   <span class="built_in">this</span>.$set(<span class="built_in">this</span>.obj, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;obj.b&#x27;</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p>
<h3 id="19-Vue-中封装的数组方法有哪些，其如何实现页面更新"><a href="#19-Vue-中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="19. Vue 中封装的数组方法有哪些，其如何实现页面更新"></a>19. Vue 中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。 </p>
<p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>
<ul>
<li>  push()</li>
<li>  pop()</li>
<li>  shift()</li>
<li>  unshift()</li>
<li>  splice()</li>
<li>  sort()</li>
<li>  reverse() </li>
</ul>
<p>那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存数组原型const arrayProto = Array.prototype;// 实现 arrayMethods.__proto__ === Array.prototypeexport const arrayMethods = Object.create(arrayProto);// 需要进行功能拓展的方法const methodsToPatch = [  &quot;push&quot;,  &quot;pop&quot;,  &quot;shift&quot;,  &quot;unshift&quot;,  &quot;splice&quot;,  &quot;sort&quot;,  &quot;reverse&quot;];/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function(method) &#123;  // 缓存原生数组方法  const original = arrayProto[method];  def(arrayMethods, method, function mutator(...args) &#123;    // 执行并缓存原生数组功能    const result = original.apply(this, args);    // 响应式处理    const ob = this.__ob__;    let inserted;    switch (method) &#123;    // push、unshift会新增索引，所以要手动observer      case &quot;push&quot;:      case &quot;unshift&quot;:        inserted = args;        break;      // splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。      case &quot;splice&quot;:        inserted = args.slice(2);        break;    &#125;    //     if (inserted) ob.observeArray(inserted);// 获取插入的值，并设置响应式监听    // notify change    ob.dep.notify();// 通知依赖更新    // 返回原生数组方法的执行结果    return result;  &#125;);&#125;);</span></span><br></pre></td></tr></table></figure>

<p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p>
<h3 id="20-Vue-单页应用与多页应用的区别"><a href="#20-Vue-单页应用与多页应用的区别" class="headerlink" title="20. Vue 单页应用与多页应用的区别"></a>20. Vue 单页应用与多页应用的区别</h3><p><strong>概念：</strong></p>
<ul>
<li>  SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li>
<li>  MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li>
</ul>
<p><strong>区别：</strong></p>
<table>
<thead>
<tr>
<th>对比项/模式</th>
<th>SPA</th>
<th>MPA</th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>一个主页面 + 许多模块的组件</td>
<td>许多完整的页面</td>
</tr>
<tr>
<td>体验</td>
<td>页面切换是，体验佳；当初次加载文件过多时，需要做相关的调优</td>
<td>页面切换慢，网速慢的时候，体验尤其不好</td>
</tr>
<tr>
<td>资源文件</td>
<td>组件公用的资源只需要加载一次</td>
<td>每个页面都要自己加载公用的的资源</td>
</tr>
<tr>
<td>适用场景</td>
<td>对体验度和流畅度有较高要求的应用，不利于 SEO，（可借助 SSR 优化 SEO）</td>
<td>适用于对 SEO 要求较高的应用</td>
</tr>
<tr>
<td>过渡动画</td>
<td>Vue 提供了 transition 的封装组件，容易实现</td>
<td>很难实现</td>
</tr>
<tr>
<td>内容更新</td>
<td>相关组件的切换，即局部更新</td>
<td>整体 HTML 的切换，费钱（重复的 http 请求）</td>
</tr>
<tr>
<td>路由模式</td>
<td>可以使用 hash ，也可以使用 history</td>
<td>普通链接跳转</td>
</tr>
<tr>
<td>数据传递</td>
<td>因为单页面，使用全局变量就好（Vuex）</td>
<td>cookie，localStorage 等缓存方案，URL 参数，调用接口保存的等</td>
</tr>
<tr>
<td>相关成本</td>
<td>前期开发成本较高，后期维护较为容易</td>
<td>前期开发成本低，后期维护就比较麻烦，因为可能一个功能需要该很多地方</td>
</tr>
</tbody></table>
<h3 id="21-Vue-template-到-render-的过程"><a href="#21-Vue-template-到-render-的过程" class="headerlink" title="21. Vue template 到 render 的过程"></a>21. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p>
<p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将模板编译为render函数const &#123; render, staticRenderFns &#125; = compileToFunctions(template,options//省略&#125;, this)</span></span><br></pre></td></tr></table></figure>

<p>CompileToFunctions中的主要逻辑如下∶</p>
<ol>
<li><p><strong>调用parse方法将template转化为ast（抽象语法树）</strong></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">constast = parse(template.trim(), options)</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li>
<li>  <strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li>
</ul>
<p>  AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p>
</li>
<li><p><strong>对静态节点做优化</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimize(ast,options)</span><br></pre></td></tr></table></figure>

<p> 这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p>
<p> 深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p>
</li>
<li><p><strong>生成代码</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> code = generate(ast, options)</span><br></pre></td></tr></table></figure>

<p> generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(render)</code> 生成render函数。</p>
</li>
</ol>
<h3 id="22-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#22-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="22. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>22. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p>
<h3 id="23-简述-mixin、extends-的覆盖逻辑"><a href="#23-简述-mixin、extends-的覆盖逻辑" class="headerlink" title="23. 简述 mixin、extends 的覆盖逻辑"></a>23. 简述 mixin、extends 的覆盖逻辑</h3><ol>
<li><p><strong>mixin 和 extends</strong> mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p>
<ul>
<li>  mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li>
<li>  extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li>
</ul>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>合并策略</th>
<th>对应合并函数</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>mixins/extends 只会将自己有的但是组件上没有的内容混合到组件上，重复定义默认使用组件上的<br />如果 data 里的值是对象，将递归内部对象继续按照该策略合并</td>
<td>mergeDataOrFn，mergeData</td>
</tr>
<tr>
<td>provide</td>
<td>同上</td>
<td>mergeDataOrFn，mergeData</td>
</tr>
<tr>
<td>props</td>
<td>mixins/extends 只会将自己有的但是组件上没有的内容混合到组件上</td>
<td>extend</td>
</tr>
<tr>
<td>methods</td>
<td>同上</td>
<td>extend</td>
</tr>
<tr>
<td>inject</td>
<td>同上</td>
<td>extend</td>
</tr>
<tr>
<td>computed</td>
<td>同上</td>
<td>extend</td>
</tr>
<tr>
<td>组件，过滤求，指令属性</td>
<td>同上</td>
<td>extend</td>
</tr>
<tr>
<td>el</td>
<td>同上</td>
<td>defaultStrat</td>
</tr>
<tr>
<td>propsData</td>
<td>同上</td>
<td>defaultStrat</td>
</tr>
<tr>
<td>watch</td>
<td>合并 watch 监控的回调方法<br />执行顺序是先 mixins/extends 里 watch 定义的回调，然后是组件的回调</td>
<td>strats.watch</td>
</tr>
<tr>
<td>hooks 生命周期钩子</td>
<td>同一种钩子的回调函数会被合并成数组<br />执行顺序是先 mixins/extends 里定义的钩子函数，然后蚕食组件里定义的</td>
<td>mergeHook</td>
</tr>
</tbody></table>
</li>
<li><p><strong>mergeOptions 的执行过程</strong></p>
<ul>
<li><p>  规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</p>
</li>
<li><p>对未合并的选项，进行判断</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!child._base) &#123;  <span class="keyword">if</span> (child.extends) &#123;    parent = mergeOptions(parent, child.extends, vm)  &#125;  <span class="keyword">if</span> (child.mixins) &#123;    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;      parent = mergeOptions(parent, child.mixins[i], vm)    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>  合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</p>
</li>
<li><p>  返回合并结果 options。</p>
</li>
</ul>
</li>
</ol>
<h3 id="24-描述下Vue自定义指令"><a href="#24-描述下Vue自定义指令" class="headerlink" title="24. 描述下Vue自定义指令"></a>24. 描述下Vue自定义指令</h3><p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;</p>
<ol>
<li><p><strong>自定义指令基本内容</strong></p>
<ul>
<li><p>  全局定义：<code>Vue.directive(&quot;focus&quot;,&#123;&#125;)</code></p>
</li>
<li><p>  局部定义：<code>directives:&#123;focus:&#123;&#125;&#125;</code></p>
</li>
<li><p>钩子函数：指令定义对象提供钩子函数</p>
<p>  o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
<p>  o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p>
<p>  o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</p>
<p>  o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</p>
<p>  o unbind：只调用一次，指令与元素解绑时调用。</p>
</li>
<li><p>钩子函数参数 o el：绑定元素</p>
<p>  o bing： 指令核心对象，描述指令全部信息属性</p>
<p>  o name</p>
<p>  o value</p>
<p>  o oldValue</p>
<p>  o expression</p>
<p>  o arg</p>
<p>  o modifers</p>
<p>  o vnode  虚拟节点</p>
<p>  o oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p>
</li>
</ul>
</li>
<li><p><strong>使用场景</strong></p>
<ul>
<li>  普通DOM元素进行底层操作的时候，可以使用自定义指令</li>
<li>  自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li>
</ul>
</li>
<li><p><strong>使用案例</strong></p>
<ul>
<li>初级应用：<ul>
<li>  鼠标聚焦</li>
<li>  下拉菜单</li>
<li>  相对时间转换</li>
<li>  滚动动画</li>
</ul>
</li>
<li>高级应用：<ul>
<li>  自定义指令实现图片懒加载</li>
<li>  自定义指令集成第三方插件</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="25-子组件可以直接改变父组件的数据吗？"><a href="#25-子组件可以直接改变父组件的数据吗？" class="headerlink" title="25. 子组件可以直接改变父组件的数据吗？"></a>25. 子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p>
<p>只能通过 <code>$emit</code> 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<h3 id="26-Vue-是如何收集依赖的？"><a href="#26-Vue-是如何收集依赖的？" class="headerlink" title="26. Vue 是如何收集依赖的？"></a>26. Vue 是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defieneReactive</span> (<span class="params">obj, key, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(Dep.target)&#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。 </p>
<ol>
<li><p><strong>Dep</strong> Dep是整个依赖收集的核心，其关键代码如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;  <span class="keyword">static</span> target;  subs;  <span class="title">constructor</span> (<span class="params"></span>) &#123;    ...    <span class="built_in">this</span>.subs = [];  &#125;  addSub (sub) &#123;    <span class="built_in">this</span>.subs.push(sub)  &#125;  removeSub (sub) &#123;    remove(<span class="built_in">this</span>.sub, sub)  &#125;  depend () &#123;    <span class="keyword">if</span>(Dep.target)&#123;      Dep.target.addDep(<span class="built_in">this</span>)    &#125;  &#125;  notify () &#123;    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subds.slice();    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; subs.length; i++)&#123;      subs[i].update()    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p> Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p>
</li>
<li><p><strong>Watcher</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;  getter;  ...  <span class="title">constructor</span> (<span class="params">vm, expression</span>)&#123;    ...    <span class="built_in">this</span>.getter = expression;    <span class="built_in">this</span>.get();  &#125;  get () &#123;    pushTarget(<span class="built_in">this</span>);    value = <span class="built_in">this</span>.getter.call(vm, vm)    ...    <span class="keyword">return</span> value  &#125;  addDep (dep)&#123;        ...    dep.addSub(<span class="built_in">this</span>)  &#125;  ...&#125;<span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target</span>) </span>&#123;  Dep.target = _target&#125;</span><br></pre></td></tr></table></figure>

<p> Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p>
</li>
<li><p><strong>过程</strong></p>
<p> 在实例化 Vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;  vm._update(vm._render())&#125;<span class="keyword">new</span> Watcher(vm, updateComponent)</span><br></pre></td></tr></table></figure>

<p> get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p>
<p> this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p>
</li>
</ol>
<h3 id="27-对-React-和-Vue-的理解，它们的异同"><a href="#27-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="27. 对 React 和 Vue 的理解，它们的异同"></a>27. 对 React 和 Vue 的理解，它们的异同</h3><ul>
<li><p><strong>相似之处：</strong></p>
<ul>
<li>  都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li>
<li>  都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li>
<li>  都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li>
<li>  都有props的概念，允许组件间的数据传递；</li>
<li>  都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li>
</ul>
</li>
<li><p><strong>不同之处 ：</strong></p>
<ol>
<li><p><strong>数据流</strong></p>
<p> Vue默认支持数据双向绑定，而React一直提倡单向数据流</p>
</li>
<li><p><strong>虚拟DOM</strong></p>
<p> Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。</p>
<ul>
<li>  Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li>
<li>  对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li>
</ul>
</li>
<li><p><strong>组件化</strong></p>
<p> React与Vue最大的不同是模板的编写。</p>
<ul>
<li>  Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li>
<li>  React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li>
</ul>
<p> 具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。</p>
</li>
<li><p><strong>监听数据变化的实现原理不同</strong></p>
<ul>
<li>  Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li>
<li>  React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li>
</ul>
</li>
<li><p><strong>高阶组件</strong></p>
<p> react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p>
<p> 高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p>
</li>
<li><p><strong>构建工具</strong></p>
<p> 两者都有自己的构建工具：</p>
<ul>
<li>  React ==&gt; Create React APP</li>
<li>  Vue ==&gt; vue-cli</li>
</ul>
</li>
<li><p><strong>跨平台</strong></p>
<ul>
<li>  React ==&gt; React Native</li>
<li>  Vue ==&gt; Weex</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="28-Vue-的优点"><a href="#28-Vue-的优点" class="headerlink" title="28. Vue 的优点"></a>28. Vue 的优点</h3><ul>
<li>  轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li>
<li>  简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li>
<li>  双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li>
<li>  组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li>
<li>  视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li>
<li>  虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li>
<li>  运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li>
</ul>
<h3 id="29-assets-和-static-的区别"><a href="#29-assets-和-static-的区别" class="headerlink" title="29. assets 和 static 的区别"></a>29. assets 和 static 的区别</h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p>
<p><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p>
<p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p>
<h3 id="30-delete-和-Vue-delete-删除数组的区别"><a href="#30-delete-和-Vue-delete-删除数组的区别" class="headerlink" title="30. delete 和 Vue.delete 删除数组的区别"></a>30. delete 和 Vue.delete 删除数组的区别</h3><ul>
<li>  <code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li>
<li>  <code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li>
</ul>
<h3 id="31-Vue-如何监听对象或者数组某个属性的变化"><a href="#31-Vue-如何监听对象或者数组某个属性的变化" class="headerlink" title="31. Vue 如何监听对象或者数组某个属性的变化"></a>31. Vue 如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p>
<p>解决方式：</p>
<ul>
<li><p>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.arr, <span class="number">0</span>, <span class="string">&quot;OBKoro1&quot;</span>); <span class="comment">// 改变数组this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>调用以下几个数组的方法</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p>
<p>vm.<code>$set</code> 的实现原理是：</p>
<ul>
<li>  如果目标是数组，直接使用数组的 splice 方法触发响应式；</li>
<li>  如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>
</ul>
<h3 id="32-什么是-mixin-？"><a href="#32-什么是-mixin-？" class="headerlink" title="32. 什么是 mixin ？"></a>32. 什么是 mixin ？</h3><ul>
<li>  Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li>
<li>  如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li>
<li>  然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li>
</ul>
<h3 id="33-Vue-模版编译原理"><a href="#33-Vue-模版编译原理" class="headerlink" title="33. Vue 模版编译原理"></a>33. Vue 模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p>
<ul>
<li>  <strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li>
<li>  <strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li>
<li>  <strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li>
</ul>
<h3 id="34-对-SSR-的理解"><a href="#34-对-SSR-的理解" class="headerlink" title="34. 对 SSR 的理解"></a>34. 对 SSR 的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p>
<p>SSR的优势：</p>
<ul>
<li>  更好的SEO</li>
<li>  首屏加载速度更快</li>
</ul>
<p>SSR的缺点：</p>
<ul>
<li>  开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li>
<li>  当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li>
<li>  更多的服务端负载。</li>
</ul>
<h3 id="35-Vue-的性能优化有哪些"><a href="#35-Vue-的性能优化有哪些" class="headerlink" title="35. Vue 的性能优化有哪些"></a>35. Vue 的性能优化有哪些</h3><ol>
<li><strong>编码阶段</strong><ul>
<li>  尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li>
<li>  v-if和v-for不能连用</li>
<li>  如果需要使用v-for给每项元素绑定事件时使用事件代理</li>
<li>  SPA 页面采用keep-alive缓存组件</li>
<li>  在更多的情况下，使用v-if替代v-show</li>
<li>  key保证唯一</li>
<li>  使用路由懒加载、异步组件</li>
<li>  防抖、节流</li>
<li>  第三方模块按需导入</li>
<li>  长列表滚动到可视区域动态加载</li>
<li>  图片懒加载</li>
</ul>
</li>
<li><strong>SEO优化</strong><ul>
<li>  预渲染</li>
<li>  服务端渲染SSR</li>
</ul>
</li>
<li><strong>打包优化</strong><ul>
<li>  压缩代码</li>
<li>  Tree Shaking/Scope Hoisting</li>
<li>  使用cdn加载第三方模块</li>
<li>  多线程打包happypack</li>
<li>  splitChunks抽离公共文件</li>
<li>  sourceMap优化</li>
</ul>
</li>
<li><strong>用户体验</strong><ul>
<li>  骨架屏</li>
<li>  PWA</li>
<li>  还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li>
</ul>
</li>
</ol>
<h3 id="36-对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#36-对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="36. 对 SPA 单页面的理解，它的优缺点分别是什么？"></a>36. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<ul>
<li><strong>优点：</strong><ul>
<li>  用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>  基于上面一点，SPA 相对对服务器压力小；</li>
<li>  前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>  初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>  前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>  SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
</li>
</ul>
<h3 id="37-template-和-jsx-的有什么分别？"><a href="#37-template-和-jsx-的有什么分别？" class="headerlink" title="37. template 和 jsx 的有什么分别？"></a>37. template 和 jsx 的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p>
<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>
<h3 id="38-Vue-初始化页面闪动问题"><a href="#38-Vue-初始化页面闪动问题" class="headerlink" title="38. Vue 初始化页面闪动问题"></a>38. Vue 初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p>
<p>首先：在css里加上以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[v-cloak] &#123;    <span class="attr">display</span>: none;&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p>
<h3 id="39-extend-有什么作用"><a href="#39-extend-有什么作用" class="headerlink" title="39. extend 有什么作用"></a>39. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建组件构造器</span></span><br><span class="line"><span class="keyword">let</span> Component = Vue.extend(&#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;test&lt;/div&gt;&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 挂载到 #app 上</span></span><br><span class="line"><span class="keyword">new</span> Component().$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// 除了上面的方式，还可以用来扩展已有的组件</span></span><br><span class="line"><span class="keyword">let</span> SuperComponent = Vue.extend(Component)</span><br><span class="line"><span class="keyword">new</span> SuperComponent(&#123;</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> SuperComponent().$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="40-mixin-和-mixins-区别"><a href="#40-mixin-和-mixins-区别" class="headerlink" title="40. mixin 和 mixins 区别"></a>40. mixin 和 mixins 区别</h3><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;        <span class="comment">// ...逻辑        // 这种方式会影响到每个组件的 beforeCreate 钩子函数    &#125;&#125;)</span></span><br></pre></td></tr></table></figure>

<p>虽然文档不建议在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p>
<p><code>mixins</code> 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。 另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</p>
<h3 id="41-MVVM-的优缺点"><a href="#41-MVVM-的优缺点" class="headerlink" title="41. MVVM 的优缺点?"></a>41. MVVM 的优缺点?</h3><ul>
<li>优点:<ul>
<li>  分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑</li>
<li>  提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</li>
<li>  ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</li>
</ul>
</li>
<li>缺点:<ul>
<li>  Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</li>
<li>  ⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存</li>
<li>  对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li>
</ul>
</li>
</ul>
<h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><h3 id="1-说一下-Vue-的生命周期（Vue2-x-Vue3-0）"><a href="#1-说一下-Vue-的生命周期（Vue2-x-Vue3-0）" class="headerlink" title="1. 说一下 Vue 的生命周期（Vue2.x Vue3.0）"></a>1. 说一下 Vue 的生命周期（Vue2.x Vue3.0）</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p>
<ol>
<li> <strong>beforeCreate（创建前）</strong>：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li>
<li> <strong>created（创建后）</strong> ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li>
<li> <strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li>
<li> <strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li>
<li> <strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li>
<li> <strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li> <strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li>
<li> <strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li>
</ol>
<p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p>
<h3 id="2-Vue-子组件和父组件执行顺序"><a href="#2-Vue-子组件和父组件执行顺序" class="headerlink" title="2. Vue 子组件和父组件执行顺序"></a>2. Vue 子组件和父组件执行顺序</h3><ul>
<li><strong>加载渲染过程：</strong><ol>
<li> 父组件 beforeCreate</li>
<li> 父组件 created</li>
<li> 父组件 beforeMount</li>
<li> 子组件 beforeCreate</li>
<li> 子组件 created</li>
<li> 子组件 beforeMount</li>
<li> 子组件 mounted</li>
<li> 父组件 mounted</li>
</ol>
</li>
<li><strong>更新过程：</strong><ol>
<li> 父组件 beforeUpdate</li>
<li> 子组件 beforeUpdate</li>
<li> 子组件 updated</li>
<li> 父组件 updated</li>
</ol>
</li>
<li><strong>销毁过程：</strong><ol>
<li> 父组件 beforeDestroy</li>
<li> 子组件 beforeDestroy</li>
<li> 子组件 destroyed</li>
<li> 父组件 destoryed</li>
</ol>
</li>
</ul>
<h3 id="3-created-和-mounted-的区别"><a href="#3-created-和-mounted-的区别" class="headerlink" title="3. created 和 mounted 的区别"></a>3. created 和 mounted 的区别</h3><ul>
<li>  created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li>
<li>  mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li>
</ul>
<h3 id="4-一般在哪个生命周期请求异步数据"><a href="#4-一般在哪个生命周期请求异步数据" class="headerlink" title="4. 一般在哪个生命周期请求异步数据"></a>4. 一般在哪个生命周期请求异步数据</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 </p>
<p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>  能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li>
<li>  SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li>
</ul>
<h3 id="5-keep-alive-中的生命周期哪些"><a href="#5-keep-alive-中的生命周期哪些" class="headerlink" title="5. keep-alive 中的生命周期哪些"></a>5. keep-alive 中的生命周期哪些</h3><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p>
<p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p>
<p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p>
<h2 id="三、组件通信"><a href="#三、组件通信" class="headerlink" title="三、组件通信"></a>三、组件通信</h2><h3 id="1-组件通信的方式"><a href="#1-组件通信的方式" class="headerlink" title="1. 组件通信的方式"></a>1. 组件通信的方式</h3><ol>
<li><p>props  /  $emit</p>
<p>  父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p>
<ol>
<li><p>父组件向子组件传值</p>
<ul>
<li>  <code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li>
<li>  <code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li>
<li>  <code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">son</span> <span class="attr">:msg</span>=<span class="string">&quot;msgData&quot;</span> <span class="attr">:fn</span>=<span class="string">&quot;myFunction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> son <span class="keyword">from</span> <span class="string">&quot;./son.vue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">name</span>: father,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">msgData</span>: <span class="string">&quot;父组件数据&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="title">myFunction</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">console</span>.log(<span class="string">&quot;vue&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        son</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件&lt;template&gt;    &lt;div id=&quot;son&quot;&gt;        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;        &lt;button @click=&quot;fn&quot;&gt;按钮&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &quot;son&quot;,    props: [&quot;msg&quot;, &quot;fn&quot;]&#125;;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>子组件向父组件传值</p>
<ul>
<li>  <code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;section&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">com-article</span> <span class="attr">:articles</span>=<span class="string">&quot;articleList&quot;</span> @<span class="attr">onEmitIndex</span>=<span class="string">&quot;onEmitIndex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">com-article</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;currentIndex&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> comArticle <span class="keyword">from</span> <span class="string">&#x27;./test/article.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&#x27;comArticle&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>: &#123; comArticle &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">currentIndex</span>: -<span class="number">1</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">articleList</span>: [<span class="string">&#x27;红楼梦&#x27;</span>, <span class="string">&#x27;西游记&#x27;</span>, <span class="string">&#x27;三国演义&#x27;</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">onEmitIndex</span>(<span class="params">idx</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.currentIndex = idx</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in articles&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;emitIndex(index)&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">props</span>: [<span class="string">&#x27;articles&#x27;</span>],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">emitIndex</span>(<span class="params">index</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;onEmitIndex&#x27;</span>, index) <span class="comment">// 触发父组件的方法，并传递参数index</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>eventBus事件总线（$emit / $on）</p>
<p> <code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下：</p>
<ol>
<li><p><strong>创建事件中心管理组件之间的通信</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event-bus.jsimport Vue from &#x27;vue&#x27;export const EventBus = new Vue()</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>发送事件</strong> 假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">first-com</span>&gt;</span><span class="tag">&lt;/<span class="name">first-com</span>&gt;</span>    <span class="tag">&lt;<span class="name">second-com</span>&gt;</span><span class="tag">&lt;/<span class="name">second-com</span>&gt;</span>  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;import firstCom from &#x27;./</span>firstCom.vue<span class="string">&#x27;import secondCom from &#x27;</span>./secondCom.vue<span class="string">&#x27;export default &#123;  components: &#123; firstCom, secondCom &#125;&#125;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在<code>firstCom</code>组件中发送事件：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>加法<span class="tag">&lt;/<span class="name">button</span>&gt;</span>      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;import &#123;EventBus&#125; from &#x27;./</span>event-bus.js<span class="string">&#x27; // 引入事件中心export default &#123;  data()&#123;    return&#123;      num:0    &#125;  &#125;,  methods:&#123;    add()&#123;      EventBus.$emit(&#x27;</span>addition<span class="string">&#x27;, &#123;        num:this.num++      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>接收事件</strong> 在<code>secondCom</code>组件中发送事件：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>求和: &#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;import &#123; EventBus &#125; from &#x27;./</span>event-bus.js<span class="string">&#x27;export default &#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;,  mounted() &#123;    EventBus.$on(&#x27;</span>addition<span class="string">&#x27;, param =&gt; &#123;      this.count = this.count + param.num;    &#125;)  &#125;&#125;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p>
<p> 虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p>
</li>
</ol>
</li>
<li><p>依赖注入（provide / inject）</p>
<p> 这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p>
<p> <code>provide / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。</p>
<ul>
<li>  <code>provide</code> 钩子用来发送数据或方法</li>
<li>  <code>inject</code>钩子用来接收数据或方法</li>
</ul>
<p> 在父组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> &#123;     </span><br><span class="line">        <span class="attr">num</span>: <span class="built_in">this</span>.num  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在子组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">inject: [<span class="string">&#x27;num&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p> 还可以这样写，这样写就可以访问父组件中的所有属性：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="built_in">this</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">inject</span>: [<span class="string">&#x27;app&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.app.num)</span><br></pre></td></tr></table></figure>

<p> <strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p>
</li>
<li><p>ref / $refs</p>
<p> 这种方式也是实现<strong>父子组件</strong>之间的通信。</p>
<p> <code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p>
<p> 在子组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  data () &#123;    <span class="keyword">return</span> &#123;      <span class="attr">name</span>: <span class="string">&#x27;JavaScript&#x27;</span>    &#125;  &#125;,  <span class="attr">methods</span>: &#123;    sayHello () &#123;      <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p> 在父组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  <span class="xml"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;  import child from &#x27;./</span>child.vue<span class="string">&#x27;  export default &#123;    components: &#123; child &#125;,    mounted () &#123;      console.log(this.$refs.child.name);  // JavaScript      this.$refs.child.sayHello();  // hello    &#125;  &#125;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>$parent / $children</p>
<ul>
<li>  使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li>
<li>  使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li>
</ul>
<p> 在子组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>    <span class="tag">&lt;<span class="name">p</span>&gt;</span>获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &#x27;Vue&#x27;    &#125;  &#125;,  computed:&#123;    parentVal()&#123;      return this.$parent.msg;    &#125;  &#125;&#125;&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p> 在父组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello_world&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>点击改变子组件值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>: &#123; child &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">msg</span>: <span class="string">&#x27;Welcome&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 获取到子组件</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.$children[<span class="number">0</span>].message = <span class="string">&#x27;JavaScript&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> 在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。 <strong>需要注意：</strong></p>
<ul>
<li>  通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li>
<li>  在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li>
<li>  在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li>
<li>  <code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li>
</ul>
</li>
<li><p>$attrs / $listeners</p>
<p> 考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p>
<p> 如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p>
<p> 针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p>
<p> 先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p>
<ul>
<li>  <code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li>
<li>  <code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li>
</ul>
<p> A组件（<code>APP.vue</code>）：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>        //此处监听了两个事件，可以在B组件或者C组件中直接触发         <span class="tag">&lt;<span class="name">child1</span> <span class="attr">:p-child1</span>=<span class="string">&quot;child1&quot;</span> <span class="attr">:p-child2</span>=<span class="string">&quot;child2&quot;</span> @<span class="attr">test1</span>=<span class="string">&quot;onTest1&quot;</span> @<span class="attr">test2</span>=<span class="string">&quot;onTest2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child1</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;import Child1 from &#x27;./</span>Child1.vue<span class="string">&#x27;;export default &#123;    components: &#123; Child1 &#125;,    methods: &#123;        onTest1() &#123;            console.log(&#x27;</span>test1 running<span class="string">&#x27;);        &#125;,        onTest2() &#123;            console.log(&#x27;</span>test2 running<span class="string">&#x27;);        &#125;    &#125;&#125;;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> B组件（<code>Child1.vue</code>）：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>props: &#123;&#123;pChild1&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">child2</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> Child2 <span class="keyword">from</span> <span class="string">&#x27;./Child2.vue&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">props</span>: [<span class="string">&#x27;pChild1&#x27;</span>],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">components</span>: &#123; Child2 &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;test1&#x27;</span>); <span class="comment">// 触发APP.vue中的test1方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> C 组件 (<code>Child2.vue</code>)：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>props: &#123;&#123;pChild2&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">props</span>: [<span class="string">&#x27;pChild2&#x27;</span>],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;test2&#x27;</span>);<span class="comment">// 触发APP.vue中的test2方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> 在上述代码中：</p>
<ul>
<li>  C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li>
<li>  在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li>
</ul>
</li>
<li><p>总结</p>
<ol>
<li><strong>父子组件间通信</strong><ul>
<li>  子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li>
<li>  通过 ref 属性给子组件设置一个名字。父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件，这样也可以实现通信。</li>
<li>  使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li>
</ul>
</li>
<li><strong>兄弟组件间通信</strong><ul>
<li>  使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li>
<li>  通过 <code>$parent/$refs</code> 来获取到兄弟组件，也可以进行通信。</li>
</ul>
</li>
<li><strong>任意组件之间</strong><ul>
<li>  使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li>
</ul>
</li>
</ol>
<p> 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>
</li>
</ol>
<h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h3 id="1-Vue-Router-的懒加载如何实现"><a href="#1-Vue-Router-的懒加载如何实现" class="headerlink" title="1. Vue-Router 的懒加载如何实现"></a>1. Vue-Router 的懒加载如何实现</h3><ul>
<li><p>非懒加载：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">&#x27;@/components/list.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: List &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>懒加载</p>
<ol>
<li><p>方案一(常用)：使用箭头函数+import动态加载</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/components/list.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: List &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>方案二：使用箭头函数+require动态加载</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/list&#x27;</span>], resolve)</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// r就是resolve</span></span><br><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], <span class="function">() =&gt;</span> r(<span class="built_in">require</span>(<span class="string">&#x27;@/components/list&#x27;</span>)), <span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: List,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="2-路由的-hash-和-history-模式的区别"><a href="#2-路由的-hash-和-history-模式的区别" class="headerlink" title="2. 路由的 hash 和 history 模式的区别"></a>2. 路由的 hash 和 history 模式的区别</h3><p>Vue-Router有两种模式：<strong>hash模式</strong>和<strong>history模式</strong>。默认的路由模式是hash模式。</p>
<ol>
<li><p>hash 模式</p>
<ul>
<li><p>  <strong>简介：</strong> hash模式是开发中默认的模式，它的URL带着一个#，例如：<a href="https://link.juejin.cn/?target=http://www.abc.com/%23/vue">www.abc.com/#/vue</a>，它的hash值就是<code>#/vue</code>。</p>
</li>
<li><p>  <strong>特点</strong>：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。</p>
</li>
<li><p><strong>原理：</strong> hash模式的主要原理就是<strong>onhashchange()事件</strong>：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(event.oldURL, event.newURL);</span><br><span class="line">	<span class="keyword">let</span> hash = location.hash.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</p>
</li>
<li><p><strong>优缺点</strong></p>
<ul>
<li>  兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由</li>
<li>  只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误</li>
<li>  hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换</li>
<li>  会覆盖锚点定位元素的功能</li>
<li>  不太美观，#后面传输的数据复杂的话会出现问题</li>
</ul>
</li>
</ul>
</li>
<li><p>history 模式</p>
<ul>
<li><p>  <strong>简介：</strong> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。 </p>
</li>
<li><p>  <strong>特点：</strong> 当使用history模式时，URL就像这样：<a href="https://link.juejin.cn/?target=http://abc.com/user/id">abc.com/user/id</a>。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。</p>
</li>
<li><p>   <strong>API：</strong> history api可以分为两大部分，切换历史状态和修改历史状态：</p>
</li>
</ul>
<pre><code> -   **修改历史状态**：包括了 HTML5 History Interface 中新增的 `pushState()` 和 `replaceState()` 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。
 -   **切换历史状态：** 包括`forward()`、`back()`、`go()`三个方法，对应浏览器的前进，后退，跳转操作。

 虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。

 如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：

 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">routes</span>: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li><p><strong>优缺点</strong></p>
<ul>
<li>  使用简单，比较美观</li>
<li>  <code>pushState()</code>设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL</li>
<li>  <code>pushState()</code>设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中</li>
<li>  <code>pushState()</code>可以通过<code>stateObject</code>参数添加任意类型的数据到记录中，而hash只能添加短字符串</li>
<li>  <code>pushState()</code>可额外设置title属性供后续使用</li>
<li>  前端的URL必须和向发送请求后端URL保持一致，否则会报404错误</li>
<li>  由于History API的缘故，低版本浏览器有兼容性问题</li>
</ul>
</li>
</ul>
</li>
<li><p>两种模式对比</p>
<p> 调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p>
<ul>
<li>  pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li>
<li>  pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li>
<li>  pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li>
<li>  pushState() 可额外设置 title 属性供后续使用。</li>
<li>  hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对应的路由处理，将返回404错误。</li>
</ul>
<p> hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</p>
</li>
</ol>
<h3 id="3-如何获取页面的-hash-变化"><a href="#3-如何获取页面的-hash-变化" class="headerlink" title="3. 如何获取页面的 hash 变化"></a>3. 如何获取页面的 hash 变化</h3><ol>
<li><p><strong>监听$route的变化</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听,当路由发生变化的时候执行</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">$route</span>: &#123;</span><br><span class="line">    <span class="attr">handler</span>: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 深度观察监听</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p> <strong>window.location.hash读取#值</strong> window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。</p>
</li>
</ol>
<h3 id="4-route-和-router-的区别"><a href="#4-route-和-router-的区别" class="headerlink" title="4. route 和 router 的区别"></a>4. route 和 router 的区别</h3><ul>
<li>  $route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li>
<li>  $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等</li>
</ul>
<h3 id="5-如何定义动态路由？如何获取传过来的动态参数？"><a href="#5-如何定义动态路由？如何获取传过来的动态参数？" class="headerlink" title="5. 如何定义动态路由？如何获取传过来的动态参数？"></a>5. 如何定义动态路由？如何获取传过来的动态参数？</h3><ol>
<li><p>param 方式</p>
<ul>
<li>  配置路由格式：<code>/router/:id</code></li>
<li>  传递的方式：在path后面跟上对应的值</li>
<li>  传递后形成的路径：<code>/router/123</code></li>
</ul>
<ol>
<li><p>路由定义</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在APP.vue中</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#x27;/user/&#x27;+userId&quot;</span> replace&gt;用户&lt;/router-link&gt;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//在index.js</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/user/:userid&#x27;</span>,</span><br><span class="line">   <span class="attr">component</span>: User,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>路由跳转</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: wade &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>:<span class="string">&#x27;users&#x27;</span>,<span class="attr">params</span>:&#123;<span class="attr">uname</span>:wade&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/user/&#x27;</span> + wade)</span><br></pre></td></tr></table></figure></li>
<li><p> 参数获取 通过 <code>$route.params.userid</code> 获取传递的值</p>
</li>
</ol>
</li>
<li><p>query 方式</p>
<ul>
<li>  配置路由格式：<code>/router</code>，也就是普通配置</li>
<li>  传递的方式：对象中使用query的key作为传递方式</li>
<li>  传递后形成的路径：<code>/route?id=123</code></li>
</ul>
<ol>
<li><p>路由定义</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1：直接在router-link 标签上以对象的形式</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;why&#x27;,age:28,height:188&#125;&#125;&quot;</span>&gt;档案&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：写成按钮以点击事件形式</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;profileClick&#x27;</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">profileClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/profile&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;kobi&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&quot;28&quot;</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="number">198</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>跳转方法</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;users&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>:james &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; path: &#x27;/user&#x27;, query: &#123; uname:james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>:james &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法5：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/user?uname=&#x27;</span> + jsmes)</span><br></pre></td></tr></table></figure></li>
<li><p>获取参数</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">通过$route.query 获取传递的值</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="6-Vue-router-路由钩子在生命周期的体现"><a href="#6-Vue-router-路由钩子在生命周期的体现" class="headerlink" title="6. Vue-router 路由钩子在生命周期的体现"></a>6. Vue-router 路由钩子在生命周期的体现</h3><ol>
<li><p>Vue-Router 导航守卫</p>
<p> 有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p>
<ol>
<li><p>全局路由钩子</p>
<p> vue-router全局有三个路由钩子;</p>
<ul>
<li>  router.beforeEach 全局前置守卫 进入路由之前</li>
<li>  router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li>
<li>  router.afterEach 全局后置钩子 进入路由之后</li>
</ul>
<p> 具体使用∶</p>
<ul>
<li><p>beforeEach（判断是否登录了，没登录就跳转到登录页）</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">let</span> ifInfo = Vue.prototype.$common.getSession(<span class="string">&#x27;userData&#x27;</span>);  <span class="comment">// 判断是否登录的存储信息</span></span><br><span class="line">    <span class="keyword">if</span> (!ifInfo) &#123; </span><br><span class="line">        <span class="comment">// sessionStorage里没有储存user信息    </span></span><br><span class="line">        <span class="keyword">if</span> (to.path == <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//如果是登录页面路径，就直接next()      </span></span><br><span class="line">            next();    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">//不然就跳转到登录      </span></span><br><span class="line">            Message.warning(<span class="string">&quot;请重新登录！&quot;</span>);     </span><br><span class="line">            <span class="built_in">window</span>.location.href = Vue.prototype.$loginUrl;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> next();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>afterEach （跳转之后滚动条回到顶部）</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 跳转之后滚动条回到顶部  </span></span><br><span class="line">    <span class="built_in">window</span>.scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>单个路由独享钩子</p>
<p> <strong>beforeEnter</strong> 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,        </span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,        </span><br><span class="line">        <span class="attr">component</span>: login,        </span><br><span class="line">        <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;          </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;即将进入登录页面&#x27;</span>)          </span><br><span class="line">            next()        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>组件内钩子</p>
<p> beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave</p>
<p> 这三个钩子都有三个参数∶to、from、next</p>
<ul>
<li>  beforeRouteEnter∶ 进入组件前触发</li>
<li>  beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li>
<li>  beforeRouteLeave∶ 离开组件被调用</li>
</ul>
<p> 注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;      </span><br><span class="line">    next(<span class="function"><span class="params">target</span> =&gt;</span> &#123;        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">from</span>.path == <span class="string">&#x27;/classProcess&#x27;</span>) &#123;          </span><br><span class="line">            target.isFromProcess = <span class="literal">true</span>        </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Vue路由钩子在生命周期函数的体现</p>
<ol>
<li><p>完整的路由导航解析流程（不包括其他生命周期）</p>
<ul>
<li>  触发进入其他路由。</li>
<li>  调用要离开路由的组件守卫beforeRouteLeave</li>
<li>  调用局前置守卫∶ beforeEach</li>
<li>  在重用的组件里调用 beforeRouteUpdate</li>
<li>  调用路由独享守卫 beforeEnter。</li>
<li>  解析异步路由组件。</li>
<li>  在将要进入的路由组件中调用 beforeRouteEnter</li>
<li>  调用全局解析守卫 beforeResolve</li>
<li>  导航被确认。</li>
<li>  调用全局后置钩子的 afterEach 钩子。</li>
<li>  触发DOM更新（mounted）。</li>
<li>  执行beforeRouteEnter 守卫中传给 next 的回调函数</li>
</ul>
</li>
<li><p>触发钩子的完整顺序</p>
<p> 路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p>
<ul>
<li>  beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li>
<li>  beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li>
<li>  beforeEnter：路由独享守卫</li>
<li>  beforeRouteEnter：路由组件的组件进入路由前钩子。</li>
<li>  beforeResolve：路由全局解析守卫</li>
<li>  afterEach：路由全局后置钩子</li>
<li>  beforeCreate：组件生命周期，不能访问tAis。</li>
<li>  created;组件生命周期，可以访问tAis，不能访问dom。</li>
<li>  beforeMount：组件生命周期</li>
<li>  deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li>
<li>  mounted：访问/操作dom。</li>
<li>  activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li>
<li>  执行beforeRouteEnter回调函数next。</li>
</ul>
</li>
<li><p>导航行为被触发到导航完成的整个过程</p>
<ul>
<li>  导航行为被触发，此时导航未被确认。</li>
<li>  在失活的组件里调用离开守卫 beforeRouteLeave。</li>
<li>  调用全局的 beforeEach守卫。</li>
<li>  在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li>
<li>  在路由配置里调用 beforeEnteY。</li>
<li>  解析异步路由组件（如果有）。</li>
<li>  在被激活的组件里调用 beforeRouteEnter。</li>
<li>  调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li>
<li>  导航被确认。</li>
<li>  调用全局的 afterEach 钩子。</li>
<li>  非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li>
<li>  触发 DOM 更新。</li>
<li>  用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li>
<li>  导航完成</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="7-Vue-router-跳转和-location-href-有什么区别"><a href="#7-Vue-router-跳转和-location-href-有什么区别" class="headerlink" title="7. Vue-router 跳转和 location.href 有什么区别"></a>7. Vue-router 跳转和 location.href 有什么区别</h3><ul>
<li>  使用 <code>location.href= /url </code>来跳转，简单方便，但是刷新了页面；</li>
<li>  使用 <code>history.pushState( /url )</code> ，无刷新页面，静态跳转；</li>
<li>  引进 router ，然后使用 <code>router.push( /url )</code> 来跳转，使用了 <code>diff</code> 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 <code>history.pushState()</code> 没什么差别的，因为vue-router就是用了 <code>history.pushState()</code> ，尤其是在history模式下。</li>
</ul>
<h3 id="8-params-和-query-的区别"><a href="#8-params-和-query-的区别" class="headerlink" title="8. params 和 query 的区别"></a>8. params 和 query 的区别</h3><p><strong>用法</strong>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 <code>this.$route.query.name</code> 和 <code>this.$route.params.name</code> 。</p>
<p><strong>url地址显示</strong>：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p>
<p><strong>注意</strong>：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。</p>
<h3 id="9-Vue-router-导航守卫有哪些"><a href="#9-Vue-router-导航守卫有哪些" class="headerlink" title="9. Vue-router 导航守卫有哪些"></a>9. Vue-router 导航守卫有哪些</h3><ul>
<li>  全局前置/钩子：beforeEach、beforeResolve、afterEach</li>
<li>  路由独享的守卫：beforeEnter</li>
<li>  组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li>
</ul>
<h3 id="10-对前端路由的理解"><a href="#10-对前端路由的理解" class="headerlink" title="10. 对前端路由的理解"></a>10. 对前端路由的理解</h3><p>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。</p>
<p>后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。</p>
<p>SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：</p>
<ul>
<li>  SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。</li>
<li>  由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息</li>
</ul>
<p>为了解决这个问题，前端路由出现了。</p>
<p>前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。</p>
<p>那么如何实现这个目的呢？首先要解决两个问题：</p>
<ul>
<li>  当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</li>
<li>  单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？</li>
</ul>
<p>从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：</p>
<ul>
<li>  拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li>
<li>  感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</li>
</ul>
<h2 id="五、Vuex"><a href="#五、Vuex" class="headerlink" title="五、Vuex"></a>五、Vuex</h2><h3 id="1-Vuex-的原理"><a href="#1-Vuex-的原理" class="headerlink" title="1. Vuex 的原理"></a>1. Vuex 的原理</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<ul>
<li>  Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>  改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。</li>
</ul>
<p><img src="/../../../Desktop/%E9%9D%A2%E8%AF%95/pic/04/04-5-1.png"></p>
<p>Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。</p>
<ol>
<li><strong>核心流程中的主要功能：</strong><ul>
<li>  Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;</li>
<li>  在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li>
<li>  然后 Mutations 就去改变（Mutate）State 中的数据;</li>
<li>  当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li>
</ul>
</li>
<li><strong>各模块在核心流程中的主要功能：</strong><ul>
<li>  <code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li>
<li>  <code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li>
<li>  <code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li>
<li>  <code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li>
<li>  <code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li>
<li>  <code>state</code>∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li>
<li>  <code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li>
</ul>
</li>
</ol>
<h3 id="2-Vuex-中-action-和-mutation-的区别"><a href="#2-Vuex-中-action-和-mutation-的区别" class="headerlink" title="2. Vuex 中 action 和 mutation 的区别"></a>2. Vuex 中 action 和 mutation 的区别</h3><p>mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++      <span class="comment">// 变更状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当触发一个类型为 increment 的 mutation 时，需要调用此函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>而Action类似于mutation，不同点在于：</p>
<ul>
<li>  Action 可以包含任意异步操作。</li>
<li>  Action 提交的是 mutation，而不是直接变更状态。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 所以，两者的不同点如下：</p>
<ul>
<li>  Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。</li>
<li>  Mutation：必须同步执行；Action：可以异步，但不能直接操作State。</li>
<li>  在视图更新时，先触发actions，actions再触发mutation</li>
<li>  mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters</li>
</ul>
<h3 id="3-Vuex-和-localStorage-的区别"><a href="#3-Vuex-和-localStorage-的区别" class="headerlink" title="3. Vuex 和 localStorage 的区别"></a>3. Vuex 和 localStorage 的区别</h3><ol>
<li><p><strong>最重要的区别</strong></p>
<ul>
<li>  vuex存储在内存中</li>
<li>  localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快</li>
</ul>
</li>
<li><p><strong>应用场景</strong></p>
<ul>
<li>  Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。</li>
<li>  localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。</li>
<li>  Vuex能做到数据的响应式，localstorage不能</li>
</ul>
</li>
<li><p><strong>永久性</strong></p>
<p> 刷新页面时vuex存储的值会丢失，localstorage不会。</p>
</li>
</ol>
<p><strong>注意：</strong> 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。</p>
<h3 id="4-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#4-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="4. Redux 和 Vuex 有什么区别，它们的共同思想"></a>4. Redux 和 Vuex 有什么区别，它们的共同思想</h3><ol>
<li><p><strong>Redux 和 Vuex区别</strong></p>
<ul>
<li>  Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li>
<li>  Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li>
<li>  Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</li>
</ul>
<p> 通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;</p>
</li>
<li><p><strong>共同思想</strong></p>
<ul>
<li>  单—的数据源</li>
<li>  变化可以预测</li>
</ul>
</li>
</ol>
<p>本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案; 形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理</p>
<h3 id="5-为什么要用-Vuex-或者-Redux"><a href="#5-为什么要用-Vuex-或者-Redux" class="headerlink" title="5. 为什么要用 Vuex 或者 Redux"></a>5. 为什么要用 Vuex 或者 Redux</h3><p>由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。</p>
<p>所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p>
<p>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。</p>
<h3 id="6-Vuex-有哪几种属性？"><a href="#6-Vuex-有哪几种属性？" class="headerlink" title="6. Vuex 有哪几种属性？"></a>6. Vuex 有哪几种属性？</h3><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p>
<ul>
<li>  state =&gt; 基本数据(数据源存放地)</li>
<li>  getters =&gt; 从基本数据派生出来的数据</li>
<li>  mutations =&gt; 提交更改数据的方法，同步</li>
<li>  actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。</li>
<li>  modules =&gt; 模块化Vuex</li>
</ul>
<h3 id="7-Vuex-和单纯的全局对象有什么区别？"><a href="#7-Vuex-和单纯的全局对象有什么区别？" class="headerlink" title="7. Vuex 和单纯的全局对象有什么区别？"></a>7. Vuex 和单纯的全局对象有什么区别？</h3><ul>
<li>  Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>  不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li>
</ul>
<h3 id="8-为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#8-为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="8. 为什么 Vuex 的 mutation 中不能做异步操作？"></a>8. 为什么 Vuex 的 mutation 中不能做异步操作？</h3><ul>
<li>  Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li>
<li>  每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li>
</ul>
<h3 id="9-Vuex-的严格模式是什么-有什么作用，如何开启？"><a href="#9-Vuex-的严格模式是什么-有什么作用，如何开启？" class="headerlink" title="9. Vuex 的严格模式是什么,有什么作用，如何开启？"></a>9. Vuex 的严格模式是什么,有什么作用，如何开启？</h3><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>
<p>在Vuex.Store 构造器选项中开启,如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="attr">strict</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="10-如何在组件中批量使用-Vuex-的-getter-属性"><a href="#10-如何在组件中批量使用-Vuex-的-getter-属性" class="headerlink" title="10. 如何在组件中批量使用 Vuex 的 getter 属性"></a>10. 如何在组件中批量使用 Vuex 的 getter 属性</h3><p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        ...mapGetters([<span class="string">&#x27;total&#x27;</span>,<span class="string">&#x27;discountTotal&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-如何在组件中重复使用-Vuex-的-mutation"><a href="#11-如何在组件中重复使用-Vuex-的-mutation" class="headerlink" title="11. 如何在组件中重复使用 Vuex 的 mutation"></a>11. 如何在组件中重复使用 Vuex 的 mutation</h3><p>使用mapMutations辅助函数,在组件中这么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">        <span class="attr">setNumber</span>:<span class="string">&#x27;SET_NUMBER&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p>
<h2 id="六、Vue-3-0"><a href="#六、Vue-3-0" class="headerlink" title="六、Vue 3.0"></a>六、Vue 3.0</h2><h3 id="1-Vue3-0-有什么更新"><a href="#1-Vue3-0-有什么更新" class="headerlink" title="1. Vue3.0 有什么更新"></a>1. Vue3.0 有什么更新</h3><ol>
<li>监测机制的改变<ul>
<li>  3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。</li>
<li>  消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</li>
</ul>
</li>
<li>只能监测属性，不能监测对象<ul>
<li>  检测属性的添加和删除；</li>
<li>  检测数组索引和长度的变更；</li>
<li>  支持 Map、Set、WeakMap 和 WeakSet。</li>
</ul>
</li>
<li>模板<ul>
<li>  作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</li>
<li>  同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</li>
</ul>
</li>
<li>对象式的组件声明方式<ul>
<li>  vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</li>
<li>  3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</li>
</ul>
</li>
<li>其它方面的修改<ul>
<li>  支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li>
<li>  支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li>
<li>  基于 tree shaking 优化，提供了更多的内置功能。</li>
</ul>
</li>
</ol>
<h3 id="2-defineProperty-和-proxy-的区别"><a href="#2-defineProperty-和-proxy-的区别" class="headerlink" title="2. defineProperty 和 proxy 的区别"></a>2. defineProperty 和 proxy 的区别</h3><p>Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。</p>
<p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p>但是这样做有以下问题：</p>
<ol>
<li> 添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过<code>$set</code> 来调用<code>Object.defineProperty()</code>处理。</li>
<li> 无法监控到数组下标和长度的变化。</li>
</ol>
<p>Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于<code>Object.defineProperty()</code>，其有以下特点：</p>
<ol>
<li> Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li>
<li> Proxy 可以监听数组的变化。</li>
</ol>
<h3 id="3-Vue3-0-为什么要用-proxy？"><a href="#3-Vue3-0-为什么要用-proxy？" class="headerlink" title="3. Vue3.0 为什么要用 proxy？"></a>3. Vue3.0 为什么要用 proxy？</h3><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p>
<ul>
<li>  不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li>
<li>  全方位的数组变化检测，消除了Vue2 无效的边界情况。</li>
<li>  支持 Map，Set，WeakMap 和 WeakSet。</li>
</ul>
<p>Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶</p>
<ul>
<li>  get 收集依赖</li>
<li>  Set、delete 等触发依赖</li>
<li>  对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</li>
</ul>
<h3 id="4-Vue-3-0-中的-Vue-Composition-API？"><a href="#4-Vue-3-0-中的-Vue-Composition-API？" class="headerlink" title="4. Vue 3.0 中的 Vue Composition API？"></a>4. Vue 3.0 中的 Vue Composition API？</h3><p>在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：</p>
<ol>
<li> 由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。</li>
<li> Vue 组件过于依赖<code>this</code>上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在<code>methods</code> 中的<code>this</code>竟然指向组件实例来不指向<code>methods</code>所在的对象。这也使得 TypeScript 在Vue2 中很不好用。</li>
</ol>
<p>于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。</p>
<p>如下，是一个使用了 Vue Composition API 的 Vue3 组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    Count: &#123;&#123; count &#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> &#123; ref, computed, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"> </span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> </span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// Vue2中需要在methods option中声明的函数，现在直接声明</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      count.value++</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> <span class="comment">// 对应于Vue2中的mounted声明周期</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    onMounted(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;component mounted!&#x27;</span>))</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> </span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      count,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      increment</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性</p>
<h3 id="5-Composition-API-与-React-Hook-很像，区别是什么"><a href="#5-Composition-API-与-React-Hook-很像，区别是什么" class="headerlink" title="5. Composition API 与 React Hook 很像，区别是什么"></a>5. Composition API 与 React Hook 很像，区别是什么</h3><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p>
<ul>
<li>  不能在循环、条件、嵌套函数中调用Hook</li>
<li>  必须确保总是在你的React函数的顶层调用Hook</li>
<li>  useEffect、useMemo等函数必须手动确定依赖关系</li>
</ul>
<p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p>
<ul>
<li>  声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li>
<li>  Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li>
<li>  响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li>
</ul>
<p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p>
<h2 id="七、虚拟DOM"><a href="#七、虚拟DOM" class="headerlink" title="七、虚拟DOM"></a>七、虚拟DOM</h2><h3 id="1-对虚拟DOM的理解？"><a href="#1-对虚拟DOM的理解？" class="headerlink" title="1. 对虚拟DOM的理解？"></a>1. 对虚拟DOM的理解？</h3><p>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p>
<p>虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p>
<p>另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。</p>
<h3 id="2-虚拟DOM的解析过程"><a href="#2-虚拟DOM的解析过程" class="headerlink" title="2. 虚拟DOM的解析过程"></a>2. 虚拟DOM的解析过程</h3><p>虚拟DOM的解析过程：</p>
<ul>
<li>  首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</li>
<li>  当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</li>
<li>  最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</li>
</ul>
<h3 id="3-为什么要用虚拟DOM"><a href="#3-为什么要用虚拟DOM" class="headerlink" title="3. 为什么要用虚拟DOM"></a>3. 为什么要用虚拟DOM</h3><ol>
<li><p><strong>保证性能下限，在不进行手动优化的情况下，提供过得去的性能</strong> 看一下页面渲染的流程：<strong>解析HTML -&gt; 生成DOM -&gt; 生成 CSSOM -&gt; Layout -&gt; Paint -&gt; Compiler</strong> 下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶</p>
<ul>
<li>  真实DOM∶ 生成HTML字符串＋重建所有的DOM元素</li>
<li>  虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新</li>
</ul>
<p> Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。 </p>
</li>
<li><p> <strong>跨平台</strong> Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</p>
</li>
</ol>
<h3 id="4-虚拟DOM真的比真实DOM性能好吗"><a href="#4-虚拟DOM真的比真实DOM性能好吗" class="headerlink" title="4. 虚拟DOM真的比真实DOM性能好吗"></a>4. 虚拟DOM真的比真实DOM性能好吗</h3><ul>
<li>  首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</li>
<li>  正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。</li>
</ul>
<h3 id="5-DIFF算法的原理"><a href="#5-DIFF算法的原理" class="headerlink" title="5. DIFF算法的原理"></a>5. DIFF算法的原理</h3><p>在新老虚拟DOM对比时：</p>
<ul>
<li>  首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li>
<li>  如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li>
<li>  比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li>
<li>  匹配时，找到相同的子节点，递归比较子节点</li>
</ul>
<p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p>
<h3 id="6-Vue-中-key-的作用"><a href="#6-Vue-中-key-的作用" class="headerlink" title="6. Vue 中 key 的作用"></a>6. Vue 中 key 的作用</h3><p>vue 中 key 值的作用可以分为两种情况来考虑：</p>
<ul>
<li>  第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li>
<li>  第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li>
</ul>
<p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</p>
<ul>
<li>  更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。</li>
<li>  更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li>
</ul>
<h3 id="7-为什么不建议用-index-作为-key"><a href="#7-为什么不建议用-index-作为-key" class="headerlink" title="7. 为什么不建议用 index 作为 key ?"></a>7. 为什么不建议用 index 作为 key ?</h3><p>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript面试题</title>
    <url>/2021/12/06/javascript/</url>
    <content><![CDATA[<p>绝大部分内容来自：<a href="https://juejin.cn/user/3544481220801815">https://juejin.cn/user/3544481220801815</a></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2021/12/06/javascript/03.JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="03.JavaScript面试题"></p>
<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p>
<p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p>
<ul>
<li>  Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li>  BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li>
</ul>
<p>这些数据可以分为原始数据类型和引用数据类型：</p>
<ul>
<li>  栈：原始数据类型（Undefined、Null、Boolean、Number、String、BigInt）</li>
<li>  堆：引用数据类型（对象、数组和函数）</li>
</ul>
<p>两种类型的区别在于<strong>存储位置的不同：</strong></p>
<ul>
<li>  原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>  引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p>
<ul>
<li>  在数据结构中，栈中数据的存取方式为先进后出。</li>
<li>  堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li>
</ul>
<p>在操作系统中，内存被分为栈区和堆区：</p>
<ul>
<li>  栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li>  堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li>
</ul>
<h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><ol>
<li><p>typeof</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p> 其中数组、对象、null都会被判断为object，其它判断都正确。</p>
</li>
<li><p>instanceof</p>
<p> <code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> 可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p>
</li>
<li><p>constructor</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> <code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>Object.prototype.toString.call()</p>
<p> <code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="number">2</span>));  <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">true</span>));  <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="string">&#x27;str&#x27;</span>));  <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call([]));  <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));  <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(&#123;&#125;));  <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">undefined</span>));  <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">null</span>));  <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<p> 同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p>
<p> 这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p>
</li>
</ol>
<h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><ol>
<li><p>通过Object.prototype.toString.call()做判断</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>通过原型链做判断</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.__proto__ === <span class="built_in">Array</span>.prototype;</span><br></pre></td></tr></table></figure></li>
<li><p>通过ES6的Array.isArray()做判断</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArrray(obj);</span><br></pre></td></tr></table></figure></li>
<li><p>通过instanceof做判断</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过Array.prototype.isPrototypeOf</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(obj)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>参考：<a href="https://juejin.cn/post/6844903777506426893">https://juejin.cn/post/6844903777506426893</a></p>
<p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p>
<p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p>
<p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p>
<p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p>
<h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。<a href="https://juejin.cn/post/6844903895177805837">https://juejin.cn/post/6844903895177805837</a></p>
<p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">000</span>: object   - 当前存储的数据指向一个对象。  <span class="number">1</span>: int      - 当前存储的数据是一个 <span class="number">31</span> 位的有符号整数。<span class="number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。<span class="number">100</span>: string   - 当前存储的数据指向一个字符串。<span class="number">110</span>: boolean  - 当前存储的数据是布尔值。</span><br></pre></td></tr></table></figure>

<p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p>
<p>有两种特殊数据类型：</p>
<ul>
<li>  undefined的值是 $-2^{31}$(一个超出整数范围的数字，即全为1)；</li>
<li>  null 的值是机器码 NULL 指针(null 指针的值全是 0)</li>
</ul>
<p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p>
<h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;  <span class="comment">// 获取对象的原型  let proto = Object.getPrototypeOf(left)  // 获取构造函数的 prototype 对象  let prototype = right.prototype;    // 判断构造函数的 prototype 对象是否在对象的原型链上  while (true) &#123;    if (!proto) return false;    if (proto === prototype) return true;    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型    proto = Object.getPrototypeOf(proto);  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-为什么0-1-0-2-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! == 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! == 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">0.1</span>, n2 = <span class="number">0.</span>2<span class="built_in">console</span>.log(n1 + n2)  <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure>

<p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(n1 + n2).toFixed(<span class="number">2</span>) <span class="comment">// 注意，toFixed为四舍五入</span></span><br></pre></td></tr></table></figure>

<p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p>
<p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p>
<p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p>
<p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p>
<p>下面看一下<strong>双精度数是如何保存</strong>的： <img src="/2021/12/06/javascript/03-1-7.png" alt="img"></p>
<ul>
<li>  第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li>
<li>  第二部分（绿色）：用来存储指数（exponent），占用11位</li>
<li>  第三部分（红色）：用来存储小数（fraction），占用52位</li>
</ul>
<p>对于0.1，它的二进制为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="number">10011.</span>..</span><br></pre></td></tr></table></figure>

<p>转为科学计数法（科学计数法的结果就是浮点数）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="number">2</span>^-<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure>

<p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p>
<p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p>
<ul>
<li>  当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li>
<li>  当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。</li>
<li>  当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。</li>
</ul>
<p>对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.</p>
<p>所以，0.1表示为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1111111011</span> <span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure>

<p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？</p>
<p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为$2^{-52}$，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是$2^{-52}$，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberepsilon</span>(<span class="params">arg1,arg2</span>)</span>&#123;                     <span class="keyword">return</span> <span class="built_in">Math</span>.abs(arg1 - arg2) &lt; <span class="built_in">Number</span>.EPSILON;        &#125;        <span class="built_in">console</span>.log(numberepsilon(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p>
<h3 id="9-typeof-NaN-的结果是什么？"><a href="#9-typeof-NaN-的结果是什么？" class="headerlink" title="9. typeof NaN 的结果是什么？"></a>9. typeof NaN 的结果是什么？</h3><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// &quot;number&quot;</span></span><br></pre></td></tr></table></figure>

<p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。</p>
<h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3><ul>
<li>  函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li>
<li>  函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li>
</ul>
<h3 id="11-操作符的强制类型转换规则？"><a href="#11-操作符的强制类型转换规则？" class="headerlink" title="11. == 操作符的强制类型转换规则？"></a>11. == 操作符的强制类型转换规则？</h3><p>参考：<a href="https://juejin.cn/post/6844903793893572622#heading-5">https://juejin.cn/post/6844903793893572622#heading-5</a></p>
<ol>
<li> 如果类型相同，调用 <code>===</code> 操作符</li>
<li>如果类型不同，尝试类型转换<ol>
<li>查看是否是 <code>undefined</code> 和 <code>null</code> 比较<ul>
<li>  ✅ 返回 <code>true</code></li>
<li>  ⬇️ 如果不是继续下一条规则</li>
</ul>
</li>
<li>是否在比较 <code>string</code> 和 <code>number</code><ul>
<li>  ✅ 如果是，那么将 <code>string</code> 转为 <code>number</code> 并回到最初重新比较 ♻️</li>
<li>  ⬇️ 如果不是继续下一条规则</li>
</ul>
</li>
<li>查看我们比较的项中是否有 <code>boolean</code><ul>
<li>  ✅ 如果有，那么将 <code>boolean</code> 转为 <code>number</code> 并回到最初重新比较 ♻️</li>
<li>  ⬇️ 如果不是继续下一条规则</li>
</ul>
</li>
<li>查看是否有一项是 <code>object</code><ul>
<li>  ✅ 如果有，那么将 <code>object</code> 转为其原始值 <code>primitive</code> 并回到最初重新比较 ♻️</li>
<li>  ❌ 如果还不是，只能返回 <code>false</code> 了</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><img src="/2021/12/06/javascript/03-1-11.webp"></p>
<p>那么怎么获取对象原始值的呢：</p>
<blockquote>
<p>  我们需要知道转换类型的这个方法在 JS 源代码中是 <code>ToPrimitive</code> 这个方法，该方法有一个可选参数 <code>PreferredType</code>，这个参数的作用是指定期望类型；如果第一个参数对应的对象可以被转换为不止一种类型，那么后者可以作为一种暗示，表示该对象应该转换为那种类型</p>
</blockquote>
<ol>
<li>默认情况下（期望类型默认为 <code>number</code>）<ul>
<li>调用 <code>valueOf</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ⬇️ 如果返回的不是原始值，那么跳到下一步</li>
</ul>
</li>
<li>调用 <code>toString</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ❌ 否则报错💩</li>
</ul>
</li>
</ul>
</li>
<li>如果期望类型为 <code>string</code>：<ol>
<li>调用 <code>toString</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ⬇️ 如果返回的不是原始值，那么跳到下一步</li>
</ul>
</li>
<li>调用 <code>valueOf</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ❌ 否则报错💩</li>
</ul>
</li>
</ol>
</li>
<li>如果对象是 Date 类型（期望类型为 <code>string</code>）：<ol>
<li>调用 <code>toString</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ⬇️ 如果返回的不是原始值，那么跳到下一步</li>
</ul>
</li>
<li>调用 <code>valueOf</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ❌ 否则报错💩</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>例子：</p>
<ol>
<li> 普通的对象，首先调用 valueOf 方法，返回的结果并非原始值，那么会调用 toString 方法<img src="/2021/12/06/javascript/03--1-11-2.webp"></li>
<li> 假设我们重写 valueOf 方法，valueOf 和 toString 同时返回 string 原始值。使用 == 操作符可以看出，对象还是优先使用了 valueOf 方法返回的值<img src="/2021/12/06/javascript/03--1-11-3.webp"></li>
<li> 数组同理，首先默认调用 valueOf 方法，如不是原始值，则调用 toString 方法<img src="/2021/12/06/javascript/03--1-11-4.webp"></li>
<li> 再看看 Date 类型，他的期望类型是 string 因此首先调用的是 toString 方法，该方法返回一个原始值，那么就是用这个原始值<img src="/2021/12/06/javascript/03--1-11-5.webp"></li>
</ol>
<h3 id="12-其他值到字符串的转换规则？"><a href="#12-其他值到字符串的转换规则？" class="headerlink" title="12. 其他值到字符串的转换规则？"></a>12. 其他值到字符串的转换规则？</h3><ul>
<li>  Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li>
<li>  Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li>
<li>  Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li>
<li>  Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li>
<li>  对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li>
</ul>
<h3 id="13-其他值到数字值的转换规则？"><a href="#13-其他值到数字值的转换规则？" class="headerlink" title="13. 其他值到数字值的转换规则？"></a>13. 其他值到数字值的转换规则？</h3><ul>
<li>  Undefined 类型的值转换为 NaN。</li>
<li>  Null 类型的值转换为 0。</li>
<li>  Boolean 类型的值，true 转换为 1，false 转换为 0。</li>
<li>  String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li>
<li>  Symbol 类型的值不能转换为数字，会报错。</li>
<li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。<ul>
<li>  为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</li>
<li>  如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</li>
</ul>
</li>
</ul>
<h3 id="14-其他值到布尔类型的值的转换规则？"><a href="#14-其他值到布尔类型的值的转换规则？" class="headerlink" title="14. 其他值到布尔类型的值的转换规则？"></a>14. 其他值到布尔类型的值的转换规则？</h3><p>以下这些是假值：</p>
<ul>
<li>  undefined</li>
<li>  null</li>
<li>  false</li>
<li>  +0、-0 </li>
<li>  NaN </li>
<li>  “”</li>
</ul>
<p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p>
<h3 id="15-和-amp-amp-操作符的返回值？"><a href="#15-和-amp-amp-操作符的返回值？" class="headerlink" title="15. || 和 &amp;&amp; 操作符的返回值？"></a>15. || 和 &amp;&amp; 操作符的返回值？</h3><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p>
<ul>
<li>  对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li>
<li>  &amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li>
</ul>
<p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p>
<h3 id="16-Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#16-Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="16. Object.is() 与比较操作符 “===”、“==” 的区别？"></a>16. Object.is() 与比较操作符 “===”、“==” 的区别？</h3><ul>
<li><p>  使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</p>
</li>
<li><p>  使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</p>
</li>
<li><p>  使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</p>
</li>
</ul>
<p>参考MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness</a></p>
<table>
<thead>
<tr>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">==</th>
<th align="center">===</th>
<th align="center">Object.is</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>undefined</code></td>
<td align="center"><code>undefined</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>null</code></td>
<td align="center"><code>null</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>true</code></td>
<td align="center"><code>true</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>&quot;foo&quot;</code></td>
<td align="center"><code>&quot;foo&quot;</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center"><code>0</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>+0</code></td>
<td align="center"><code>-0</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center"><code>false</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&quot;&quot;</code></td>
<td align="center"><code>false</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&quot;&quot;</code></td>
<td align="center"><code>0</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&quot;0&quot;</code></td>
<td align="center"><code>0</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&quot;17&quot;</code></td>
<td align="center"><code>17</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>[1,2]</code></td>
<td align="center"><code>&quot;1,2&quot;</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>new String(&quot;foo&quot;)</code></td>
<td align="center"><code>&quot;foo&quot;</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>null</code></td>
<td align="center"><code>undefined</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>null</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>undefined</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&#123; foo: &quot;bar&quot; &#125;</code></td>
<td align="center"><code>&#123; foo: &quot;bar&quot; &#125;</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>new String(&quot;foo&quot;)</code></td>
<td align="center"><code>new String(&quot;foo&quot;)</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center"><code>null</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center"><code>NaN</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&quot;foo&quot;</code></td>
<td align="center"><code>NaN</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>NaN</code></td>
<td align="center"><code>NaN</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center">true</td>
</tr>
</tbody></table>
<h3 id="17-什么是-JavaScript-中的包装类型？"><a href="#17-什么是-JavaScript-中的包装类型？" class="headerlink" title="17. 什么是 JavaScript 中的包装类型？"></a>17. 什么是 JavaScript 中的包装类型？</h3><p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&quot;abc&quot;</span>;a.length; <span class="comment">// 3a.toUpperCase(); // &quot;ABC&quot;复制代码</span></span><br></pre></td></tr></table></figure>

<p>在访问<code>&#39;abc&#39;.length</code>时，JavaScript 将<code>&#39;abc&#39;</code>在后台转换成<code>String(&#39;abc&#39;)</code>，然后再访问其<code>length</code>属性。</p>
<p>JavaScript也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span><span class="built_in">Object</span>(a) <span class="comment">// String &#123;&quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span><span class="keyword">var</span> b = <span class="built_in">Object</span>(a)<span class="keyword">var</span> c = b.valueOf() <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>看看如下代码会打印出什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> );<span class="keyword">if</span> (!a) &#123;	<span class="built_in">console</span>.log( <span class="string">&quot;Oops&quot;</span> ); <span class="comment">// never runs&#125;</span></span><br></pre></td></tr></table></figure>

<p>答案是什么都不会打印，因为虽然包裹的基本类型是<code>false</code>，但是<code>false</code>被包裹成包装类型后就成了对象，所以其非值为<code>false</code>，所以循环体中的内容不会运行。</p>
<h3 id="18-JavaScript-中如何进行隐式类型转换？"><a href="#18-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="18. JavaScript 中如何进行隐式类型转换？"></a>18. JavaScript 中如何进行隐式类型转换？</h3><blockquote>
<p>  [] + {}  // [object Object]</p>
<p>  {} + []  // 0</p>
</blockquote>
<p> 参考：<a href="https://juejin.cn/post/6844903632974905358#heading-1%EF%BC%88%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E3%80%8B%E4%B8%AD%E5%8D%B7%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%89">https://juejin.cn/post/6844903632974905358#heading-1（《你不知道的JS》中卷第四章）</a></p>
<p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** <span class="doctag">@obj </span>需要转换的对象* <span class="doctag">@type </span>期望的结果类型*/</span>ToPrimitive(obj,type)</span><br></pre></td></tr></table></figure>

<p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p>
<ol>
<li><strong>当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong><ul>
<li>  调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li>
<li>  调用<code>obj</code>的<code>toString</code>方法，后续同上；</li>
<li>  抛出<code>TypeError</code> 异常。</li>
</ul>
</li>
<li><strong>当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong><ul>
<li>  调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li>
<li>  调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li>
<li>  抛出<code>TypeError</code> 异常。</li>
</ul>
</li>
</ol>
<p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p>
<ul>
<li>  如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li>
<li>  其他情况下，<code>type</code>默认为<code>number</code>。</li>
</ul>
<p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objToNumber = <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">Number</span>(value.valueOf().toString())objToNumber([]) === 0objToNumber(&#123;&#125;) === <span class="literal">NaN</span></span><br></pre></td></tr></table></figure>

<p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p>
<p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p>
<ol>
<li><p><code>+</code><strong>操作符</strong></p>
<p> <code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;23&#x27;</span> <span class="comment">// &#x27;123&#x27; 1 + false // 1  1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number &#x27;1&#x27; + false // &#x27;1false&#x27; false + true // 1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>-</code>、<code>*</code>、<code>\</code><strong>操作符</strong></p>
<p> <code>NaN</code>也是一个数字</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="string">&#x27;23&#x27;</span> <span class="comment">// 23 1 * false // 0 1 / &#x27;aa&#x27; // NaN</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对于</strong><code>==</code><strong>操作符</strong></p>
<p> 操作符两边的值都尽量转成<code>number</code>：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> == <span class="literal">true</span> <span class="comment">// false, 3 转为number为3，true转为number为1&#x27;0&#x27; == false //true, &#x27;0&#x27;转为number为0，false转为number为0&#x27;0&#x27; == 0 // &#x27;0&#x27;转为number为0</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对于</strong><code>&lt;</code><strong>和</strong><code>&gt;</code><strong>比较符</strong></p>
<p> 如果两边都是字符串，则比较字母表顺序：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;ca&#x27;</span> &lt; <span class="string">&#x27;bd&#x27;</span> <span class="comment">// false&#x27;a&#x27; &lt; &#x27;b&#x27; // true</span></span><br></pre></td></tr></table></figure>

<p> 其他情况下，转换为数字再比较：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span> &lt; <span class="number">13</span> <span class="comment">// truefalse &gt; -1 // true</span></span><br></pre></td></tr></table></figure>

<p> 以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;a &gt; <span class="number">2</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p> 其对比过程如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.valueOf() <span class="comment">// &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步a.toString() // &quot;[object Object]&quot;，现在是一个字符串了Number(a.toString()) // NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字NaN &gt; 2 //false，得出比较结果</span></span><br></pre></td></tr></table></figure>

<p> 又比如：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;<span class="keyword">var</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;a + b <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p> 运算过程如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.valueOf() <span class="comment">// &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步a.toString() // &quot;[object Object]&quot;b.valueOf() // 同理b.toString() // &quot;[object Object]&quot;a + b // &quot;[object Object][object Object]&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="19-操作符什么时候用于字符串的拼接？"><a href="#19-操作符什么时候用于字符串的拼接？" class="headerlink" title="19. +操作符什么时候用于字符串的拼接？"></a>19. +操作符什么时候用于字符串的拼接？</h3><p>参考：<a href="https://juejin.cn/post/6844904038400540680#comment">https://juejin.cn/post/6844904038400540680#comment</a></p>
<p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p>
<p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p>
<p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p>
<h3 id="20-为什么会有BigInt的提案？"><a href="#20-为什么会有BigInt的提案？" class="headerlink" title="20. 为什么会有BigInt的提案？"></a>20. 为什么会有BigInt的提案？</h3><p>参考：<a href="https://juejin.cn/post/6844903902295359502">https://juejin.cn/post/6844903902295359502</a></p>
<p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。</p>
<h3 id="21-object-assign和扩展运算符是深拷贝还是浅拷贝，两者区别"><a href="#21-object-assign和扩展运算符是深拷贝还是浅拷贝，两者区别" class="headerlink" title="21. object.assign和扩展运算符是深拷贝还是浅拷贝，两者区别"></a>21. object.assign和扩展运算符是深拷贝还是浅拷贝，两者区别</h3><p>扩展运算符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> outObj = &#123;  <span class="attr">inObj</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;&#125;<span class="keyword">let</span> newObj = &#123;...outObj&#125;newObj.inObj.a = 2<span class="built_in">console</span>.log(outObj) <span class="comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>Object.assign():</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> outObj = &#123;  <span class="attr">inObj</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;&#125;<span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, outObj)newObj.inObj.a = 2<span class="built_in">console</span>.log(outObj) <span class="comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，两者都是浅拷贝。</p>
<ul>
<li>  Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</li>
<li>  扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</li>
</ul>
<p>深拷贝与浅拷贝的区别：</p>
<ul>
<li>  <code>浅拷贝</code>，只拷贝第一层的原始类型值，和第一层的引用类型地址。</li>
<li>  <code>深拷贝</code>，拷贝所有的属性值，以及属性地址指向的值的内存空间。通过递归调用，或者 JSON 来做深拷贝，都会有一些问题。而 cloneForce 方法倒是目前看来最完美的解决方案了。</li>
</ul>
<h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><p><strong>（1）块级作用域：</strong> 块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p>
<ul>
<li>  内层变量可能覆盖外层变量</li>
<li>  用来计数的循环变量泄露为全局变量</li>
</ul>
<p><strong>（2）变量提升：</strong> var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>
<p><strong>（3）给全局添加属性：</strong> 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p>
<p><strong>（4）重复声明：</strong> var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p>
<p><strong>（5）暂时性死区：</strong> 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p>
<p><strong>（6）初始值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p>
<p><strong>（7）指针指向：</strong> let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p>
<table>
<thead>
<tr>
<th align="center"><strong>区别</strong></th>
<th align="center"><strong>var</strong></th>
<th align="center"><strong>let</strong></th>
<th align="center"><strong>const</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否有块级作用域</td>
<td align="center">×</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">是否存在变量提升</td>
<td align="center">✔</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">是否添加全局属性</td>
<td align="center">✔</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">能否重复声明变量</td>
<td align="center">✔</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">是否存在暂时性死区</td>
<td align="center">×</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">是否必须设置初始值</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">能否改变指针指向</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p>
<p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<p>如果不想让内部数据改动，可以使用 Object.freeze() 方法。注：Object.freeze() 会对最近一层的对象进行冻结，并不会对深层对象进行冻结。</p>
<h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p>
<p>new操作符的实现步骤如下：</p>
<ol>
<li> 创建一个对象</li>
<li> 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</li>
<li> 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li>
<li> 返回新的对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">constructor, ...args</span>) </span>&#123;  <span class="keyword">let</span> obj = &#123;&#125;  <span class="built_in">Object</span>.setPrototypeOf(obj, <span class="title">constructor</span>.<span class="title">prototype</span>)  <span class="title">let</span> <span class="title">result</span> = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">obj, args</span>)  <span class="title">return</span> <span class="title">result</span> <span class="title">instanceof</span> <span class="title">Object</span> ? <span class="title">result</span> : <span class="title">obj</span>&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> 首先函数接受不定量的参数，第一个参数为构造函数，接下来的参数被构造函数使用</li>
<li> 然后内部创建一个空对象 <code>obj</code></li>
<li> 因为 <code>obj</code> 对象需要访问到构造函数原型链上的属性，所以我们通过 <code>setPrototypeOf</code> 将两者联系起来。这段代码等同于 <code>obj.__proto__ = Con.prototype</code></li>
<li> 将 <code>obj</code> 绑定到构造函数上，并且传入剩余的参数</li>
<li> 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 <code>obj</code>，这样就实现了忽略构造函数返回的原始值</li>
</ol>
<h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><ol>
<li><p>箭头函数比普通函数更加简洁</p>
<ul>
<li><p>  如果没有参数，就直接写一个空括号即可</p>
</li>
<li><p>  如果只有一个参数，可以省去参数的括号</p>
</li>
<li><p>  如果有多个参数，用逗号分割</p>
</li>
<li><p>  如果函数体的返回值只有一句，可以省略大括号</p>
</li>
<li><p>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>箭头函数没有自己的this</p>
<p> 箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p>
</li>
<li><p>箭头函数继承来的this指向永远不会改变</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;<span class="keyword">var</span> obj = &#123;  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,  <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);  &#125;,  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);  &#125;&#125;;obj.a();    <span class="comment">// &#x27;OBJ&#x27;obj.b();    // &#x27;GLOBAL&#x27;new obj.a()  // undefinednew obj.b()  // Uncaught TypeError: obj.b is not a constructor</span></span><br></pre></td></tr></table></figure>

<p> 对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>
</li>
<li><p>call()、apply()、bind()等方法不能改变箭头函数中this的指向</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;<span class="keyword">let</span> fun1 = <span class="function">() =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)&#125;;fun1();                     <span class="comment">// &#x27;Global&#x27;fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27;fun1.apply(&#123;id: &#x27;Obj&#x27;&#125;);    // &#x27;Global&#x27;fun1.bind(&#123;id: &#x27;Obj&#x27;&#125;)();   // &#x27;Global&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数不能作为构造函数使用</p>
<p> 构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p>
</li>
<li><p>箭头函数没有自己的arguments</p>
<p> 箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p>
</li>
<li><p> 箭头函数没有prototype</p>
</li>
<li><p> 箭头函数不能用作Generator函数，不能使用yeild关键字</p>
</li>
</ol>
<h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的this指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p>
<p>可以⽤Babel理解⼀下箭头函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 const obj = &#123;   getArrow() &#123;     return () =&gt; &#123;       console.log(this === obj);     &#125;;   &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>转化后：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5，由 Babel 转译var obj = &#123;    getArrow: function getArrow() &#123;      var _this = this;      return function () &#123;         console.log(_this === obj);      &#125;;    &#125; &#125;;</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://juejin.cn/post/6844903746984476686#heading-3">https://juejin.cn/post/6844903746984476686#heading-3</a></p>
<h3 id="6-扩展运算符的作用及使用场景"><a href="#6-扩展运算符的作用及使用场景" class="headerlink" title="6. 扩展运算符的作用及使用场景"></a>6. 扩展运算符的作用及使用场景</h3><ol>
<li><p>对象扩展运算符</p>
<p> 对象的扩展运算符（…）用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;<span class="keyword">let</span> baz = &#123; ...bar &#125;; <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p> 上述方法等价于：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;<span class="keyword">let</span> baz = <span class="built_in">Object</span>.assign(&#123;&#125;, bar); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p> <code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p>
<p> 同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;<span class="keyword">let</span> baz = &#123;...bar, ...&#123;<span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;&#125;;  <span class="comment">// &#123;a: 2, b: 4&#125;</span></span><br></pre></td></tr></table></figure>

<p> 利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p>
<p> 需要注意：<strong>扩展运算符对对象实例的拷贝属于浅拷贝</strong>。</p>
</li>
<li><p>数组扩展运算符</p>
<p> 数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])<span class="comment">// 1 2 3console.log(...[1, [2, 3, 4], 5])// 1 [2, 3, 4] 5</span></span><br></pre></td></tr></table></figure>

<p> 下面是数组的扩展运算符的应用：</p>
<ul>
<li><p>将数组转换为参数序列</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;  <span class="keyword">return</span> x + y;&#125;<span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>];add(...numbers) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li><p>复制数组</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];<span class="keyword">const</span> arr2 = [...arr1];</span><br></pre></td></tr></table></figure>

<p>  要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p>
</li>
<li><p>合并数组</p>
<p>  如果想在数组内合并数组，可以这样：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];<span class="keyword">const</span> arr2 = [<span class="string">&#x27;one&#x27;</span>, ...arr1, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>];<span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>扩展运算符和解构赋值结合起来，用于生成数组</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];      <span class="comment">// first  1rest  // [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>  需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [...rest, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];         <span class="comment">// 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错</span></span><br></pre></td></tr></table></figure></li>
<li><p>将字符串转为真正的数组</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]    <span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure></li>
<li><p>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</p>
<p>  比较常见的应用是可以将某些数据结构转为数组：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments对象function foo() &#123;  const args = [...arguments];&#125;</span></span><br></pre></td></tr></table></figure>

<p>  用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p>
</li>
<li><p>使用 Math 函数获取数组中特定的值</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>];<span class="built_in">Math</span>.min(...numbers); <span class="comment">// 1Math.max(...numbers); // 9</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="7-Proxy-可以实现什么功能？"><a href="#7-Proxy-可以实现什么功能？" class="headerlink" title="7. Proxy 可以实现什么功能？"></a>7. Proxy 可以实现什么功能？</h3><p>在 Vue3.0 中通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</p>
<p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)复制代码</span><br></pre></td></tr></table></figure>

<p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p>
<p>下面来通过 <code>Proxy</code> 来实现一个数据响应式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;  <span class="keyword">let</span> handler = &#123;    <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;      getLogger(target, property)      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)    &#125;,    <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;      setBind(value, property)      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)    &#125;  &#125;  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)&#125;<span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;<span class="keyword">let</span> p = onWatch(  obj,  <span class="function">(<span class="params">v, property</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">`监听到属性<span class="subst">$&#123;property&#125;</span>改变为<span class="subst">$&#123;v&#125;</span>`</span>)  &#125;,  <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">`&#x27;<span class="subst">$&#123;property&#125;</span>&#x27; = <span class="subst">$&#123;target[property]&#125;</span>`</span>)  &#125;)p.a = <span class="number">2</span> <span class="comment">// 监听到属性a改变p.a // &#x27;a&#x27; = 2</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，通过自定义 <code>set</code> 和 <code>get</code> 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p>
<p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 <code>get</code> 中收集依赖，在 <code>set</code> 派发更新，之所以 Vue3.0 要使用 <code>Proxy</code> 替换原本的 API 原因在于 <code>Proxy</code> 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 <code>Proxy</code> 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p>
<p><strong>常用拦截方法</strong>：</p>
<table>
<thead>
<tr>
<th align="center">拦截器</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get</td>
<td align="center">拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">拦截对象属性的设置，返回一个布尔值，比如 proxy.foo = v 或 proxy[‘foo’] = v</td>
</tr>
<tr>
<td align="center">has</td>
<td align="center">拦截 propKey in proxy 的操作，返回一个布尔值</td>
</tr>
<tr>
<td align="center">ownKeys</td>
<td align="center">拦截 Object.getOwnPropertyNames(proxy) 、Object.getOwnPropertySymbols(proxy) 、Object.keys(proxy) 、for…in 循环，返回一个数组</td>
</tr>
<tr>
<td align="center">deleteProperty</td>
<td align="center">拦截 delete proxy[propKey] 的操作，返回一个布尔值</td>
</tr>
<tr>
<td align="center">apply</td>
<td align="center">拦截函数的调用、call 和 apply 操作</td>
</tr>
<tr>
<td align="center">construct</td>
<td align="center">拦截 new 命令，返回一个对象</td>
</tr>
</tbody></table>
<h3 id="8-对对象与数组的解构的理解"><a href="#8-对对象与数组的解构的理解" class="headerlink" title="8. 对对象与数组的解构的理解"></a>8. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。</p>
<ol>
<li><p>数组的解构：在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p> 最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：  数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p> 通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量</p>
</li>
<li><p>对象的解构：对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stu = &#123;  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,  <span class="attr">age</span>: <span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure>

<p> 假如想要解构它的两个自有属性，可以这样：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = stu</span><br></pre></td></tr></table></figure>

<p> 这样就得到了 name 和 age 两个和 stu 平级的变量</p>
<p> 注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; age, name &#125; = stu</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-如何提取高度嵌套的对象里的指定属性？"><a href="#9-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="9. 如何提取高度嵌套的对象里的指定属性？"></a>9. 如何提取高度嵌套的对象里的指定属性？</h3><p>有时会遇到一些嵌套程度非常深的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;   <span class="attr">classes</span>: &#123;      <span class="attr">stu</span>: &#123;         <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,         <span class="attr">age</span>: <span class="number">24</span>,      &#125;   &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name &#125; = school</span><br></pre></td></tr></table></figure>

<p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; classes &#125; = schoolconst &#123; stu &#125; = classesconst &#123; name &#125; = stuname <span class="comment">// &#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">classes</span>: &#123; <span class="attr">stu</span>: &#123; name &#125; &#125;&#125; = school       <span class="built_in">console</span>.log(name)  <span class="comment">// &#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p>
<h3 id="10-对-rest-参数的理解"><a href="#10-对-rest-参数的理解" class="headerlink" title="10. 对 rest 参数的理解"></a>10. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>(<span class="params">...args</span>) </span>&#123;  <span class="keyword">let</span> result = <span class="number">1</span>;  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> args) &#123;    result *= val;  &#125;  <span class="keyword">return</span> result;&#125;mutiple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>(<span class="params">...args</span>) </span>&#123;  <span class="built_in">console</span>.log(args)&#125;mutiple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p>
<h3 id="11-ES6中模板语法与字符串处理"><a href="#11-ES6中模板语法与字符串处理" class="headerlink" title="11. ES6中模板语法与字符串处理"></a>11. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   <span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> <span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]<span class="keyword">var</span> finalString = <span class="string">&#x27;my name is &#x27;</span> + name + <span class="string">&#x27;, I work as a &#x27;</span> + career + <span class="string">&#x27;, I love &#x27;</span> + hobby[<span class="number">0</span>] + <span class="string">&#x27; and &#x27;</span> + hobby[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   <span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> <span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]<span class="keyword">var</span> finalString = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, I work as a <span class="subst">$&#123;career&#125;</span> I love <span class="subst">$&#123;hobby[<span class="number">0</span>]&#125;</span> and <span class="subst">$&#123;hobby[<span class="number">1</span>]&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p>
<ul>
<li>  在模板字符串中，空格、缩进、换行都会被保留</li>
<li>  模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li>
</ul>
<p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="string">`	&lt;ul&gt;		&lt;li&gt;列表项1&lt;/li&gt;		&lt;li&gt;列表项2&lt;/li&gt;	&lt;/ul&gt;`</span>;<span class="built_in">console</span>.log(message); <span class="comment">// 正确输出，不存在报错</span></span><br></pre></td></tr></table></figure>

<p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;  <span class="keyword">const</span> finalString = <span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a+b&#125;</span>`</span>  <span class="built_in">console</span>.log(finalString)&#125;add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 输出 &#x27;1 + 2 = 3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p>
<ol>
<li><p><strong>存在性判定</strong>：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p>
<ul>
<li>  <strong>includes</strong>：判断字符串与子串的包含关系：</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> son = <span class="string">&#x27;haha&#x27;</span> <span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span>father.includes(son) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>startsWith</strong>：判断字符串是否以某个/某串字符开头：</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span>father.startsWith(<span class="string">&#x27;haha&#x27;</span>) <span class="comment">// falsefather.startsWith(&#x27;xixi&#x27;) // true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>endsWith</strong>：判断字符串是否以某个/某串字符结尾：</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span>  father.endsWith(<span class="string">&#x27;hehe&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceCode = <span class="string">&#x27;repeat for 3 times;&#x27;</span><span class="keyword">const</span> repeated = sourceCode.repeat(<span class="number">3</span>) <span class="built_in">console</span>.log(repeated) <span class="comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p>
<p>（1）首先创建了一个新的空对象</p>
<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p>
<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>
<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<p>具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title">constructor</span> = <span class="title">Array</span>.<span class="title">prototype</span>.<span class="title">shift</span>.<span class="title">call</span>(<span class="params"><span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title">constructor</span> !== &quot;<span class="title">function</span>&quot;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="built_in">Object</span>.create(<span class="title">constructor</span>.<span class="title">prototype</span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">newObject, <span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>

<h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>意外的键</td>
<td>Map 默认情况不包含任何的键</td>
<td>Object 有一个原型，原型链上的键名有可能和自己在对象上设置的键名产生冲突</td>
</tr>
<tr>
<td>键的类型</td>
<td>Map 的键可以是任意值，包括函数、对象或任意基本类型</td>
<td>Object 的键必须是 String 或是 Symbol</td>
</tr>
<tr>
<td>键的顺序</td>
<td>Map 中的 key 是有序的。因此，当迭代的时候，Map 对象以插入的顺序返回键值</td>
<td>Object 的键是无序的</td>
</tr>
<tr>
<td>Size</td>
<td>Map 的键值对个数可以轻易地通过 size 属性获取</td>
<td>Object 的键值对个数只能手动计算</td>
</tr>
<tr>
<td>迭代</td>
<td>Map 是 iterable 的，所以可以直接被迭代</td>
<td>迭代 Object 需要以某种方式获取它的键然后才能迭代</td>
</tr>
<tr>
<td>性能</td>
<td>在频繁增删键值对的场景下表现更好</td>
<td>在频繁添加和删除键值对的场景下未做出优化</td>
</tr>
</tbody></table>
<h3 id="3-map和weakMap的区别"><a href="#3-map和weakMap的区别" class="headerlink" title="3. map和weakMap的区别"></a>3. map和weakMap的区别</h3><ol>
<li><p>Map</p>
<ul>
<li><p>  map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。</p>
</li>
<li><p>Map数据结构有以下操作方法：</p>
<ul>
<li>  <strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li>
<li>  **set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li>
<li>  **get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>  **has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li>
<li>  **delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li>
<li>  **clear()**：map.clear()清除所有成员，没有返回值。</li>
</ul>
</li>
<li><p>Map结构原生提供是三个遍历器生成函数和一个遍历方法</p>
<ul>
<li>  keys()：返回键名的遍历器。</li>
<li>  values()：返回键值的遍历器。</li>
<li>  entries()：返回所有成员的遍历器。</li>
<li>  forEach()：遍历Map的所有成员。</li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">     [<span class="string">&quot;foo&quot;</span>,<span class="number">1</span>],</span><br><span class="line">     [<span class="string">&quot;bar&quot;</span>,<span class="number">2</span>],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> map.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);  <span class="comment">// foo bar</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> map.values())&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(value); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> items <span class="keyword">of</span> map.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(items);  <span class="comment">// [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span></span><br><span class="line">&#125;</span><br><span class="line">map.forEach( <span class="function">(<span class="params">value,key,map</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(key,value); <span class="comment">// foo 1    bar 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>WeakMap</p>
<ul>
<li><p>  WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。</p>
</li>
<li><p>该对象也有以下几种方法：</p>
<ul>
<li>  **set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li>
<li>  **get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>  **has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li>
<li>  **delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li>
</ul>
<p>  其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。</p>
</li>
<li><p>  WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</p>
</li>
<li><p>  而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。</p>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>  Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
<li>  WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
</li>
</ol>
<h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p>
<p><strong>标准内置对象的分类：</strong></p>
<ol>
<li> 值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</li>
<li> 函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</li>
<li> 基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</li>
<li> 数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</li>
<li> 字符串，用来表示和操作字符串的对象。例如 String、RegExp</li>
<li> 可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</li>
<li> 使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet</li>
<li> 矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等</li>
<li> 结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</li>
<li> 控制抽象对象 例如 Promise、Generator 等</li>
<li> 反射。例如 Reflect、Proxy</li>
<li> 国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</li>
<li> WebAssembly</li>
<li> 其他。例如 arguments</li>
</ol>
<p><strong>总结：</strong> js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p>
<h3 id="5-常用的正则表达式有哪些？"><a href="#5-常用的正则表达式有哪些？" class="headerlink" title="5. 常用的正则表达式有哪些？"></a>5. 常用的正则表达式有哪些？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;// （2）匹配日期，如 yyyy-mm-dd 格式var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;// （3）匹配 qq 号var regex = /^[1-9][0-9]&#123;4,10&#125;$/g;// （4）手机号码正则var regex = /^1[34578]\d&#123;9&#125;$/g;// （5）用户名正则var regex = /^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p>
<p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p>
<p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p>
<p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p>
<ul>
<li>  JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li>
<li>  JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li>
</ul>
<h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p>
<p>一般有以下几种方式：</p>
<ul>
<li>  <strong>defer 属性：</strong> 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li>
<li>  <strong>async 属性：</strong> 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li>
<li>  <strong>动态创建 DOM 方式：</strong> 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li>
<li>  <strong>使用 setTimeout 延迟方法：</strong> 设置一个定时器来延迟加载js脚本文件</li>
<li>  <strong>让 JS 最后加载：</strong> 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li>
</ul>
<h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p>
<p>常见的类数组对象转换为数组的方法有这样几种：</p>
<ol>
<li><p>通过 call 调用数组的 slice 方法来实现转换</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 call 调用数组的 splice 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 apply 调用数组的 concat 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 Array.from 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul>
<li>  数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li>
<li>  数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li>
<li>  数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li>
<li>  数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li>
<li>  数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li>
<li>  数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li>
<li>  数组归并方法 reduce() 和 reduceRight() 方法</li>
</ul>
<h3 id="10-Unicode、UTF-8、UTF-16、UTF-32的区别？"><a href="#10-Unicode、UTF-8、UTF-16、UTF-32的区别？" class="headerlink" title="10. Unicode、UTF-8、UTF-16、UTF-32的区别？"></a>10. Unicode、UTF-8、UTF-16、UTF-32的区别？</h3><ol>
<li><p>Unicode</p>
<p> 在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。</p>
<ul>
<li>  它是基于拉丁字母的一套电脑编码系统。</li>
<li>  它定义了一个用于代表常见字符的字典。</li>
<li>  它包含了”A-Z”(包含大小写)，数据”0-9” 以及一些常见的符号。</li>
<li>  它是专门为英语而设计的，有128个编码，对其他语言无能为力</li>
</ul>
<p> <code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。</p>
<p> <code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>
<p> <code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。</p>
</li>
<li><p>UTF-8</p>
<p> <code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。</p>
<p> <strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。</p>
<p> <code>UTF-8</code>的编码规则：</p>
<ul>
<li>  对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li>
<li>  对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li>
</ul>
<p> 具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：</p>
<table>
<thead>
<tr>
<th>编码范围（编号对应的十进制数）</th>
<th>二进制格式</th>
</tr>
</thead>
<tbody><tr>
<td>0x00—0x7F （0-127）</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0x80—0x7FF （128-2047）</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0x800—0xFFFF  （2048-65535）</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0x10000—0x10FFFF  （65536以上）</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p> 那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong></p>
<ul>
<li>  找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li>
<li>  将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li>
<li>  将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li>
</ul>
<p> 来看一个实际的例子： “<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code> </p>
<ol>
<li> 首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code></li>
<li> 39532对应的二进制数为<code>1001 1010 0110 1100</code> </li>
<li> 将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code></li>
</ol>
</li>
<li><p>UTF-16</p>
<ol>
<li><p>平面的概念</p>
<p> 在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念： <code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。</p>
<p> 最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 216-1</strong>，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是<strong>辅助平面</strong>，码点范围是 <code>U+10000—U+10FFFF</code>。</p>
</li>
<li><p>UTF-16 概念</p>
<p> <code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。</p>
</li>
<li><p>UTF-16 编码规则</p>
<ul>
<li>  编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li>
<li>  编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li>
</ul>
</li>
<li><p>编码识别</p>
<p> 那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？</p>
<p> <code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。</p>
<p> 辅助平面共有 <strong>220</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。</p>
<p> 因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。</p>
</li>
<li><p>举例说明</p>
<p> 以 “<strong>𡠀</strong>“ 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：</p>
<ul>
<li>  首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li>
<li>  将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li>
<li>  将得到的两个10位二进制数分别对应到两个区间中</li>
<li>  <code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li>
</ul>
</li>
</ol>
</li>
<li><p>UTF-32</p>
<p> <code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。</p>
<p> 比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。</p>
</li>
<li><p>总结</p>
<p> <strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong></p>
<ul>
<li>  <code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li>
<li>  <code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li>
<li>  <code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li>
<li>  如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间</li>
</ul>
</li>
</ol>
<h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>或</td>
</tr>
<tr>
<td><code>^</code></td>
<td>异或</td>
<td>两个位相同为0，相异为1</td>
</tr>
<tr>
<td><code>~</code></td>
<td>取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td>各二进制位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td>
</tr>
</tbody></table>
<ol>
<li><p>按位与运算符（&amp;）</p>
<p> <strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。 <strong>运算规则：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span>  <span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span>  <span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span>  <span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> 总结：两位同时为1，结果才为1，否则结果为0。 例如：3&amp;5 即：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span>    <span class="number">0000</span> <span class="number">0101</span>  = <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>

<p> 因此 3&amp;5 的值为1。 注意：负数按补码形式参加按位与运算。</p>
<p> <strong>用途：</strong></p>
<ol>
<li><p><strong>判断奇偶</strong></p>
<p> 只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p>
</li>
<li><p><strong>清零</strong></p>
<p> 如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p>
</li>
</ol>
</li>
<li><p>按位或运算符（|）</p>
<p> <strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p>
<p> <strong>运算规则：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">00</span> | <span class="number">1</span> = <span class="number">1</span>  <span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span>  <span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> 总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3|5即：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span>  <span class="number">0000</span> <span class="number">0101</span> = <span class="number">0000</span> <span class="number">0111</span></span><br></pre></td></tr></table></figure>

<p> 因此，3|5的值为7。 注意：负数按补码形式参加按位或运算。</p>
</li>
<li><p>异或运算符（^）</p>
<p> <strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p>
<p> <strong>运算规则：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span>  <span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span>  <span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span>  <span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p> 总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 例如：3|5即：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span>  <span class="number">0000</span> <span class="number">0101</span> = <span class="number">0000</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure>

<p> 因此，3^5的值为6。 异或运算的性质:</p>
<ul>
<li>  交换律：<code>(a^b)^c == a^(b^c)</code></li>
<li>  结合律：<code>(a + b)^c == a^b + b^c</code></li>
<li>  对于任何数x，都有 <code>x^x=0，x^0=x</code></li>
<li>  自反性: <code>a^b^b=a^0=a</code>;</li>
</ul>
</li>
<li><p>取反运算符 (~)</p>
<p> <strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p>
<p> <strong>运算规则：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">~ <span class="number">1</span> = <span class="number">0</span>~ <span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> 总结：对一个二进制数按位取反，即将0变1，1变0。 例如：~6 即：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span>= <span class="number">1111</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<p> 在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。 当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span>   = <span class="number">1111</span> <span class="number">1001</span>反码：<span class="number">1000</span> <span class="number">0110</span>补码：<span class="number">1000</span> <span class="number">0111</span></span><br></pre></td></tr></table></figure>

<p> 因此，~6的值为-7。</p>
</li>
<li><p>左移运算符（&lt;&lt;）</p>
<p> <strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。 设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p>
</li>
<li><p>右移运算符（&gt;&gt;）</p>
<p> <strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 操作数每右移一位，相当于该数除以2。</p>
</li>
<li><p>原码、补码、反码</p>
<p> 上面提到了补码、反码等知识，这里就补充一下。 计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p>
<p> <strong>（1）原码</strong></p>
<p> 原码就是一个数的二进制数。例如：10的原码为0000 1010</p>
<p> <strong>（2）反码</strong></p>
<ul>
<li>  正数的反码与原码相同，如：10 反码为 0000 1010</li>
<li>  负数的反码为除符号位，按位取反，即0变1，1变0。</li>
</ul>
<p> 例如：-10</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span>反码：<span class="number">1111</span> <span class="number">0101</span></span><br></pre></td></tr></table></figure>

<p> <strong>（3）补码</strong></p>
<ul>
<li>  正数的补码与原码相同，如：10 补码为 0000 1010</li>
<li>  负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li>
</ul>
<p> 例如：-10</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span>反码：<span class="number">1111</span> <span class="number">0101</span>补码：<span class="number">1111</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p>
<p>要遍历类数组，有三个方法：</p>
<ol>
<li><p>将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用Array.from方法将类数组转化成数组：‌</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">const</span> arrArgs = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>) </span><br><span class="line">  arrArgs.forEach(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用展开运算符将类数组转化成数组</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">const</span> arrArgs = [...arguments] </span><br><span class="line">    arrArgs.forEach(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul>
<li>  DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li>
<li>  BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li>
</ul>
<h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p>
<p>常见的类数组对象转换为数组的方法有这样几种：</p>
<ol>
<li><p>通过 call 调用数组的 slice 方法来实现转换</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 call 调用数组的 splice 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 apply 调用数组的 concat 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 Array.from 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="15-escape、encodeURI、encodeURIComponent-的区别"><a href="#15-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="15. escape、encodeURI、encodeURIComponent 的区别"></a>15. escape、encodeURI、encodeURIComponent 的区别</h3><ol>
<li><p>escape</p>
<p>  从名字来判断就知道，escape和后面的不是一伙的，因此不容易和后两者混淆，单独记住它就行了。</p>
<p>  简单来说，escape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。其中 ASCII字母  数字  @*/+   这几个字符不会被编码，其余的都会。最关键的是，当你需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。</p>
<p>  用MDN的话说就是：</p>
<blockquote>
<p>  escape 函数是全局对象的属性。特色字符如: @*_+-./ 被排除在外。字符的16进制格式值,当该值小于等于0xFF时,用一个2位转移序列: %xx 表示. 大于的话则使用4位序列:%uxxxx 表示.</p>
</blockquote>
</li>
<li><p>encodeURI和encodeURIComponent</p>
<p>  如果需要对整个uri编码则用encodeURI,如果对uri的部分编码则用encodeURIComponent</p>
<p>  下面来解释一下：</p>
<p>  它们都是编码URI，唯一区别就是编码的字符范围，其中encodeURI方法不会对下列字符编码：  ASCII字母，数字，~!@#$&amp;<em>()=:/,;?+’ ，encodeURIComponent方法不会对下列字符编码 ASCII字母，数字， ~!</em>()’，所以encodeURIComponent比encodeURI编码的范围更大。实际例子来说：</p>
<blockquote>
<p>  encodeURIComponent会把 http://  编码成  http%3A%2F%2F 而encodeURI却不会。</p>
</blockquote>
<p>  所以使用了encodeURIComponent编码后的地址都不能被正常访问，所以此时要用encodeURI编码，而上面时候要用到encodeURIComponent呢，知道GET和POST网络请求方法的话就好理解了，当使用GET请求时，后面需要传入parms，这里的parms也是uri的一部分，但uri对字符的输入有要求，因此要用encodeURIComponent编码后再添加到uri里面去，这样就能让浏览器正确解释出屋面想传入的params。</p>
</li>
<li><p>举例</p>
<ol>
<li><p> 如果只是编码字符串，不和URL有半毛钱关系，那么用escape。</p>
</li>
<li><p>如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。</p>
<p> 比如</p>
<p> encodeURI(“<a href="https://link.juejin.cn/?target=http://www.cnblogs.com/season-huang/some">www.cnblogs.com/season-huan…</a> other thing”);编码后会变为</p>
<p> “<a href="https://link.juejin.cn/?target=http://www.cnblogs.com/season-huang/some%20other%20thing">www.cnblogs.com/season-huan…</a>“;</p>
<p> 其中，空格被编码成了%20。但是如果你用了encodeURIComponent，那么结果变为</p>
<p> “http%3A%2F%2F<a href="http://www.cnblogs.com%2Fseason-huang%2Fsome%20other%20thing&quot;">www.cnblogs.com%2Fseason-huang%2Fsome%20other%20thing&quot;</a></p>
<p> 看到了区别吗，连 “/“ 都被编码了，整个URL已经没法用了。</p>
</li>
<li><p>当你需要编码URL中的参数的时候，那么encodeURIComponent是最好方法。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> param = <span class="string">&quot;http://www.cnblogs.com/season-huang/&quot;</span>; <span class="comment">//param为参数param = encodeURIComponent(param);var url = &quot;http://www.cnblogs.com?next=&quot; + param;console.log(url) //&quot;http://www.cnblogs.com?next=http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2F&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>创建AJAX请求的步骤：</p>
<ul>
<li>  <strong>创建一个 XMLHttpRequest 对象。</strong></li>
<li>  在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>  在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li>
<li>  当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_URL = <span class="string">&quot;/server&quot;</span>;<span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();<span class="comment">// 创建 Http 请求xhr.open(&quot;GET&quot;, url, true);// 设置状态监听函数xhr.onreadystatechange = function() &#123;  if (this.readyState !== 4) return;  // 当请求成功时  if (this.status === 200) &#123;    handle(this.response);  &#125; else &#123;    console.error(this.statusText);  &#125;&#125;;// 设置请求失败时的监听函数xhr.onerror = function() &#123;  console.error(this.statusText);&#125;;// 设置请求头信息xhr.responseType = &quot;json&quot;;xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);// 发送 Http 请求xhr.send(null);const SERVER_URL = &quot;/server&quot;;let xhr = new XMLHttpRequest();// 创建 Http 请求xhr.open(&quot;GET&quot;, url, true);// 设置状态监听函数xhr.onreadystatechange = function() &#123;  if (this.readyState !== 4) return;  // 当请求成功时  if (this.status === 200) &#123;    handle(this.response);  &#125; else &#123;    console.error(this.statusText);  &#125;&#125;;// 设置请求失败时的监听函数xhr.onerror = function() &#123;  console.error(this.statusText);&#125;;// 设置请求头信息xhr.responseType = &quot;json&quot;;xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);// 发送 Http 请求xhr.send(null);</span></span><br></pre></td></tr></table></figure>

<p>使用Promise封装AJAX：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise 封装实现：function getJSON(url) &#123;  // 创建一个 promise 对象  let promise = new Promise(function(resolve, reject) &#123;    let xhr = new XMLHttpRequest();    // 新建一个 http 请求    xhr.open(&quot;GET&quot;, url, true);    // 设置状态的监听函数    xhr.onreadystatechange = function() &#123;      if (this.readyState !== 4) return;      // 当请求成功或失败时，改变 promise 的状态      if (this.status === 200) &#123;        resolve(this.response);      &#125; else &#123;        reject(new Error(this.statusText));      &#125;    &#125;;    // 设置错误监听函数    xhr.onerror = function() &#123;      reject(new Error(this.statusText));    &#125;;    // 设置响应的数据类型    xhr.responseType = &quot;json&quot;;    // 设置请求头信息    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);    // 发送 http 请求    xhr.send(null);  &#125;);  return promise;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p>
<p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p>
<p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p>
<ul>
<li><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。<ul>
<li>  全局上下文：变量定义，函数声明</li>
<li>  函数上下文：变量定义，函数声明，this，arguments</li>
</ul>
</li>
<li>  <strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</li>
</ul>
<p>那为什么会进行变量提升呢？主要有以下两个原因：</p>
<ol>
<li><p>提高性能</p>
<p> 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p>
<p> 在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p>
</li>
<li><p>容错性更好</p>
<p> 变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;<span class="keyword">var</span> a;<span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p> 如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p>
<p> 虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>  解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li>
<li>  声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li>
</ul>
<p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;	<span class="built_in">console</span>.log(tmp);	<span class="keyword">if</span>(<span class="literal">false</span>)&#123;		<span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;	&#125;&#125;fn();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;	<span class="built_in">console</span>.log(tmp[i]);&#125;<span class="built_in">console</span>.log(i); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p>
<h3 id="18-什么是尾调用，使用尾调用有什么好处？"><a href="#18-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="18. 什么是尾调用，使用尾调用有什么好处？"></a>18. 什么是尾调用，使用尾调用有什么好处？</h3><p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19. ES6模块与CommonJS模块有什么异同？"></a>19. ES6模块与CommonJS模块有什么异同？</h3><p>参考：<a href="https://juejin.cn/post/6844904145443356680#heading-24">https://juejin.cn/post/6844904145443356680#heading-24</a></p>
<ul>
<li>  CommonJS模块是运行时加载，ES6 Modules是编译时输出接口</li>
<li>  CommonJS输出是值的浅拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li>
<li>  CommonJs导入的模块路径可以是一个表达式，因为它使用的是<code>require()</code>方法；而ES6 Modules只能是字符串</li>
<li>  CommonJS <code>this</code>指向当前模块，ES6 Modules <code>this</code>指向<code>undefined</code></li>
<li>  且ES6 Modules中没有这些顶层变量：<code>arguments</code>、<code>require</code>、<code>module</code>、<code>exports</code>、<code>__filename</code>、<code>__dirname</code></li>
</ul>
<p>关于第一个差异，是因为CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<h3 id="20-常见的DOM操作有哪些"><a href="#20-常见的DOM操作有哪些" class="headerlink" title="20. 常见的DOM操作有哪些"></a>20. 常见的DOM操作有哪些</h3><ol>
<li><p>DOM 节点的获取</p>
<p> DOM 节点的获取的API及使用：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getElementById <span class="comment">// 按照 id 查询</span></span><br><span class="line">getElementsByTagName <span class="comment">// 按照标签名查询</span></span><br><span class="line">getElementsByClassName <span class="comment">// 按照类名查询</span></span><br><span class="line">querySelectorAll <span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照 id 查询</span></span><br><span class="line"><span class="keyword">var</span> imooc = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;imooc&#x27;</span>) <span class="comment">// 查询到 id 为 imooc 的元素</span></span><br><span class="line"><span class="comment">// 按照标签名查询</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)  <span class="comment">// 查询到标签为 p 的集合</span></span><br><span class="line"><span class="built_in">console</span>.log(divList.length)</span><br><span class="line"><span class="built_in">console</span>.log(divList[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 按照类名查询</span></span><br><span class="line"><span class="keyword">var</span> moocList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;mooc&#x27;</span>) <span class="comment">// 查询到类名为 mooc 的集合</span></span><br><span class="line"><span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.mooc&#x27;</span>) <span class="comment">// 查询到类名为 mooc 的集合</span></span><br></pre></td></tr></table></figure></li>
<li><p>DOM 节点的创建</p>
<p> <strong>创建一个新节点，并把它添加到指定节点的后面。</strong> 已知的 HTML 结构如下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p> 要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先获取父节点</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line"><span class="keyword">var</span> targetSpan = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line"><span class="comment">// 设置 span 节点的内容</span></span><br><span class="line">targetSpan.innerHTML = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment">// 把新创建的元素塞进父节点里去</span></span><br><span class="line">container.appendChild(targetSpan)</span><br></pre></td></tr></table></figure></li>
<li><p>DOM 节点的删除</p>
<p> <strong>删除指定的 DOM 节点，</strong> 已知的 HTML 结构如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;  <span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span>  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span>       <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>     <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span>&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p> 需要删除 id 为 title 的元素，做法是：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素的父元素var container = document.getElementById(&#x27;container&#x27;)// 获取目标元素var targetNode = document.getElementById(&#x27;title&#x27;)// 删除目标元素container.removeChild(targetNode)</span></span><br></pre></td></tr></table></figure>

<p> 或者通过子节点数组来完成删除：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素的父元素var container = document.getElementById(&#x27;container&#x27;)// 获取目标元素var targetNode = container.childNodes[1]// 删除目标元素container.removeChild(targetNode)</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改 DOM 元素</p>
<p> 修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。</p>
<p> <strong>将指定的两个 DOM 元素交换位置，</strong> 已知的 HTML 结构如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;  <span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span>  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span>       <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>     <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span>&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p> 现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取父元素var container = document.getElementById(&#x27;container&#x27;)    // 获取两个需要被交换的元素var title = document.getElementById(&#x27;title&#x27;)var content = document.getElementById(&#x27;content&#x27;)// 交换两个元素，把 content 置于 title 前面container.insertBefore(content, title)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="21-use-strict是什么意思-使用它区别是什么？"><a href="#21-use-strict是什么意思-使用它区别是什么？" class="headerlink" title="21. use strict是什么意思 ? 使用它区别是什么？"></a>21. use strict是什么意思 ? 使用它区别是什么？</h3><p>use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：</p>
<ul>
<li>  消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li>
<li>  消除代码运行的不安全之处，保证代码运行的安全；</li>
<li>  提高编译器效率，增加运行速度；</li>
<li>  为未来新版本的 Javascript 做好铺垫。</li>
</ul>
<p>严格模式的规范：<a href="https://juejin.cn/post/6844904120214618120#heading-4">https://juejin.cn/post/6844904120214618120#heading-4</a></p>
<ol>
<li>变量<ul>
<li>  不允许意外创建全局变量</li>
<li>  不能使用 <code>delete</code> 操作符删除声明变量</li>
<li>  不用使用保留字（例如 ：implements、interface、let、package、 private、protected、public、static 和 yield 标识符）作为变量名</li>
</ul>
</li>
<li>对象<ul>
<li>  为只读属性赋值会抛出TypeError</li>
<li>  对不可配置的（nonconfigurable）的属性使用 delete 操作符会抛出TypeError</li>
<li>  为不可扩展的（nonextensible）的对象添加属性会抛出TypeError</li>
<li>  使用对象字面量时, 属性名必须唯一</li>
</ul>
</li>
<li>函数<ul>
<li>  要求命名函数的参数必须唯一</li>
</ul>
</li>
<li>eval 和 arguments<ul>
<li>  eval不在为上下文中创建变量或函数</li>
<li>  eval 和 arguments 不能通过程序语法被绑定(be bound)或赋值</li>
<li>  参数的值不会随 arguments 对象的值的改变而变化</li>
<li>  禁止使用arguments.callee</li>
</ul>
</li>
<li> 禁止在函数内部遍历调用栈</li>
<li>静态绑定<ul>
<li>  禁止使用with语句</li>
<li>  eval()声明变量和函数只能当前eval内部的作用域中有效</li>
</ul>
</li>
<li>this 指向<ul>
<li>  全局作用域的函数中的this不再指向全局而是undefined。</li>
<li>  如果使用构造函数时，如果忘了加new，this不再指向全局对象，而是undefined报错</li>
</ul>
</li>
</ol>
<h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><p>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<p>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p>
<p>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</p>
<h3 id="23-强类型语言和弱类型语言的区别"><a href="#23-强类型语言和弱类型语言的区别" class="headerlink" title="23. 强类型语言和弱类型语言的区别"></a>23. 强类型语言和弱类型语言的区别</h3><ul>
<li>  <strong>强类型语言</strong>：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。</li>
<li>  <strong>弱类型语言</strong>：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串’12’和整数3进行连接得到字符串’123’，在相加的时候会进行强制类型转换。</li>
</ul>
<p>两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。</p>
<h3 id="24-解释性语言和编译型语言的区别"><a href="#24-解释性语言和编译型语言的区别" class="headerlink" title="24. 解释性语言和编译型语言的区别"></a>24. 解释性语言和编译型语言的区别</h3><ol>
<li>解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下<ul>
<li>  解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li>
<li>  只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li>
<li>  JavaScript、Python等属于解释型语言。</li>
</ul>
</li>
<li>编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：<ul>
<li>  一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li>
<li>  与特定平台相关，一般无法移植到其他平台；</li>
<li>  C、C++等属于编译型语言。</li>
</ul>
</li>
</ol>
<p><strong>两者主要区别在于：</strong> 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p>
<h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下：</p>
<ul>
<li>  for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li>
<li>  for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li>
<li>  对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li>
</ul>
<p><strong>总结：</strong> for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p>
<h3 id="26-如何使用for…of遍历对象"><a href="#26-如何使用for…of遍历对象" class="headerlink" title="26. 如何使用for…of遍历对象"></a>26. 如何使用for…of遍历对象</h3><p>for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。</p>
<p>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;    <span class="number">0</span>:<span class="string">&#x27;one&#x27;</span>,    <span class="number">1</span>:<span class="string">&#x27;two&#x27;</span>,    <span class="attr">length</span>: <span class="number">2</span>&#125;;obj = <span class="built_in">Array</span>.from(obj);<span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> obj)&#123;    <span class="built_in">console</span>.log(k)&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：var obj = &#123;    a:1,    b:2,    c:3&#125;;obj[Symbol.iterator] = function()&#123;	var keys = Object.keys(this);	var count = 0;	return &#123;		next()&#123;			if(count&lt;keys.length)&#123;				return &#123;value: obj[keys[count++]],done:false&#125;;			&#125;else&#123;				return &#123;value:undefined,done:true&#125;;			&#125;		&#125;	&#125;&#125;;for(var k of obj)&#123;	console.log(k);&#125;// 方法二var obj = &#123;    a:1,    b:2,    c:3&#125;;obj[Symbol.iterator] = function*()&#123;    var keys = Object.keys(obj);    for(var k of keys)&#123;        yield [k,obj[k]]    &#125;&#125;;for(var [k,v] of obj)&#123;    console.log(k,v);&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="27-ajax、axios、fetch的区别"><a href="#27-ajax、axios、fetch的区别" class="headerlink" title="27. ajax、axios、fetch的区别"></a>27. ajax、axios、fetch的区别</h3><ol>
<li><p><strong>AJAX</strong> Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：</p>
<ul>
<li>  本身是针对MVC编程，不符合前端MVVM的浪潮</li>
<li>  基于原生XHR开发，XHR本身的架构不清晰</li>
<li>  不符合关注分离（Separation of Concerns）的原则</li>
<li>  配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li>
</ul>
</li>
<li><p><strong>Fetch</strong> fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</p>
<p> fetch的优点：</p>
<ul>
<li>  语法简洁，更加语义化</li>
<li>  基于标准 Promise 实现，支持 async/await</li>
<li>  更加底层，提供的API丰富（request, response）</li>
<li>  脱离了XHR，是ES规范里新的实现方式</li>
</ul>
<p> fetch的缺点：</p>
<ul>
<li>  fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li>
<li>  fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li>
<li>  fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li>
<li>  fetch没有办法原生监测请求的进度，而XHR可以</li>
</ul>
</li>
<li><p><strong>Axios</strong> Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</p>
<ul>
<li>  浏览器端发起XMLHttpRequests请求</li>
<li>  node端发起http请求</li>
<li>  支持Promise API</li>
<li>  监听请求和返回</li>
<li>  对请求和返回进行转化</li>
<li>  取消请求</li>
<li>  自动转换json数据</li>
<li>  客户端支持抵御XSRF攻击</li>
</ul>
</li>
</ol>
<h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><p><a href="https://cuggz.blog.csdn.net/article/details/107649549">https://cuggz.blog.csdn.net/article/details/107649549</a></p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>是否改变原数组</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>forEach()</td>
<td>否</td>
<td>数组方法，不改变原数组，没有返回值</td>
</tr>
<tr>
<td>map()</td>
<td>否</td>
<td>数组方法，不改变原数组，有返回值，可链式调用</td>
</tr>
<tr>
<td>filter()</td>
<td>否</td>
<td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td>
</tr>
<tr>
<td>for…of</td>
<td>否</td>
<td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td>
</tr>
<tr>
<td>every() 和 some()</td>
<td>否</td>
<td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td>
</tr>
<tr>
<td>find() 和 findIndex()</td>
<td>否</td>
<td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td>
</tr>
<tr>
<td>reduce() 和 reduceRight()</td>
<td>否</td>
<td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td>
</tr>
</tbody></table>
<h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p>
<ul>
<li>  forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li>
<li>  map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li>
</ul>
<h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p>
<p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p>
<p><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p>
<p>参考：<a href="https://juejin.cn/post/6934498361475072014%EF%BC%8Chttps://juejin.cn/post/6844903989088092174#heading-1">https://juejin.cn/post/6934498361475072014，https://juejin.cn/post/6844903989088092174#heading-1</a></p>
<p><img src="/2021/12/06/javascript/03-4-1.JPG"></p>
<p><img src="/../../../Desktop/%E9%9D%A2%E8%AF%95/pic/03/03-4-1-2.png"></p>
<h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">p.constructor = Person</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.__proto__  <span class="comment">// Person.prototype</span></span><br><span class="line">Person.prototype.__proto__  <span class="comment">// Object.prototype</span></span><br><span class="line">p.__proto__.__proto__ <span class="comment">//Object.prototype</span></span><br><span class="line">p.__proto__.constructor.prototype.__proto__ <span class="comment">// Object.prototype</span></span><br><span class="line">Person.prototype.constructor.prototype.__proto__ <span class="comment">// Object.prototype</span></span><br><span class="line">p1.__proto__.constructor <span class="comment">// Person</span></span><br><span class="line">Person.prototype.constructor  <span class="comment">// Person</span></span><br></pre></td></tr></table></figure>

<h3 id="4-原型链的终点是什么？如何打印出原型链的终点？"><a href="#4-原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="4. 原型链的终点是什么？如何打印出原型链的终点？"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h3><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。</p>
<h3 id="5-如何获得对象非原型链上的属性？"><a href="#5-如何获得对象非原型链上的属性？" class="headerlink" title="5. 如何获得对象非原型链上的属性？"></a>5. 如何获得对象非原型链上的属性？</h3><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> res=[];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))</span><br><span class="line">           res.push(key+<span class="string">&#x27;: &#x27;</span>+obj[key]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="五、执行上下文-作用域链-闭包"><a href="#五、执行上下文-作用域链-闭包" class="headerlink" title="五、执行上下文/作用域链/闭包"></a>五、执行上下文/作用域链/闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p>
<p>闭包有两个常用的用途；</p>
<ul>
<li>  闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li>
<li>  闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li>
</ul>
<p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p>
<ol>
<li><p>第一种是使用闭包的方式</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;      ;(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;                  <span class="built_in">console</span>.log(j)            &#125;, j * <span class="number">1000</span>)      &#125;)(i)&#125;</span><br></pre></td></tr></table></figure>

<p> 在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p>
</li>
<li><p>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;  <span class="built_in">setTimeout</span>(    <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;      <span class="built_in">console</span>.log(j)    &#125;,    i * <span class="number">1000</span>,    i  )&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(i)  &#125;, i * <span class="number">1000</span>)&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><ol>
<li>全局作用域和函数作用域<ol>
<li>全局作用域<ul>
<li>  最外层函数和最外层函数外面定义的变量拥有全局作用域</li>
<li>  所有未定义直接赋值的变量自动声明为全局作用域</li>
<li>  所有window对象的属性拥有全局作用域</li>
<li>  全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li>
</ul>
</li>
<li>函数作用域<ul>
<li>  函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>
<li>  作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>
</ul>
</li>
</ol>
</li>
<li>块级作用域<ul>
<li>  使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li>
<li>  let和const声明的变量不会有变量提升，也不可以重复声明</li>
<li>  在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>
</ul>
</li>
</ol>
<p><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p>
<p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p>
<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>
<p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p>
<h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><ol>
<li><p>执行上下文类型</p>
<ul>
<li><p>全局执行上下文</p>
<p>  任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p>
</li>
<li><p>函数执行上下文</p>
<p>  当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p>
</li>
<li><p><code>eval</code> 函数执行上下文</p>
<p>  执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p>
</li>
</ul>
</li>
<li><p>执行上下文栈</p>
<ul>
<li>  JavaScript引擎使用执行上下文栈来管理执行上下文</li>
<li>  当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;<span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&#x27;Inside first function&#x27;</span>);  second();  <span class="built_in">console</span>.log(<span class="string">&#x27;Again inside first function&#x27;</span>);&#125;<span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&#x27;Inside second function&#x27;</span>);&#125;first();<span class="comment">//执行顺序//先执行second(),在执行first()</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建执行上下文</p>
<p> 创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p>
<ol>
<li>创建阶段<ol>
<li>this 绑定<ul>
<li>  在全局执行上下文中，this指向全局对象（window对象）</li>
<li>  在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li>
</ul>
</li>
<li>创建词法环境组件<ul>
<li>  词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。</li>
<li>  词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li>
</ul>
</li>
<li>创建变量环境组件<ul>
<li>  变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li>
</ul>
</li>
</ol>
</li>
<li> 执行阶段  此阶段会完成对变量的分配，最后执行完代码。</li>
</ol>
</li>
</ol>
<p><strong>简单来说执行上下文就是指：</strong></p>
<p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p>
<p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p>
<ul>
<li>  全局上下文：变量定义，函数声明</li>
<li>  函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li>
</ul>
<h2 id="六、this-call-apply-bind"><a href="#六、this-call-apply-bind" class="headerlink" title="六、this/call/apply/bind"></a>六、this/call/apply/bind</h2><h3 id="1-对-this-对象的理解"><a href="#1-对-this-对象的理解" class="headerlink" title="1. 对 this 对象的理解"></a>1. 对 this 对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>
<ul>
<li>  第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li>
<li>  第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>
<li>  第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>
<li>  第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>
</ul>
<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>
<h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p>
<ul>
<li>  apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li>
<li>  call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li>
</ul>
<h3 id="3-实现-call、apply-及-bind-函数"><a href="#3-实现-call、apply-及-bind-函数" class="headerlink" title="3. 实现 call、apply 及 bind 函数"></a>3. 实现 call、apply 及 bind 函数</h3><ol>
<li><p>call</p>
<ul>
<li>  判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>  判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>  处理传入的参数，截取第一个参数后的所有参数。</li>
<li>  将函数作为上下文对象的一个属性。</li>
<li>  使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>  删除刚才新增的属性。</li>
<li>  返回结果。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.fn(...args);</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>apply</p>
<ul>
<li>  判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>  判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>  将函数作为上下文对象的一个属性。</li>
<li>  判断参数值是否传入</li>
<li>  使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>  删除刚才新增的属性</li>
<li>  返回结果</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>bind</p>
<ul>
<li>  判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>  保存当前函数的引用，获取其余传入参数值。</li>
<li>  创建一个函数返回</li>
<li>  函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(</span><br><span class="line">      <span class="built_in">this</span> <span class="keyword">instanceof</span> Fn ? <span class="built_in">this</span> : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</p>
<p><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</p>
<p><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</p>
<p><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</p>
<h3 id="2-setTimeout、Promise、Async-Await-的区别"><a href="#2-setTimeout、Promise、Async-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async/Await 的区别"></a>2. setTimeout、Promise、Async/Await 的区别</h3><p>参考：<a href="https://juejin.cn/post/6844903999108284430">https://juejin.cn/post/6844903999108284430</a></p>
<ol>
<li><p>seTimeout</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)	<span class="comment">//1. 打印 script start</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)	<span class="comment">// 4. 打印 settimeout</span></span><br><span class="line">&#125;)	<span class="comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)	<span class="comment">//3. 打印 script start</span></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br></pre></td></tr></table></figure></li>
<li><p>Promise</p>
<p> Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p> 当JS主线程执行到Promise对象时：</p>
<ul>
<li>  promise1.then() 的回调就是一个 task</li>
<li>  promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>  promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li>  setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>
</ul>
</li>
<li><p>async/await</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sync <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p> async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>
<p> await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p>
</li>
</ol>
<h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<ol>
<li><p>Promise的实例有<strong>三个状态</strong>:</p>
<ul>
<li>  Pending（进行中）</li>
<li>  Resolved（已完成）</li>
<li>  Rejected（已拒绝）</li>
</ul>
<p> 当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p>
</li>
<li><p>Promise的实例有<strong>两个过程</strong>：</p>
<ul>
<li>  pending -&gt; fulfilled : Resolved（已完成）</li>
<li>  pending -&gt; rejected：Rejected（已拒绝）</li>
</ul>
<p> 注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p>
</li>
</ol>
<p><strong>Promise的特点：</strong></p>
<ul>
<li>  对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li>
<li>  一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li>
</ul>
<p><strong>Promise的缺点：</strong></p>
<ul>
<li>  无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>  如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>  当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<p><strong>总结：</strong> Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p>
<p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p>
<p><strong>注意：</strong> 在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p>
<h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><ol>
<li><p>创建 Promise 对象</p>
<p> Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p>
<p> Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> <strong>一般情况下都会使用</strong><code>new Promise()</code><strong>来创建promise对象，但是也可以使用</strong><code>promise.resolve</code><strong>和</strong><code>promise.reject</code><strong>这两个方法：</strong></p>
<ul>
<li><p><strong>Promise.resolve</strong></p>
<p>  <code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">11</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 打印出11</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  <code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p>
<p>  创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p>
</li>
<li><p><strong>Promise.reject</strong></p>
<p>  <code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(“我错了，请原谅俺！！”));</span><br></pre></td></tr></table></figure>

<p>  就是下面的代码new Promise的简单形式：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">   reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;我错了！&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  下面是使用resolve方法和reject方法：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testPromise</span>(<span class="params">ready</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">      resolve(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">&quot;No thanks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line">testPromise(<span class="literal">true</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p>
</li>
</ul>
</li>
<li><p>Promise 方法</p>
<p> Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p>
<ol>
<li><p><strong>then()</strong></p>
<p> 当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> <code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。 <code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p>
<p> 当要写有顺序的异步事件时，需要串行时，可以这样写：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    ajax(<span class="string">&#x27;first&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        resolve(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        ajax(<span class="string">&#x27;second&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        ajax(<span class="string">&#x27;second&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> 那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p>
</li>
<li><p><strong>catch()</strong></p>
<p> Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">     &#125;</span><br><span class="line">); </span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>  <strong>all()</strong></p>
</li>
</ol>
<pre><code> `all`方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个`promise`对象。当数组中所有的`promise`的状态都达到`resolved`的时候，`all`方法的状态就会变成`resolved`，如果有一个状态变成了`rejected`，那么`all`方法的状态就会变成`rejected`。

 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">javascript</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="number">1</span>);</span><br><span class="line">	&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="number">2</span>);</span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="number">3</span>);</span><br><span class="line">	&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all([promise1,promise2,promise3]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="comment">//结果为：[1,2,3] </span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

 调用`all`方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象`resolve`执行时的值。
</code></pre>
<ol start="4">
<li><p><strong>race()</strong></p>
<p> <code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       reject(<span class="number">1</span>);</span><br><span class="line">	&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="number">2</span>);</span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="number">3</span>);</span><br><span class="line">	&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([promise1,promise2,promise3]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">	<span class="comment">//结果：2</span></span><br><span class="line">&#125;,<span class="function"><span class="params">rej</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rej)&#125;;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> 那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([promise1,timeOutPromise(<span class="number">5000</span>)]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>finally()</strong></p>
<p> <code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>

<p> 上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<p> 下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>

<p> <code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> 上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
</li>
</ol>
</li>
</ol>
<h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.readFile(<span class="string">&#x27;./a.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  fs.readFile(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    fs.readFile(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的代码有如下缺点：</p>
<ul>
<li>  后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li>
<li>  如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li>
</ul>
<p><code>Promise</code>出现之后，代码变成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(url,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,data</span>)</span>&#123;</span><br><span class="line">      error &amp;&amp; reject(error)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">read(<span class="string">&#x27;./a.txt&#x27;</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> read(data) </span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> read(data)  </span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://juejin.cn/post/6844903636737196045#comment">https://juejin.cn/post/6844903636737196045#comment</a></p>
<h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><ul>
<li><p>Promise.all</p>
<p>  <code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p>
<p>  Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p>
<p>  需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p>
</li>
<li><p>Promise.race</p>
<p>  顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([promise1,timeOutPromise(<span class="number">5000</span>)]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-对async-await-的理解"><a href="#7-对async-await-的理解" class="headerlink" title="7. 对async/await 的理解"></a>7. 对async/await 的理解</h3><p>async/await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = testAsy(); </span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/06/javascript/03-7-7.png"></p>
<p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>
<p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = testAsy() </span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line">result.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)   <span class="comment">// hello world</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p>
<p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>
<p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>
<h3 id="8-await-到底在等啥？"><a href="#8-await-到底在等啥？" class="headerlink" title="8. await 到底在等啥？"></a>8. await 到底在等啥？</h3><p><strong>await 在等待什么呢？</strong> 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>
<p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;something&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething();</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">    <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>await 表达式的运算结果取决于它等的是什么。</p>
<ul>
<li>  如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li>
<li>  如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li>
</ul>
<p>来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       resolve(x);</span><br><span class="line">     &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAwt</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">  <span class="keyword">let</span> result =  <span class="keyword">await</span> testAsy(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);    <span class="comment">// 3秒钟之后出现hello world</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;cuger&#x27;</span>)   <span class="comment">// 3秒钟之后出现cug</span></span><br><span class="line">&#125;</span><br><span class="line">testAwt();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;cug&#x27;</span>)  <span class="comment">//立即输出cug</span></span><br></pre></td></tr></table></figure>

<p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p>
<h3 id="9-async-await的优势"><a href="#9-async-await的优势" class="headerlink" title="9. async/await的优势"></a>9. async/await的优势</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p>
<p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class="line"><span class="comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在用 Promise 方式来实现这三个步骤的处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br><span class="line"><span class="comment">// c:\var\test&gt;node --harmony_async_await .</span></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 500</span></span><br><span class="line"><span class="comment">// step3 with 700</span></span><br><span class="line"><span class="comment">// result is 900</span></span><br><span class="line"><span class="comment">// doIt: 1507.251ms</span></span><br></pre></td></tr></table></figure>

<p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p>
<p>如果用 async/await 来实现呢，会是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure>

<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>
<h3 id="10-async-await对比Promise的优势"><a href="#10-async-await对比Promise的优势" class="headerlink" title="10. async/await对比Promise的优势"></a>10. async/await对比Promise的优势</h3><ul>
<li>  代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担</li>
<li>  Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅</li>
<li>  错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余</li>
<li>  调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li>
</ul>
<h3 id="11-async-await-如何捕获异常"><a href="#11-async-await-如何捕获异常" class="headerlink" title="11. async/await 如何捕获异常"></a>11. async/await 如何捕获异常</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-并发与并行的区别？"><a href="#12-并发与并行的区别？" class="headerlink" title="12. 并发与并行的区别？"></a>12. 并发与并行的区别？</h3><ul>
<li>  并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</li>
<li>  并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li>
</ul>
<h3 id="13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"><a href="#13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？" class="headerlink" title="13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"></a>13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h3><p>以下代码就是一个回调函数的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url1, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        ajax(url2, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ajax(url1, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    secondAjax()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">secondAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ajax(url2, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理逻辑</span></span><br><span class="line">  firstAjax()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：</p>
<ol>
<li> 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li> 嵌套函数一多，就很难处理错误</li>
</ol>
<p>当然，回调函数还存在着别的几个缺点，比如不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。</p>
<h3 id="14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？"><a href="#14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？" class="headerlink" title="14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？"></a>14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h3><p>异步编程当然少不了定时器了，常见的定时器函数有 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>。最常用的是<code>setTimeout</code>，很多人认为 <code>setTimeout</code> 是延时多久，那就应该是多久后执行。</p>
<p>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 <code>setTimeout</code> 不会按期执行。当然了，可以通过代码去修正 <code>setTimeout</code>，从而使定时器相对准确：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + period</span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span></span><br><span class="line"><span class="keyword">let</span> currentInterval = interval</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * interval);</span><br><span class="line">  <span class="keyword">let</span> diff = end - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  <span class="keyword">let</span> h = <span class="built_in">Math</span>.floor(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">let</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">let</span> m = <span class="built_in">Math</span>.floor(hdiff / (<span class="number">60</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">let</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> s = mdiff / (<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> sCeil = <span class="built_in">Math</span>.ceil(s)</span><br><span class="line">  <span class="keyword">let</span> sFloor = <span class="built_in">Math</span>.floor(s)</span><br><span class="line">  <span class="comment">// 得到下一次循环所消耗的时间</span></span><br><span class="line">  currentInterval = interval - offset </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;时：&#x27;</span>+h, <span class="string">&#x27;分：&#x27;</span>+m, <span class="string">&#x27;毫秒：&#x27;</span>+s, <span class="string">&#x27;秒向上取整：&#x27;</span>+sCeil, <span class="string">&#x27;代码执行时间：&#x27;</span>+offset, <span class="string">&#x27;下次循环间隔&#x27;</span>+currentInterval) </span><br><span class="line">  <span class="built_in">setTimeout</span>(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(loop, currentInterval)</span><br></pre></td></tr></table></figure>

<p>接下来看 <code>setInterval</code>，其实这个函数作用和 <code>setTimeout</code> 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p>
<p>通常来说不建议使用 <code>setInterval</code>。第一，它和 <code>setTimeout</code> 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">  sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>

<p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p>
<p>如果有循环定时器的需求，其实完全可以通过 <code>requestAnimationFrame</code> 来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInterval</span>(<span class="params">callback, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now</span><br><span class="line">  <span class="keyword">let</span> startTime = now()</span><br><span class="line">  <span class="keyword">let</span> endTime = startTime</span><br><span class="line">  <span class="keyword">const</span> loop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">    endTime = now()</span><br><span class="line">    <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = now()</span><br><span class="line">      callback(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">  <span class="keyword">return</span> timer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="params">timer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">3</span>) cancelAnimationFrame(timer)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 <code>setTimeout</code>。</p>
<h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1-对象创建的方式有哪些？"><a href="#1-对象创建的方式有哪些？" class="headerlink" title="1. 对象创建的方式有哪些？"></a>1. 对象创建的方式有哪些？</h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p>
<ol>
<li> 第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</li>
<li> 第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</li>
<li> 第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</li>
<li> 第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</li>
<li> 第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</li>
<li> 第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</li>
</ol>
<h3 id="2-对象继承的方式有哪些？"><a href="#2-对象继承的方式有哪些？" class="headerlink" title="2. 对象继承的方式有哪些？"></a>2. 对象继承的方式有哪些？</h3><ol>
<li> 第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</li>
<li> 第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</li>
<li> 第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</li>
<li> 第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</li>
<li> 第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</li>
<li> 第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</li>
</ol>
<h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><p>参考：<a href="https://juejin.cn/post/6995706341041897486">https://juejin.cn/post/6995706341041897486</a></p>
<ol>
<li><p>垃圾回收的概念</p>
<p> <strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p>
<p> <strong>回收机制</strong>：</p>
<ul>
<li>  Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li>
<li>  JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li>
<li>  不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li>
</ul>
</li>
<li><p>垃圾回收的方式</p>
<p> 浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 </p>
<p> <strong>1）标记清除</strong></p>
<ul>
<li>  标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li>
<li>  垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li>
</ul>
<p> <strong>2）引用计数</strong></p>
<ul>
<li>  另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li>
<li>  这种方法会引起<strong>循环引用</strong>的问题：例如：<code> obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line">    obj1.a = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.a = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这种情况下，就要手动释放变量占用的内存：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj1.a =  <span class="literal">null</span></span><br><span class="line"> obj2.a =  <span class="literal">null</span></span><br></pre></td></tr></table></figure></li>
<li><p>减少垃圾回收</p>
<p> 虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p>
<ul>
<li>  <strong>对数组进行优化：</strong> 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li>
<li>  <strong>对</strong><code>object</code><strong>进行优化：</strong> 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li>
<li>  <strong>对函数进行优化：</strong> 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li>
</ul>
</li>
</ol>
<h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>参考：<a href="https://juejin.cn/post/6996828267068014600#heading-11">https://juejin.cn/post/6996828267068014600#heading-11</a></p>
<p>以下四种情况会造成内存的泄漏：</p>
<ul>
<li>  <strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li>  <strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li>  <strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>  <strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
<h3 id="Object-create-和"><a href="#Object-create-和" class="headerlink" title="Object.create()和{}"></a>Object.create()和{}</h3><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
