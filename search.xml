<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>html语义化理解及SEO</title>
    <url>/2021/11/22/html-semantic-seo/</url>
    <content><![CDATA[<h2 id="1-语义化"><a href="#1-语义化" class="headerlink" title="1. 语义化"></a>1. 语义化</h2><h3 id="1-1-含义"><a href="#1-1-含义" class="headerlink" title="1.1 含义"></a>1.1 含义</h3><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗的来讲就是正确的标签做正确的事情。</p>
<h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul>
<li>  对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li>
<li>  对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li>
</ul>
<h3 id="1-3-常见的语义化标签"><a href="#1-3-常见的语义化标签" class="headerlink" title="1.3 常见的语义化标签"></a>1.3 常见的语义化标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span>  头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>  导航栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  区块（有语义化的div）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span>  主要区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span>  主要内容</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span>  侧边栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure>

<h3 id="1-4-写语义化代码应该注意什么"><a href="#1-4-写语义化代码应该注意什么" class="headerlink" title="1.4 写语义化代码应该注意什么"></a>1.4 写语义化代码应该注意什么</h3><ul>
<li>  尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li>
<li>  不要使用纯样式标签，如：b、font、u等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li>
<li>  使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li>
<li>  表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来</li>
</ul>
<h2 id="2-SEO"><a href="#2-SEO" class="headerlink" title="2. SEO"></a>2. SEO</h2><h3 id="2-1-TKD-设置"><a href="#2-1-TKD-设置" class="headerlink" title="2.1 TKD 设置"></a>2.1 TKD 设置</h3><ul>
<li><p>  页面 TKD 要包含品牌词及业务词，提升页面排名</p>
</li>
<li><p>例如：掘金的 TKD</p>
<ul>
<li>  Title：掘金 - 代码不止，掘金不停</li>
<li>  Keywords：掘金,稀土,Vue.js,前端面试题,nginx配置,Kotlin,RxJava,React Native,敏捷开发,Python</li>
<li>  Description：掘金是一个帮助开发者成长的社区,是给开发者用的 <code>Hacker News</code>,给设计师用的 <code>Designer News</code>,和给产品经理用的 <code>Medium</code>。掘金的技术文章由稀土上聚集的技术大牛和极客共同编辑为你筛选出最优质的干货,其中包括：<code>Android、iOS</code>、前端、后端等方面的内容。用户每天都可以在这里找到技术世界的头条内容。与此同时,掘金内还有沸点、掘金翻译计划、线下活动、专栏文章等内容。即使你是 <code>GitHub、StackOverflow、</code>开源中国的用户,我们相信你也可以在这里有所收获。</li>
</ul>
</li>
</ul>
<h3 id="2-2-页面内容优化"><a href="#2-2-页面内容优化" class="headerlink" title="2.2 页面内容优化"></a>2.2 页面内容优化</h3><ol>
<li> 网页代码语义化调整：多使用语义化标签，便于爬虫搜索。</li>
<li> 页面内容关键词强化：在页面大小标题和文案中重复关键词，以达到内容强化目的；关键词汇避免使用图片，便于爬虫检索，收录。</li>
<li> img 添加 alt 属性，用 h1 标签写内容关键字。</li>
</ol>
<p>引导链接</p>
<ul>
<li>  网站底部推荐部分保留产品介绍、常见问题汇总等降低跳出率的引导，提高页面留存与转化；或者与所推荐页面形成互链形式，以稳定页面流量权重。</li>
</ul>
<h3 id="2-3-移动端优化"><a href="#2-3-移动端优化" class="headerlink" title="2.3 移动端优化"></a>2.3 移动端优化</h3><ul>
<li>  设置移动页面，或者将 pc 页面设置为自适应，增加移动端搜索的体验和留存转化</li>
<li>移动页面设计需注意以下原则：<ol>
<li> 页面字体、字符大小、文本行间距等设计，应适合手机用户阅读，不可明显过大过小，正文文本字号不小于 10pt（pt：绝对单位，等于1/72英寸）。</li>
<li> 首屏主体内容必须占屏幕的 50% 以上。</li>
<li> 主体内容应与其它板块有明显区分，且位于屏幕的中心位置，使用户获取信息是不受任何干扰。</li>
<li> 导航的功能与位置明确，避免用户使用过程中被误导</li>
<li> 除以上提到的内容外，网站还应避免其他影响页面内容辨识的情况，例如页面出现大面积空白、文本无任何排版、段落/图片排版错乱不整齐、主体内容展示不全等。</li>
</ol>
</li>
</ul>
<h3 id="2-4-站外优化"><a href="#2-4-站外优化" class="headerlink" title="2.4 站外优化"></a>2.4 站外优化</h3><ol>
<li> 在搜索引擎排名较高的公众平台发布正面网站信息，以建设良好口碑；负面信息排名较高的需删除或者屏蔽处理。</li>
<li> 百度，互动，搜狗等百科的创建更新与维护，(互动百科在今日头条有着较高的排名，现在今日头条也在发展搜素引擎)，百科对树立品牌形象较为重要。</li>
<li> 公关舆情传播，宣传新闻源发布。</li>
<li> 站外推广与外链建设。</li>
<li> 根据竞争对手及品牌业务分析，拓展高质量、高权重的外链渠道、科技论坛、自媒体平台、分类信息网等，发布高质量锚文本外链，另进行友情链接交换，以提高关键词排名及自然流量。</li>
</ol>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>script标签defer和async的区别，还有哪些属性？</title>
    <url>/2021/11/21/script-attribute/</url>
    <content><![CDATA[<h2 id="1-defer-和-async-属性出现的意义"><a href="#1-defer-和-async-属性出现的意义" class="headerlink" title="1. defer 和 async 属性出现的意义"></a>1. defer 和 async 属性出现的意义</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>
<h3 id="1-1-defer-属性"><a href="#1-1-defer-属性" class="headerlink" title="1.1 defer 属性"></a>1.1 defer 属性</h3><p>推迟执行脚本。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</p>
<ul>
<li>  在 &lt;script&gt; 标签上设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。</li>
<li>  HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，并且会在 DOMContentLoaded 事件之前执行。不过在实际当中，不一定总会按照顺序或者在 DOMContentLoaded 事件之前执行。</li>
</ul>
<h3 id="1-2-async-属性（HTML5）"><a href="#1-2-async-属性（HTML5）" class="headerlink" title="1.2 async 属性（HTML5）"></a>1.2 async 属性（<strong>HTML5</strong>）</h3><p>异步执行脚本。表示应该立即请求脚本，并尽快解析和执行，但不能阻止其它页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</p>
<ul>
<li>  告诉浏览器立即下载，但不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行完后在加载其它脚本。（因此，异步脚本不应该在加载期间修改 DOM）</li>
<li>  标记为 async 的脚本并不保证能按照它们出现的次序执行。异步脚本保证会在页面的的 <strong>load</strong> 事件前执行，但可能会在 <strong>DOMContentLoaded</strong> 之前或之后。</li>
</ul>
<h2 id="2-lt-script-gt-标签其它属性"><a href="#2-lt-script-gt-标签其它属性" class="headerlink" title="2. &lt;script&gt; 标签其它属性"></a>2. &lt;script&gt; 标签其它属性</h2><h3 id="2-1-charset-属性"><a href="#2-1-charset-属性" class="headerlink" title="2.1 charset 属性"></a>2.1 charset 属性</h3><p>使用 src 属性指定的代码字符集。很少使用，因为大多数浏览器不在乎它的值。</p>
<h3 id="2-2-crossorigin-属性"><a href="#2-2-crossorigin-属性" class="headerlink" title="2.2 crossorigin 属性"></a>2.2 crossorigin 属性</h3><p>那些没有通过标准CORS (跨域资源共享)检查的正常script 元素传递最少的信息到 window.onerror。可以使用本属性来使那些将静态资源放在另外一个域名的站点打印错误信息。默认不使用 CORS，“” 相当于 “anonymous” ，对此元素的 CORS 请求不设置凭据标志；“use-credentials”，对此元素的 CORS 请求将设置凭证标志，这意味着请求将提供凭据。</p>
<h3 id="2-3-integrity-属性"><a href="#2-3-integrity-属性" class="headerlink" title="2.3 integrity 属性"></a>2.3 integrity 属性</h3><p>允许对比接收到的资源和指定的加密签名以验证子资源完整性（SRI）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN）不会提供恶意内容。</p>
<h3 id="2-4-nomodule-属性"><a href="#2-4-nomodule-属性" class="headerlink" title="2.4 nomodule 属性"></a>2.4 nomodule 属性</h3><p>这个布尔属性被设置来标明这个脚本在支持 ES2015 modules 的浏览器中不执行。实际上，这可用于在不支持模块化 JavaScript 的旧浏览器中提供回退脚本。</p>
<h3 id="2-5-language-属性"><a href="#2-5-language-属性" class="headerlink" title="2.5 language 属性"></a>2.5 language 属性</h3><p>废弃。最初用于表示代码块中的脚本语言。大多数浏览器都会忽略这个属性，不应该再使用它。</p>
<h3 id="2-6-src-属性"><a href="#2-6-src-属性" class="headerlink" title="2.6 src 属性"></a>2.6 src 属性</h3><p>定义引用外部脚本的URI，这可以用来代替直接在文档中嵌入脚本。指定了 src 属性的script元素标签内不应该再有嵌入的脚本。</p>
<h3 id="2-7-type-属性"><a href="#2-7-type-属性" class="headerlink" title="2.7 type 属性"></a>2.7 type 属性</h3><p>代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型：<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></strong>）。支持的MIME类型包括text/javascript, text/ecmascript, application/javascript（非IE支持）, 和application/ecmascript（非IE支持）。如果没有定义这个属性，脚本会被视作JavaScript。如果MIME类型不是JavaScript类型（上述支持的类型），则该元素所包含的内容会被当作数据块而不会被浏览器执行。JS 文件中的MIME 类型通常是 “application/x-javascript” 。如果type属性为module，代码会被当作JavaScript模块 。</p>
<h3 id="2-8-text-属性"><a href="#2-8-text-属性" class="headerlink" title="2.8 text 属性"></a>2.8 text 属性</h3><p>和 textContent 属性类似，本属性用于设置元素的文本内容。但和 textContent 不一样的是，本属性在节点插入到DOM之后，此属性被解析为可执行代码。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>十大经典排序算法</title>
    <url>/2021/11/25/sort-algorithm/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><p>十大常见排序算法可以分为两大类：</p>
<ul>
<li>  比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$O(nlogn)$，因此也称为非线性时间比较类排序</li>
<li>  非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序</li>
</ul>
<span id="more"></span>

<p><img src="/2021/11/25/sort-algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li>  稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li>  不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li>  时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li>  空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>
<li>  In-place：占用常数内存，不占用额外内存。</li>
<li>  Out-place：占用额外内存。</li>
<li>  内排序：所有排序操作都在内存中完成，常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</li>
<li>  外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li>
</ul>
<h2 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h2><h3 id="1-1-思想"><a href="#1-1-思想" class="headerlink" title="1.1 思想"></a>1.1 思想</h3><ul>
<li>  比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>  对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>  针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>  持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
<li>  因此最多重复 n - 1 次，就完成了 n 个数据的排序工作。</li>
</ul>
<h3 id="1-2-动画演示"><a href="#1-2-动画演示" class="headerlink" title="1.2 动画演示"></a>1.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/bubbleSort.gif"></p>
<h3 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;  <span class="comment">// 扫描 n - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123; </span><br><span class="line">      <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;  <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">        <span class="keyword">const</span> temp = arr[j + <span class="number">1</span>]  <span class="comment">// 元素交换</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong>：上述代码不论什么情况下都会对数组扫描 n  - 1次，但是当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。下面是优化后的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSortPlus = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> hasChange = <span class="literal">false</span>  <span class="comment">// 增加一个标记位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">        arr[j] = temp</span><br><span class="line">        hasChange = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!hasChange) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-性能分析"><a href="#1-4-性能分析" class="headerlink" title="1.4 性能分析"></a>1.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(N^2)$<br></li>
<li>  最佳时间复杂度：$O(N)$<br></li>
<li>  最差时间复杂度：$O(N^2)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2. 选择排序（Selection Sort）"></a>2. 选择排序（Selection Sort）</h2><h3 id="2-1-思想"><a href="#2-1-思想" class="headerlink" title="2.1 思想"></a>2.1 思想</h3><ul>
<li>  首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>  再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>  重复第二步，直到所有元素均排序完毕。</li>
</ul>
<h3 id="2-2-动画演示"><a href="#2-2-动画演示" class="headerlink" title="2.2 动画演示"></a>2.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/selectionSort.gif"></p>
<h3 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">let</span> minIndex, temp</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    minIndex = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">        minIndex = j  <span class="comment">// 将最小的索引保存</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minIndex !== i) &#123;</span><br><span class="line">      temp = arr[i]</span><br><span class="line">      arr[i] = arr[minIndex]</span><br><span class="line">      arr[minIndex] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-性能分析"><a href="#2-4-性能分析" class="headerlink" title="2.4 性能分析"></a>2.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(N^2)$<br></li>
<li>  最佳时间复杂度：$O(N^2)$<br></li>
<li>  最差时间复杂度：$O(N^2)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：不稳定</li>
</ul>
<h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. 插入排序（Insertion Sort）</h2><h3 id="3-1-思想"><a href="#3-1-思想" class="headerlink" title="3.1 思想"></a>3.1 思想</h3><ul>
<li>  将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>  从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ul>
<h3 id="3-2-动画演示"><a href="#3-2-动画演示" class="headerlink" title="3.2 动画演示"></a>3.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/insertionSort.gif"></p>
<h3 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a>3.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i], j</span><br><span class="line">    <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;  <span class="comment">// 将当前元素和有序序列元素一一比较，寻找何时的插入位置</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; temp) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-性能分析"><a href="#3-4-性能分析" class="headerlink" title="3.4 性能分析"></a>3.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(N^2)$<br></li>
<li>  最佳时间复杂度：$O(N)$<br></li>
<li>  最差时间复杂度：$O(N^2)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4.希尔排序（Shell Sort）"></a>4.希尔排序（Shell Sort）</h2><h3 id="4-1-思想"><a href="#4-1-思想" class="headerlink" title="4.1 思想"></a>4.1 思想</h3><ul>
<li>  先将整个待排序的记录序列分割成为若干子序列。</li>
<li>  分别进行直接插入排序。</li>
<li>  待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。</li>
</ul>
<h3 id="4-2-动画演示"><a href="#4-2-动画演示" class="headerlink" title="4.2 动画演示"></a>4.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/shellSort.gif"></p>
<h3 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shellSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">let</span> gap = <span class="number">1</span>, temp</span><br><span class="line">  <span class="keyword">while</span> (gap &lt; length / <span class="number">3</span>) &#123;  <span class="comment">// 动态定义间隔序列</span></span><br><span class="line">    gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">      temp = arr[i]</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">        arr[j + gap] = arr[j]</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + gap] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-性能分析"><a href="#4-4-性能分析" class="headerlink" title="4.4 性能分析"></a>4.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(nlogn)$<br></li>
<li>  最佳时间复杂度：$O(nlog^2n)$<br></li>
<li>  最差时间复杂度：$O(nlog^2n)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：不稳定</li>
</ul>
<h2 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5. 归并排序（Merge Sort）"></a>5. 归并排序（Merge Sort）</h2><h3 id="5-1-思想"><a href="#5-1-思想" class="headerlink" title="5.1 思想"></a>5.1 思想</h3><ul>
<li>  把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>  对这两个子序列分别采用归并排序；</li>
<li>  将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<h3 id="5-2-动画演示"><a href="#5-2-动画演示" class="headerlink" title="5.2 动画演示"></a>5.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/mergeSort.gif"></p>
<h3 id="5-3-实现"><a href="#5-3-实现" class="headerlink" title="5.3 实现"></a>5.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> left = arr.slice(<span class="number">0</span>, mid)</span><br><span class="line">  <span class="keyword">let</span> right = arr.slice(mid)</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="comment">// 注意: 判断的条件是小于或等于，如果只是小于，那么排序将不稳定.</span></span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">    result.push(left.shift())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">    result.push(right.shift())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-性能分析"><a href="#5-4-性能分析" class="headerlink" title="5.4 性能分析"></a>5.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(nlogn)$<br></li>
<li>  最佳时间复杂度：$O(nlogn)$<br></li>
<li>  最差时间复杂度：$O(nlogn)$<br></li>
<li>  空间复杂度：$O(n)$<br></li>
<li>  排序方式：Out-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6. 快速排序（Quick Sort）"></a>6. 快速排序（Quick Sort）</h2><h3 id="6-1-思想"><a href="#6-1-思想" class="headerlink" title="6.1 思想"></a>6.1 思想</h3><ul>
<li>  先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。</li>
<li>  左右分别用一个空数组去存储比较后的数据。</li>
<li>  最后递归执行上述操作，直到数组长度 &lt;= 1;</li>
</ul>
<h3 id="6-2-动画演示"><a href="#6-2-动画演示" class="headerlink" title="6.2 动画演示"></a>6.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/quickSort.gif"></p>
<h3 id="6-3-实现"><a href="#6-3-实现" class="headerlink" title="6.3 实现"></a>6.3 实现</h3><ul>
<li><p>方法一：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort1 = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//取基准点</span></span><br><span class="line">  <span class="keyword">const</span> midIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>)</span><br><span class="line">  <span class="comment">//取基准点的值，splice(index,1) 则返回的是含有被删除的元素的数组。</span></span><br><span class="line">  <span class="keyword">const</span> valArr = arr.splice(midIndex, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> midIndexVal = valArr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> left = [], right = []</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; midIndexVal) &#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//递归执行以上操作，对左右两个数组进行操作，直到数组长度为 &lt;= 1</span></span><br><span class="line">  <span class="keyword">return</span> quickSort1(left).concat(midIndexVal, quickSort1(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort2 = <span class="function"><span class="keyword">function</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = arr.length, partitionIndex</span><br><span class="line">  left = <span class="keyword">typeof</span> left !== <span class="string">&#x27;number&#x27;</span> ? <span class="number">0</span> : left</span><br><span class="line">  right = <span class="keyword">typeof</span>  right !== <span class="string">&#x27;number&#x27;</span> ? length - <span class="number">1</span> : right</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    partitionIndex = partition(arr, left, right)</span><br><span class="line">    quickSort2(arr, left, partitionIndex - <span class="number">1</span>)</span><br><span class="line">    quickSort2(arr, partitionIndex + <span class="number">1</span>, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partition = <span class="function">(<span class="params">arr, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//分区操作</span></span><br><span class="line">  <span class="keyword">let</span> pivot = left  <span class="comment">// //设定基准值（pivot）</span></span><br><span class="line">  <span class="keyword">let</span> index = pivot + <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">      swap(arr, i, index)</span><br><span class="line">      index++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, pivot, index - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> index - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">  arr[i] = arr[j]</span><br><span class="line">  arr[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-4-性能分析"><a href="#6-4-性能分析" class="headerlink" title="6.4 性能分析"></a>6.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(nlogn)$<br></li>
<li>  最佳时间复杂度：$O(nlogn)$<br></li>
<li>  最差时间复杂度：$O(n^2)$<br></li>
<li>  空间复杂度：$O(logn)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：不稳定</li>
</ul>
<h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7. 堆排序（Heap Sort）"></a>7. 堆排序（Heap Sort）</h2><h3 id="7-1-思想"><a href="#7-1-思想" class="headerlink" title="7.1 思想"></a>7.1 思想</h3><p>堆其实是一种特殊的树。只要满足这两点，它就是一个堆。</p>
<ul>
<li>  堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li>
<li>  堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</li>
</ul>
<p>对于每个节点的值都<code>大于等于</code>子树中每个节点值的堆，我们叫作<code>大顶堆</code>。 对于每个节点的值都<code>小于等于</code>子树中每个节点值的堆，我们叫作<code>小顶堆</code>。</p>
<ul>
<li>  将初始待排序关键字序列 (R1, R2 …. Rn) 构建成大顶堆，此堆为初始的无序区；</li>
<li>  将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1, R2, ….. Rn-1) 和新的有序区 (Rn) ，且满足 R[1, 2 … n-1] &lt;= R[n]。</li>
<li>  由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1, R2 …… Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1, R2 …. Rn-2) 和新的有序区 (Rn-1, Rn)。不断重复此过程，直到有序区的元素个数为 n - 1，则整个排序过程完成。</li>
</ul>
<h3 id="7-2-动画演示"><a href="#7-2-动画演示" class="headerlink" title="7.2 动画演示"></a>7.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/heapSort.gif"></p>
<h3 id="7-3-实现"><a href="#7-3-实现" class="headerlink" title="7.3 实现"></a>7.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> len</span><br><span class="line"><span class="keyword">const</span> heapSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  buildMaxHeap(arr)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i)</span><br><span class="line">    len--</span><br><span class="line">    heapify(arr, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildMaxHeap = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  len = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">    heapify(arr, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function"><span class="keyword">function</span>(<span class="params">arr, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">2</span> * i + <span class="number">1</span>, right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">  <span class="keyword">let</span> largest = i</span><br><span class="line">  <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = right</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (largest !== i) &#123;</span><br><span class="line">    swap(arr, largest, i)</span><br><span class="line">    heapify(arr, largest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">  arr[i] = arr[j]</span><br><span class="line">  arr[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-性能分析"><a href="#7-4-性能分析" class="headerlink" title="7.4 性能分析"></a>7.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(nlogn)$<br></li>
<li>  最佳时间复杂度：$O(nlogn)$<br></li>
<li>  最差时间复杂度：$O(nlogn)$<br></li>
<li>  空间复杂度：$O(1)$<br></li>
<li>  排序方式：In-place</li>
<li>  稳定性：不稳定</li>
</ul>
<h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8. 计数排序（Counting Sort）"></a>8. 计数排序（Counting Sort）</h2><h3 id="8-1-思想"><a href="#8-1-思想" class="headerlink" title="8.1 思想"></a>8.1 思想</h3><ul>
<li>  找出待排序的数组中最大和最小的元素</li>
<li>  统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>
<li>  对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>  反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ul>
<h3 id="8-2-动画演示"><a href="#8-2-动画演示" class="headerlink" title="8.2 动画演示"></a>8.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/countingSort.gif"></p>
<h3 id="8-3-实现"><a href="#8-3-实现" class="headerlink" title="8.3 实现"></a>8.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countingSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">      max = arr[i]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min &gt; arr[i]) &#123;</span><br><span class="line">      min = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> countArr = <span class="keyword">new</span> <span class="built_in">Array</span>(max - min + <span class="number">1</span>).fill(<span class="number">0</span>)  <span class="comment">// 找出最大值，最小值，根据两者的差来确定计数数组的长度。而不是直接根据最大值开辟数组，节省空间</span></span><br><span class="line">  <span class="keyword">if</span> (countArr.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    countArr[arr[i] - min]++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; max - min + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    countArr[i] += countArr[i - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(length)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[countArr[arr[i] - min] - <span class="number">1</span>] = arr[i]</span><br><span class="line">    countArr[arr[i] - min]--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-性能分析"><a href="#8-4-性能分析" class="headerlink" title="8.4 性能分析"></a>8.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(n+k)$<br></li>
<li>  最佳时间复杂度：$O(n+k)$<br></li>
<li>  最差时间复杂度：$O(n+k)$<br></li>
<li>  空间复杂度：$O(k)$<br></li>
<li>  排序方式：Out-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9. 桶排序（Bucket Sort）"></a>9. 桶排序（Bucket Sort）</h2><h3 id="9-1-思想"><a href="#9-1-思想" class="headerlink" title="9.1 思想"></a>9.1 思想</h3><ul>
<li>  设置一个定量的数组当作空桶；</li>
<li>  遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>  对每个不是空的桶进行排序；</li>
<li>  从不是空的桶里把排好序的数据拼接起来。</li>
</ul>
<h3 id="9-2-动画演示"><a href="#9-2-动画演示" class="headerlink" title="9.2 动画演示"></a>9.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/bucketSort.gif"></p>
<h3 id="9-3-实现"><a href="#9-3-实现" class="headerlink" title="9.3 实现"></a>9.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bucketSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr, bucketSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> length = arr.length</span><br><span class="line">  <span class="keyword">let</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    max = max &lt; arr[i] ? arr[i] : max</span><br><span class="line">    min = min &gt; arr[i] ? arr[i] : min</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bucketSize = bucketSize || <span class="number">5</span> <span class="comment">// 默认一个桶容纳的范围是5</span></span><br><span class="line">  <span class="keyword">let</span> bucketCount = <span class="built_in">Math</span>.floor((max - min)/bucketSize) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(bucketCount)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">    buckets[i] = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    buckets[<span class="built_in">Math</span>.floor((arr[i]-min)/bucketSize)].push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  arr.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">    insertionSort(buckets[i])</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">      arr.push(buckets[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-性能分析"><a href="#9-4-性能分析" class="headerlink" title="9.4 性能分析"></a>9.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(n+k)$<br></li>
<li>  最佳时间复杂度：$O(n+k)$<br></li>
<li>  最差时间复杂度：$O(n^2)$<br></li>
<li>  空间复杂度：$O(n+k)$<br></li>
<li>  排序方式：Out-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10. 基数排序（Radix Sort）"></a>10. 基数排序（Radix Sort）</h2><h3 id="10-1-思想"><a href="#10-1-思想" class="headerlink" title="10.1 思想"></a>10.1 思想</h3><ul>
<li>  取得数组中的最大数，并取得位数；</li>
<li>  arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>  对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<h3 id="10-2-动画演示"><a href="#10-2-动画演示" class="headerlink" title="10.2 动画演示"></a>10.2 动画演示</h3><p><img src="/2021/11/25/sort-algorithm/radixSort.gif"></p>
<h3 id="10-3-实现"><a href="#10-3-实现" class="headerlink" title="10.3 实现"></a>10.3 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> radixSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> max = arr[<span class="number">0</span>], length = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    max = <span class="built_in">Math</span>.max(max, arr[i], -arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> maxDigit = max.toString().length</span><br><span class="line">  <span class="keyword">let</span> mod = <span class="number">10</span>, dev = <span class="number">1</span>, counter = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>)</span><br><span class="line">  <span class="comment">//  考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    counter[i] = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev) + <span class="number">10</span></span><br><span class="line">      counter[bucket].push(arr[j])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> len = counter[j].length</span><br><span class="line">      <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        arr[pos++] = counter[j].shift()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4-性能分析"><a href="#10-4-性能分析" class="headerlink" title="10.4 性能分析"></a>10.4 性能分析</h3><ul>
<li>  平均时间复杂度：$O(n*k)$<br></li>
<li>  最佳时间复杂度：$O(n*k)$<br></li>
<li>  最差时间复杂度：$O(n*k)$<br></li>
<li>  空间复杂度：$O(n+k)$<br></li>
<li>  排序方式：Out-place</li>
<li>  稳定性：稳定</li>
</ul>
<h2 id="11-复杂度对比"><a href="#11-复杂度对比" class="headerlink" title="11. 复杂度对比"></a>11. 复杂度对比</h2><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
<th align="center">排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlog^2n)$</td>
<td align="center">$O(nlog^2n)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(n)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(logn)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(nlogn)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="12-练习地址"><a href="#12-练习地址" class="headerlink" title="12. 练习地址"></a>12. 练习地址</h2><p>可以在力扣912测试代码：<a href="https://leetcode-cn.com/problems/sort-an-array/">https://leetcode-cn.com/problems/sort-an-array/</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML面试题</title>
    <url>/2021/11/24/html/</url>
    <content><![CDATA[<p>绝大部分内容来自：<a href="https://juejin.cn/user/3544481220801815">https://juejin.cn/user/3544481220801815</a></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2021/11/24/html/01.HTML%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="01.HTML面试题"></p>
<h2 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h2><p>src 和 href 都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p>
<ul>
<li>  <strong>src：</strong> 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。常在 img、script、iframe 等元素上使用。</li>
<li>  <strong>href：</strong> 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。这也是为什么建议使用 link 方式加载 css，而不是使用 @import 方式。</li>
</ul>
<h2 id="2-对HTML语义化的理解，SEO优化"><a href="#2-对HTML语义化的理解，SEO优化" class="headerlink" title="2. 对HTML语义化的理解，SEO优化"></a>2. 对HTML语义化的理解，SEO优化</h2><p><strong>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗的来讲就是正确的标签做正确的事情。</p>
<p>语义化的优点如下：</p>
<ul>
<li>  对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li>
<li>  对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li>
</ul>
<p>常见的语义化标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span>  头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span>  导航栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>  区块（有语义化的div）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span>  主要区域</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span>  主要内容</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span>  侧边栏</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span>  底部</span><br></pre></td></tr></table></figure>

<p>写语义化代码应该注意什么：</p>
<ul>
<li>  尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li>
<li>  不要使用纯样式标签，如：b、font、u等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li>
<li>  使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li>
<li>  表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来</li>
</ul>
<p>SEO：</p>
<ol>
<li><p>TKD 设置</p>
<ul>
<li><p>  页面 TKD 要包含品牌词及业务词，提升页面排名</p>
</li>
<li><p>例如：掘金的 TKD</p>
<ul>
<li>  Title：掘金 - 代码不止，掘金不停</li>
<li>  Keywords：掘金,稀土,Vue.js,前端面试题,nginx配置,Kotlin,RxJava,React Native,敏捷开发,Python</li>
<li>  Description：掘金是一个帮助开发者成长的社区,是给开发者用的 <code>Hacker News</code>,给设计师用的 <code>Designer News</code>,和给产品经理用的 <code>Medium</code>。掘金的技术文章由稀土上聚集的技术大牛和极客共同编辑为你筛选出最优质的干货,其中包括：<code>Android、iOS</code>、前端、后端等方面的内容。用户每天都可以在这里找到技术世界的头条内容。与此同时,掘金内还有沸点、掘金翻译计划、线下活动、专栏文章等内容。即使你是 <code>GitHub、StackOverflow、</code>开源中国的用户,我们相信你也可以在这里有所收获。</li>
</ul>
</li>
</ul>
</li>
<li><p>页面内容优化</p>
<ol>
<li> 网页代码语义化调整：多使用语义化标签，便于爬虫搜索。</li>
<li> 页面内容关键词强化：在页面大小标题和文案中重复关键词，以达到内容强化目的；关键词汇避免使用图片，便于爬虫检索，收录。</li>
<li> img 添加 alt 属性，用 h1 标签写内容关键字。</li>
</ol>
</li>
<li><p>引导链接</p>
<ul>
<li>  网站底部推荐部分保留产品介绍、常见问题汇总等降低跳出率的引导，提高页面留存与转化；或者与所推荐页面形成互链形式，以稳定页面流量权重。</li>
</ul>
</li>
<li><p>移动端优化</p>
<ul>
<li>  设置移动页面，或者将 pc 页面设置为自适应，增加移动端搜索的体验和留存转化</li>
<li>移动页面设计需注意以下原则：<ol>
<li> 页面字体、字符大小、文本行间距等设计，应适合手机用户阅读，不可明显过大过小，正文文本字号不小于 10pt（pt：绝对单位，等于1/72英寸）。</li>
<li> 首屏主体内容必须占屏幕的 50% 以上。</li>
<li> 主体内容应与其它板块有明显区分，且位于屏幕的中心位置，使用户获取信息是不受任何干扰。</li>
<li> 导航的功能与位置明确，避免用户使用过程中被误导</li>
<li> 除以上提到的内容外，网站还应避免其他影响页面内容辨识的情况，例如页面出现大面积空白、文本无任何排版、段落/图片排版错乱不整齐、主体内容展示不全等。</li>
</ol>
</li>
</ul>
</li>
<li><p>站外优化</p>
<ol>
<li> 在搜索引擎排名较高的公众平台发布正面网站信息，以建设良好口碑；负面信息排名较高的需删除或者屏蔽处理。</li>
<li> 百度，互动，搜狗等百科的创建更新与维护，(互动百科在今日头条有着较高的排名，现在今日头条也在发展搜素引擎)，百科对树立品牌形象较为重要。</li>
<li> 公关舆情传播，宣传新闻源发布。</li>
<li> 站外推广与外链建设。</li>
<li> 根据竞争对手及品牌业务分析，拓展高质量、高权重的外链渠道、科技论坛、自媒体平台、分类信息网等，发布高质量锚文本外链，另进行友情链接交换，以提高关键词排名及自然流量。</li>
</ol>
</li>
</ol>
<h2 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h2><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p>
<p>浏览器渲染页面的两种模式（可通过<strong>document.compatMode</strong>获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p>
<ul>
<li>  <strong>CSS1Compat：标准模式（Standards mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li>
<li>  **BackCompat：怪异模式(混杂模式)(Quicks mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li>
</ul>
<blockquote>
<p>  MDN：在 HTML5 中，DOCTYPE 唯一的作用是启用标准模式。更早期的 HTML 标准中，DOCTYPE 会附加其他意义，但没有任何浏览器会将 DOCTYPE 用于怪异模式和标准模式之间互换以外的用途。</p>
<p>  《JavaScript高级程序设计》：</p>
<p>  ​    IE5.5 发明了文档模式的概念，即可以使用 doctype 切换文档模式。最初的文档模式有两种：混杂模式和标准模式。前者让 IE 像 IE5 一样（支持一些非标准的特性），后者让 IE 具有兼容标准的行为。</p>
<p>  ​    IE 初次支持文档模式切换以后，其它浏览器用也跟着实现了。随着浏览器的普遍出现，又出现了第三种文档模式：准标准模式。这种模式下的浏览器支持很多标准的特性，但是没有标准规定的那么严格。主要区别在于如何对待图片元素周围的空白（在表格中使用图片最为明显）。</p>
</blockquote>
<h2 id="4-script标签中defer和async的区别，还有哪些属性？"><a href="#4-script标签中defer和async的区别，还有哪些属性？" class="headerlink" title="4. script标签中defer和async的区别，还有哪些属性？"></a>4. script标签中defer和async的区别，还有哪些属性？</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>
<p>下图可以直观的看出三者之间的区别:</p>
<p><img src="/2021/11/24/html/01-4.png" alt="01-4"></p>
<ul>
<li>defer 属性：推迟执行脚本。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。<ul>
<li>  在 &lt;script&gt; 标签上设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。</li>
<li>  HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，并且会在 DOMContentLoaded 事件之前执行。不过在实际当中，不一定总会按照顺序或者在 DOMContentLoaded 事件之前执行。</li>
</ul>
</li>
<li>async 属性（<strong>HTML5</strong>）：异步执行脚本。表示应该立即请求脚本，并尽快解析和执行，但不能阻止其它页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。<ul>
<li>  告诉浏览器立即下载，但不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行完后在加载其它脚本。（因此，异步脚本不应该在加载期间修改 DOM）</li>
<li>  标记为 async 的脚本并不保证能按照它们出现的次序执行。异步脚本保证会在页面的的 <strong>load</strong> 事件前执行，但可能会在 <strong>DOMContentLoaded</strong> 之前或之后。</li>
</ul>
</li>
</ul>
<p>除上述外，&lt;script&gt; 标签还有以下属性：</p>
<ul>
<li>  charset：使用 src 属性指定的代码字符集。很少使用，因为大多数浏览器不在乎它的值。</li>
<li>  crossorigin：那些没有通过标准CORS (跨域资源共享)检查的正常script 元素传递最少的信息到 window.onerror。可以使用本属性来使那些将静态资源放在另外一个域名的站点打印错误信息。默认不使用 CORS，“” 相当于 “anonymous” ，对此元素的 CORS 请求不设置凭据标志；“use-credentials”，对此元素的 CORS 请求将设置凭证标志，这意味着请求将提供凭据。</li>
<li>  integrity：允许对比接收到的资源和指定的加密签名以验证子资源完整性（SRI）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN）不会提供恶意内容。</li>
<li>  nomodule：这个布尔属性被设置来标明这个脚本在支持 ES2015 modules 的浏览器中不执行。实际上，这可用于在不支持模块化 JavaScript 的旧浏览器中提供回退脚本。</li>
<li>  language：废弃。最初用于表示代码块中的脚本语言。大多数浏览器都会忽略这个属性，不应该再使用它。</li>
<li>  src：定义引用外部脚本的URI，这可以用来代替直接在文档中嵌入脚本。指定了 src 属性的script元素标签内不应该再有嵌入的脚本。</li>
<li>  type：代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型：<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></strong>）。支持的MIME类型包括text/javascript, text/ecmascript, application/javascript（非IE支持）, 和application/ecmascript（非IE支持）。如果没有定义这个属性，脚本会被视作JavaScript。如果MIME类型不是JavaScript类型（上述支持的类型），则该元素所包含的内容会被当作数据块而不会被浏览器执行。JS 文件中的MIME 类型通常是 “application/x-javascript” 。如果type属性为module，代码会被当作JavaScript模块 。</li>
<li>  text：和 textContent 属性类似，本属性用于设置元素的文本内容。但和 textContent 不一样的是，本属性在节点插入到DOM之后，此属性被解析为可执行代码。</li>
</ul>
<h2 id="5-meta，常⽤的meta（元数据）标签有哪些"><a href="#5-meta，常⽤的meta（元数据）标签有哪些" class="headerlink" title="5. meta，常⽤的meta（元数据）标签有哪些"></a>5. meta，常⽤的meta（元数据）标签有哪些</h2><blockquote>
<p>  每个 meta 只能用于一种用途。如果在这些特性中想要使用的不值一个，那就应该在 head 元素中添加多个 meta 元素。</p>
</blockquote>
<p><code>meta</code> <strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。放在 head 元素中。</p>
<p><code>meta</code> 元素定义的元数据的类型包括以下几种：</p>
<ul>
<li>  如果设置了 <code>name</code> 属性，<code>meta</code> 元素提供的是文档级别（<em>document-level</em>）的元数据，应用于整个页面。</li>
<li>  如果设置了 <code>http-equiv</code> 属性，<code>meta</code> 元素则是编译指令，提供的信息与类似命名的HTTP头部相同。</li>
<li>  如果设置了 <code>charset </code> 属性（<strong>HTML5</strong>），<code>meta</code> 元素是一个字符集声明，告诉文档使用哪种字符编码。</li>
<li>  如果设置了 <code>itemprop</code> 属性，<code>meta</code> 元素提供用户定义的元数据。</li>
</ul>
<p><code>meta</code> 包含的属性：</p>
<blockquote>
<p>  注意: 全局属性 <code>name</code> 在 &lt;meta&gt; 元素中具有特殊的语义；另外， 在同一个 &lt;meta&gt; 标签中，<code>name</code>, <code>http-equiv</code> 或者 <code>charset</code> 三者中任何一个属性存在时，<code>itemprop</code> 属性不能被使用。</p>
</blockquote>
<ul>
<li><p>  <code>charset</code>：这个属性声明了文档的字符编码。如果使用了这个属性，其值必须是与ASCII大小写无关（ASCII case-insensitive）的”<code>utf-8</code>“。</p>
</li>
<li><p>  <code>content</code>：此属性包含 <code>http-equiv</code> 或 <code>name</code> 属性的值，具体取决于所使用的值。</p>
</li>
<li><p><code>http-equiv</code>：属性定义了一个编译指示指令。这个属性叫做 <code>http-equiv(alent)</code> 是因为所有允许的值都是特定HTTP头部的名称，如下：</p>
<ul>
<li><p><code>content-security-policy</code><br>  它允许页面作者定义当前页的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">内容策略</a>。 内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。</p>
</li>
<li><p><code>content-type</code><br>  如果使用这个属性，其值必须是”<code>text/html; charset=utf-8</code>“。注意：该属性只能用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a> 为 <code>text/html</code> 的文档，不能用于MIME类型为XML的文档。</p>
</li>
<li><p><code>default-style</code></p>
<p>  设置默认 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS 样式表</a>组的名称。</p>
</li>
<li><p><code>x-ua-compatible</code><br>  如果指定，则 <code>content</code> 属性必须具有值 “<code>IE=edge</code>“。用户代理必须忽略此指示。</p>
</li>
<li><p><code>refresh</code></p>
<p>  这个属性指定:</p>
<ul>
<li>  如果 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content"><code>content</code></a> 只包含一个正整数，则为重新载入页面的时间间隔(秒)；</li>
<li>  如果 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content"><code>content</code></a> 包含一个正整数，并且后面跟着字符串 ‘<code>;url=</code>‘ 和一个合法的 URL，则是重定向到指定链接的时间间隔(秒)</li>
</ul>
</li>
</ul>
</li>
<li><p><code>name</code></p>
<ul>
<li>  <code>name</code> 和 <code>content</code> 属性可以一起使用，以名-值对的方式给文档提供元数据，其中 name 作为元数据的名称，content 作为元数据的值。</li>
<li>  在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name">标准元数据名称</a>（见下方元数据名称）中查看 HTML 规范等规范中定义的标准元数据名称。</li>
</ul>
</li>
</ul>
<p><code>meta</code> 用途：</p>
<ul>
<li>  指定名/值元数据对</li>
<li>  声明字符编码</li>
<li>  模拟 HTTP 标头字段</li>
</ul>
<p>常用的 <code>meta</code> 标签：</p>
<ol>
<li><p><code>charset</code>，用来描述 HTML 文档的编码类型：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>keywords</code>，页面关键词：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>description</code>，页面描述：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;页面描述内容&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>refresh</code>，页面重定向和刷新：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li>  <code>width viewport</code> ：宽度(数值/device-width)</li>
<li>  <code>height viewport</code> ：高度(数值/device-height)</li>
<li>  <code>initial-scale</code> ：初始缩放比例</li>
<li>  <code>maximum-scale</code> ：最大缩放比例</li>
<li>  <code>minimum-scale</code> ：最小缩放比例</li>
<li>  <code>user-scalable</code> ：是否允许用户缩放(yes/no）</li>
</ul>
</li>
<li><p>搜索引擎索引方式：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p> 其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li>  <code>all</code>：文件将被检索，且页面上的链接可以被查询；</li>
<li>  <code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li>
<li>  <code>index</code>：文件将被检索；</li>
<li>  <code>follow</code>：页面上的链接可以被查询；</li>
<li>  <code>noindex</code>：文件将不被检索；</li>
<li>  <code>nofollow</code>：页面上的链接不可以被查询。</li>
</ul>
</li>
</ol>
<p>元数据名称（参考）：</p>
<ol>
<li><p>HTML 规范定义的标准元数据名称</p>
<ul>
<li><p>  application-name：网页中所运行的应用程序的名称</p>
</li>
<li><p>  author：文档作者的名字</p>
</li>
<li><p>  description：一段简短而精确的、对页面内容的描述。一些浏览器，比如 Firefox 和 Opera，将其用作书签的默认描述。</p>
</li>
<li><p>  generator：用来生成 HTML 的软件名称</p>
</li>
<li><p>  keywords：与页面内容相关的关键词，常以逗号分隔</p>
</li>
<li><p>referrer：控制有当前文档发出的请求的 HTTP Referer 请求头</p>
<ul>
<li><p>  &lt;meta name=”referrer”&gt; 的 content 属性的值</p>
</li>
<li><table>
<thead>
<tr>
<th align="left">content</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">no-referrer</td>
<td align="left">不发送 HTTP <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 请求头。</td>
</tr>
<tr>
<td align="left">origin</td>
<td align="left">只发送当前文档的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a>。</td>
</tr>
<tr>
<td align="left">no-referrer-when-downgrade</td>
<td align="left">如果请求目标与当前页面一样安全或者更加安全（HTTP(S)→HTTPS），则发送完整 URL；<br />如果请求目标更加不安全（HTTPS→HTTP），则不发送 referrer。这是默认行为。</td>
</tr>
<tr>
<td align="left">origin-when-cross-origin</td>
<td align="left">对同源请求发送完整 URL（不含 URL 参数），其他情况下，只发送 origin。</td>
</tr>
<tr>
<td align="left">same-origin</td>
<td align="left">对同源请求发送完整 URL（不含 URL 参数），其他情况下，请求不包含 referrer 请求头。</td>
</tr>
<tr>
<td align="left">strict-origin</td>
<td align="left">如果请求目标与当前页面一样安全或者更加安全（HTTP(S)→HTTPS），则发送 origin；<br />如果请求目标更加不安全（HTTPS→HTTP），则不发送 referrer。</td>
</tr>
<tr>
<td align="left">strict-origin-when-cross-origin</td>
<td align="left">对同源请求发送完整 URL（不含 URL 参数）；<br />其他情况下，如果请求目标与当前页面一样安全或者更加安全（HTTP(S)→HTTPS），则发送 origin；<br />如果请求目标更加不安全（HTTPS→HTTP），则不发送 referrer。</td>
</tr>
<tr>
<td align="left">unsafe-URL</td>
<td align="left">对同源请求和跨源请求发送完整 URL（不含 URL 参数）。</td>
</tr>
</tbody></table>
</li>
<li><blockquote>
<p>  备注：<br>  动态插入 &lt;meta name=”referrer”&gt;（使用 document.write() 方法或者 appendChild() 等方法）会使 referrer 行为变得不可预测。<br>  如果定义了互相冲突的策略，则会转而使用 no-referrer 策略。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>  theme-color：表示当前页面的建议颜色，在自定义当前页面从或页面周围的用户界面的显示时，用户代理应当使用此颜色。content 属性应当包含一个有效的 CSS &lt;color&gt; 值。</p>
</li>
</ul>
</li>
<li><p>CSS 颜色调整规范定义的元数据名称</p>
<ul>
<li><p><code>color-scheme</code>: 指定与当前文档兼容的一种或多种配色方案。</p>
<p>  浏览器将优先采用此元数据的值，然后再使用用户的浏览器或设备设置，来确定页面上的各种默认颜色和元素外观，例如背景色、前景色、窗体控件和滚动条。<code>&lt;meta name=&quot;color-scheme&quot;&gt;</code> 的主要用途是指示当前页面与浅色模式和深色模式的兼容性，以及选用这两种模式时的优先顺序。</p>
<p>  <code>color-scheme</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content"><code>content</code></a> 属性的值应当为以下值中的一个：</p>
<ul>
<li><p><code>normal</code></p>
<p>  该文档未指定（unaware of）配色方案，应当仅使用默认配色进行渲染。</p>
</li>
<li><p>[<code>light</code> | <code>dark</code>]+</p>
<p>  文档所支持的一种或多种配色方案。如果多次指定同一个配色方案，则与仅指定一次效果相同。如果指定了多种配色方案，则表示文档优先选择第一种方案——如果用户更倾向于选择第二种配色方案，则可以接受第二种。</p>
</li>
<li><p><code>only light</code></p>
<p>  表示文档<em>仅</em>支持浅色模式，也就是浅色背景色和深色前景色。按照规范，<code>only dark</code> <em>是无效的</em>。如果在文档不支持深色模式的情况下强迫其以深色模式进行渲染，会导致内容不可读。所以，在未经配置的情况下，所有主要浏览器均默认使用浅色模式。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CSS 设备适配规范定义的元数据名称</p>
<ul>
<li><p><code>viewport</code>: 为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport">viewport</a>（视口）的初始大小提供指示（hint）。目前仅用于移动设备。</p>
<ul>
<li><p>  &lt;meta name=”viewport”&gt; 的 content 属性的值</p>
</li>
<li><table>
<thead>
<tr>
<th>值</th>
<th>可能附加的值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>一个正整数，或者字符串 <code>device-width</code></td>
<td>定义 viewport 的宽度，如果值为正整数，则单位为像素。</td>
</tr>
<tr>
<td>height</td>
<td>一个正整数，或者字符串 <code>device-height</code></td>
<td>定义 viewport 的高度。未被任何浏览器使用。</td>
</tr>
<tr>
<td>initial-scale</td>
<td>一个 <code>0.0</code> 和 <code>10.0</code> 之间的正数</td>
<td>定义设备宽度（宽度和高度中更小的那个：如果是纵向屏幕，就是 <code>device-width</code>，如果是横向屏幕，就是 <code>device-height</code>）与 viewport 大小之间的缩放比例。</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>一个 <code>0.0</code> 和 <code>10.0</code> 之间的正数</td>
<td>定义缩放的最大值，必须大于等于 <code>minimum-scale</code>，否则表现将不可预测。<br />浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>一个 <code>0.0</code> 和 <code>10.0</code> 之间的正数</td>
<td>定义缩放的最小值，必须小于等于 <code>maximum-scale</code>，否则表现将不可预测。<br />浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。</td>
</tr>
<tr>
<td>user-scalable</td>
<td><code>yes</code> 或者 <code>no</code></td>
<td>默认为 <code>yes</code>，如果设置为 <code>no</code>，用户将无法缩放当前页面。<br />浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。</td>
</tr>
<tr>
<td>viewport-fit</td>
<td><code>auto</code>、<code>contain</code> 或者 <code>cover</code></td>
<td>该<code>auto</code>值不影响初始布局视口，整个网页都是可见的。<br />该<code>contain</code>值表示视口被缩放以适应显示中内接的最大矩形。<br />该<code>cover</code>值意味着缩放视口以填充设备显示。强烈建议使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/env()">安全区域插入</a>变量来确保重要内容不会出现在显示之外。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>其它元数据名称</p>
<ul>
<li><p>  <code>creator</code>：当前文档的创建者，例如某个组织或者机构。如果有不止一个创建者，则应当使用多个名称为 <code>creator</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">``</a> 元素。（而不是像关键词一样使用逗号分隔：关键词不应包含逗号，但创建者名称可能含有逗号。）</p>
</li>
<li><p>  <code>googlebot</code>：<code>robots</code> 的替代名称，只被 Googlebot（Google 的网页爬虫/索引搜寻器）使用。</p>
</li>
<li><p>  <code>publisher</code>：当前文档的发布者/出版者。</p>
</li>
<li><p><code>robots</code>：爬虫、协作搜寻器，或者“机器人”，对此页面的处理行为，或者说，应当遵守的规则。是一个使用逗号分隔的、由下列值构成的列表：</p>
<ul>
<li><p>  &lt;meta name=”robots”&gt; 的 content 属性的值</p>
</li>
<li><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>被用于</th>
</tr>
</thead>
<tbody><tr>
<td><code>index</code></td>
<td>允许机器人索引此页面（默认）。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>noindex</code></td>
<td>要求机器人不索引此页面。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>follow</code></td>
<td>允许机器人跟随此页面上的链接（默认）。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>nofollow</code></td>
<td>要求机器人不跟随此页面上的链接。</td>
<td>所有爬虫</td>
</tr>
<tr>
<td><code>all</code></td>
<td>与 <code>index, follow</code> 等价</td>
<td><a href="https://support.google.com/webmasters/answer/79812">谷歌</a></td>
</tr>
<tr>
<td><code>none</code></td>
<td>与 <code>noindex, nofollow</code> 等价</td>
<td><a href="https://support.google.com/webmasters/answer/79812">谷歌</a></td>
</tr>
<tr>
<td><code>noarchive</code></td>
<td>要求搜索引擎不缓存页面内容。</td>
<td><a href="https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives">谷歌</a>、<a href="https://help.yahoo.com/kb/search-for-desktop/SLN2213.html">雅虎</a>、<a href="https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240">Bing</a></td>
</tr>
<tr>
<td><code>nosnippet</code></td>
<td>防止在搜索引擎结果中显示页面的任何描述。</td>
<td><a href="https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives">谷歌</a>、<a href="https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240">Bing</a></td>
</tr>
<tr>
<td><code>noimageindex</code></td>
<td>要求此页面不显示为索引图像的引用页面。</td>
<td><a href="https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives">谷歌</a></td>
</tr>
<tr>
<td><code>nocache</code></td>
<td><code>noarchive</code> 的替代名称。</td>
<td><a href="https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240">Bing</a></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h2><p><strong>1.新的 DOCTYPE 和字符集</strong></p>
<ul>
<li><p>HTML4</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>HTML5</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 语义化标签</strong></p>
<table>
<thead>
<tr>
<th align="center">元素</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">address</td>
<td align="center">表示文档或article的联系信息</td>
</tr>
<tr>
<td align="center">article</td>
<td align="center">表示一段独立的内容</td>
</tr>
<tr>
<td align="center">aside</td>
<td align="center">表示与周边内容稍有牵涉的内容，相关内容或引文</td>
</tr>
<tr>
<td align="center">details</td>
<td align="center">生成一个区域，用户将其展开可以获得更多细节知识</td>
</tr>
<tr>
<td align="center">footer</td>
<td align="center">表示尾部</td>
</tr>
<tr>
<td align="center">header</td>
<td align="center">表示首部</td>
</tr>
<tr>
<td align="center">hgroup</td>
<td align="center">将一组标题组织在一起，以便文档大纲只显示其中第一个标题</td>
</tr>
<tr>
<td align="center">nav</td>
<td align="center">表示有意集中在一起的导航元素</td>
</tr>
<tr>
<td align="center">section</td>
<td align="center">表示一个重要的概念或主题</td>
</tr>
<tr>
<td align="center">summary</td>
<td align="center">用在 details 元素中，表示该元素内容的标题或说明</td>
</tr>
</tbody></table>
<p><strong>3. 媒体标签</strong></p>
<ol>
<li><p>audio：在网页里嵌入音频内容</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">autoplay</td>
<td align="center">如果存在，此属性会使浏览器尽可能立刻开始播放视频</td>
</tr>
<tr>
<td align="center">preload</td>
<td align="center">告诉浏览器是否要预先载入视频<br />none：用户开始播放之前不会载入视频<br />metadata：用户开始播放之前只能载入视频的元数据（音频长度和其它此类信息）<br />auto：请求浏览器尽快下载整个视频。浏览器可以忽略这个请求。这是默认行为</td>
</tr>
<tr>
<td align="center">controls</td>
<td align="center">除非此属性存在，否则浏览器不会显示播放控件</td>
</tr>
<tr>
<td align="center">loop</td>
<td align="center">如果存在，此属性会让浏览器反复播放视频</td>
</tr>
<tr>
<td align="center">muted</td>
<td align="center">如果此属性存在，视频从一开始就会处于静音状态</td>
</tr>
<tr>
<td align="center">src</td>
<td align="center">指定要显示的视频</td>
</tr>
</tbody></table>
</li>
<li><p>video：在网页里嵌入视频内容</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">poster</span>=<span class="string">&#x27;imgs/aa.jpg&#x27;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">autoplay</td>
<td align="center">如果存在，此属性会使浏览器尽可能立刻开始播放视频</td>
</tr>
<tr>
<td align="center">preload</td>
<td align="center">告诉浏览器是否要预先载入视频<br />none：用户开始播放之前不会载入视频<br />metadata：用户开始播放之前只能载入视频的元数据（宽度、高度、第一帧、长度和其它此类信息）<br />auto：请求浏览器尽快下载整个视频。浏览器可以忽略这个请求。这是默认行为</td>
</tr>
<tr>
<td align="center">controls</td>
<td align="center">除非此属性存在，否则浏览器不会显示播放控件</td>
</tr>
<tr>
<td align="center">loop</td>
<td align="center">如果存在，此属性会让浏览器反复播放视频</td>
</tr>
<tr>
<td align="center">poster</td>
<td align="center">指定在视频数据载入时显示的图片</td>
</tr>
<tr>
<td align="center">height</td>
<td align="center">指定视频的高度</td>
</tr>
<tr>
<td align="center">width</td>
<td align="center">指定视频的宽度</td>
</tr>
<tr>
<td align="center">muted</td>
<td align="center">如果此属性存在，视频从一开始就会处于静音状态</td>
</tr>
<tr>
<td align="center">src</td>
<td align="center">指定要显示的视频</td>
</tr>
</tbody></table>
</li>
<li><p>source：因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p>
<p> 浏览器重点支持的视频格式：</p>
<table>
<thead>
<tr>
<th align="center">格式</th>
<th align="center">说明</th>
<th align="center">支持</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WebM</td>
<td align="center">此格式由谷歌提供支持，目标是创建一个无专利约束，免版税的格式</td>
<td align="center">Opera、Chrome、Firefox</td>
</tr>
<tr>
<td align="center">Ogg/Theora</td>
<td align="center">Ogg Theora 是一种开放、免版税和无专利约束的格式</td>
<td align="center">Opera、Chrome、Firefox</td>
</tr>
<tr>
<td align="center">MP4/H.264</td>
<td align="center">暂无</td>
<td align="center">IE、Chrome、Safari</td>
</tr>
</tbody></table>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;images/s1.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;images/s1.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;images/s1.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>track：提供了一套视频相关内容的实现机制。这些内容包括字幕、说明和章节标题。</p>
<p> MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track</a></p>
</li>
</ol>
<p><strong>4. 表单</strong></p>
<p><strong>表单类型：</strong></p>
<ul>
<li>  email ：能够验证当前输入的邮箱地址是否合法</li>
<li>  url ： 验证URL</li>
<li>  tel：验证电话号码</li>
<li>  number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li>
<li>  search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li>
<li>  range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li>
<li>  color ： 提供了一个颜色拾取器</li>
<li>  time ： 时分秒</li>
<li>  data ： 日期选择年月日</li>
<li>  datatime ： 时间和日期(目前只有Safari支持)</li>
<li>  datatime-local ：日期时间控件</li>
<li>  week ：周控件</li>
<li>  month：月控件</li>
</ul>
<p><strong>表单属性：</strong></p>
<ul>
<li>  placeholder ：提示信息</li>
<li>  autofocus ：自动获取焦点</li>
<li>autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：<ul>
<li>  表单必须提交过</li>
<li>  必须有name属性。</li>
</ul>
</li>
<li>  required：要求输入框不能为空，必须有值才能够提交。</li>
<li>  pattern=” “ 里面写入想要的正则模式，例如手机号patte=”^(+86)?\d{10}$”</li>
<li>  multiple：可以选择多个文件或者多个邮箱</li>
<li>  form=” form表单的ID”</li>
<li>  novalidate 不经输入验证就能提交表单</li>
</ul>
<p><strong>表单事件：</strong></p>
<ul>
<li>  oninput 每当input里的输入框内容发生变化都会触发此事件。</li>
<li>  oninvalid 当验证不通过时触发此事件。</li>
</ul>
<p><strong>附：</strong></p>
<p><img src="/2021/11/24/html/01-6.png" alt="01-6"></p>
<p><strong>5. 进度条、度量器</strong></p>
<ul>
<li>  progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</li>
<li>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）<ul>
<li>  high/low：规定被视作高/低的范围</li>
<li>  max/min：规定最大/小值</li>
<li>  value：规定当前度量值</li>
</ul>
</li>
</ul>
<p>设置规则：min &lt; low &lt; high &lt; max</p>
<p><strong>6.DOM查询操作</strong></p>
<ul>
<li>  document.querySelector()</li>
<li>  document.querySelectorAll()</li>
</ul>
<p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p>
<p><strong>7. Web存储</strong></p>
<p>HTML5 提供了两种在客户端存储数据的新方法：</p>
<ul>
<li>  localStorage - 没有时间限制的数据存储</li>
<li>  sessionStorage - 针对一个 session 的数据存储</li>
</ul>
<p><strong>8. 其他</strong></p>
<ul>
<li>  拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li>
<li>  Geolocation API（地理定位）用于定位用户的位置。</li>
<li>  WebSockets</li>
<li>  Web Workers</li>
<li>  Web Storage API</li>
<li>  Communication API</li>
<li>  History API</li>
</ul>
<p><strong>总结(不全，还没改)：</strong> （1）新增语义化标签：nav、header、footer、aside、section、article （2）音频、视频标签：audio、video （3）数据存储：localStorage、sessionStorage （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） （5）input标签新增属性：placeholder、autocomplete、autofocus、required （6）history API：go、forward、back、pushstate</p>
<p><strong>移除的元素有(<a href="https://html.spec.whatwg.org/multipage/obsolete.html)%EF%BC%9A">https://html.spec.whatwg.org/multipage/obsolete.html)：</a></strong></p>
<ul>
<li>  纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li>
<li>  对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<h2 id="7-img的srcset属性的作⽤？"><a href="#7-img的srcset属性的作⽤？" class="headerlink" title="7. img的srcset属性的作⽤？"></a>7. img的srcset属性的作⽤？</h2><p>H5中img有两个新属性，<code>srcset</code>和<code>sizes</code>，主要作用：</p>
<ul>
<li>  控制响应式图片，根据屏幕大小来选择显示不同图片</li>
<li>  根据屏幕的不同（视网膜屏幕还是普通屏），展示不同质量的图片，合理控制下载资源，以及带给用户高质量享受。</li>
</ul>
<p><strong>srcset：</strong></p>
<ol>
<li><p>格式一：图片源地址 空格 图片像素宽度[，图片源地址 空格 图片像素宽度，…]，如</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">srcset=&quot;1.jpg 580w, 2.png 618w&quot;</span><br></pre></td></tr></table></figure>

<p> 表示图片<code>1.jpg</code>的像素宽度为<code>580px</code>，图片<code>2.png</code>的像素宽度为<code>618px</code>，两个图片源之间用逗号隔开。</p>
<p> <strong>千万注意：描述图片的像素宽度是用’w’单位，且一定要是图片的真实像素宽度，如果私自改动，那么会影响浏览器对图片的选择！</strong><del>这里的以 w 后缀的值并不是 “真实” 大小，它只是对浏览器的一个提示，大致等于图片的 “CSS像素” 大小。</del></p>
<p> 其实上述例子类似给了个默认的<code>sizes</code>属性（具体下面再讲）</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">srcset=&quot;1.jpg 580w, 2.png 618w&quot; sizes=&quot;100vw&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>格式二：图片源地址 空格 屏幕像素密度[, 图片源地址 空格 屏幕像素密度, …]，如</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">srcset=&quot;1.jpg 1x, 2.png 2x&quot;</span><br></pre></td></tr></table></figure>

<p> 表示图片<code>1.jpg</code>为DPR（**DPR = 设备像素 / CSS像素(某一方向上)**）为1时下显示的图片；<code>2.png</code>为DPR为2时显示的图片，如果没有更大的DPR设置的图片源，那么当大于当前设置的DPR最高值时，会采用当前设置的最大DPR的图片源。如这里如果屏幕DPR为3，那么还是会用<code>2.png</code>。</p>
</li>
<li><p> 小结：在浏览器支持<code>srcset</code>的情况下，<code>src</code>值就成为了一个<code>1x</code>情况下的候选图片，在没有符合条件的情况下，会采用该值。</p>
</li>
</ol>
<p><strong>sizes：</strong>只有当设置了<code>srcset</code>，且单位为<code>w</code>时，<code>sizes</code>的设置才会起效。浏览器先根据<code>sizes</code>设定的条件下，找出此刻图片显示的宽度，然后根据这个宽度去<code>srcset</code>里找符合条件的图片。</p>
<ul>
<li><p>浏览器的选取规则</p>
<ul>
<li>  srcset中设置的图片像素宽度（’w’的值），组成了相应的半开半闭区间(a, b]。 图片的显示宽度（sizes规定的值）看落在哪个区间内，取区间中最大值对应的图片。若没有最大值（如∞），则取上个区间最大值。</li>
<li>如<code>&lt;img src=&quot;4.jpg&quot; srcset=&quot;3.jpg 229w,2.png 618w,1.jpg 1000w&quot;, sizes=&quot;300px&quot;&gt;</code><ul>
<li>  上面设置图片要显示成<code>300px</code>（<code>sizes</code>里的值），在<code>srcset</code>里的几个临界值中形成了<code>(0, 229px]</code>、<code>(229px, 618px]</code>、<code>(618px, 1000px]</code>、<code>(1000px, ∞]</code>。<code>300px</code>落在了<code>(229px, 618px]</code>中，取最大值<code>618</code>，因此最终选择的图片就是<code>2.png</code></li>
<li>  如果<code>sizes</code>改成<code>1200px</code>，按照上述规则，最终会选取<code>1000w</code>的<code>1.jpg</code></li>
<li>  注意：srcset里的顺序不重要，不会受到影响。</li>
</ul>
</li>
</ul>
</li>
<li><p>sizes 的语法结构</p>
<ul>
<li><p>[媒体查询 空格 ]图片显示宽度[, [媒体查询 空格 ]图片显示宽], …, 其余条件宽度值]</p>
<p>  图片的宽度值单位不能为<code>%</code>，其余正常单位可以使用</p>
</li>
<li><p>举例：<code>sizes=&quot;(max-width: 500px) 400px, (max-width: 900px) 700px, 1200px&quot;</code></p>
<ul>
<li>  上面的意思就是，在屏幕小于等于500px情况下，图片显示成400px宽；在屏幕小于等于900px情况下，图片显示成700px宽；其余情况显示成1200px宽。</li>
<li>  因此，可根据这种<code>sizes</code>值，判断在哪个屏幕大小下显示什么宽度的图片，然后根据这个宽度值去<code>srcset</code>里找满足条件的图片源。</li>
</ul>
</li>
<li><p>所以下面这个例子：<code>&lt;img src=&quot;4.jpg&quot; srcset=&quot;3.jpg 229w,2.png 618w,1.jpg 1000w&quot;, sizes=&quot;(max-width: 500px) 400px, (max-width: 900px) 700px, 1200px&quot;&gt;</code></p>
<ul>
<li>  在屏幕小于等于500px情况下，图片显示成400px宽，选取<code>2.png</code>；在屏幕小于等于900px情况下，图片显示成700px宽，选取<code>1.jpg</code>；其余情况显示成1200px宽，还是选取<code>1.jpg</code>。</li>
<li>  注意：sizes里的媒体查询条件顺序是很重要的，只要满足了越靠前的某个条件，那么后面的条件会被忽略的</li>
</ul>
</li>
</ul>
</li>
<li><p>如果<code>sizes</code>属性没有值，或者在有媒体条件下，其余条件宽度没有设值，那么默认是<code>100vw</code></p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;100vw&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span>, <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 500px) 400px&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg 229w,2.png 618w&quot;</span>, <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 500px) 400px, 100vw&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  这种时候，就是直接根据屏幕的宽度来决定选取哪个图片源了。</p>
</li>
</ul>
<p><strong>DPR的影响</strong></p>
<p>上述内容，都是在DPR为1的情况下说明的，主要针对PC端吧。那如果是手机端，DPR不单单是1，还有2，3的情况。这时候其实上述内容的规则还是不会变的，但是我们需要做一些值的转化才能套用上述规则。这里主要是说’w’的情况下浏览器如何去选择</p>
<p>例如：<code>&lt;img src=&quot;4.jpg&quot; srcset=&quot;3.jpg 229w,2.png 618w&quot; sizes=&quot;(max-width: 600px) 114px&quot;&gt;</code></p>
<p>首先我们要知道，srcset里的’w’符号，是代表的是图像的宽度像素，是个物理像素；sizes里的114px是表示逻辑像素！</p>
<p>而浏览器对图片的选择，是要转化为同一概念上的像素才能进行对比的，总不能拿着逻辑像素值去物理像素区间里做比较吧？</p>
<p>因此，在DPR不为1时，要转化一下像素值才能去区间里比较，套用上述规则。</p>
<p>如在DPR=2时，把114px转化为物理像素，即114px * 2 = 228px，用228px去(0, 229px]、(229px, 618px]、(618px, ∞]里做比较，落在了(0, 229px]中，取229px对应的3.jpg</p>
<h2 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><ul>
<li>  行内元素有：<code>a b span img input select strong</code>；</li>
<li>  块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li>
</ul>
<p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p>
<ul>
<li>  常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li>
<li>  鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li>
</ul>
<h2 id="9-说一下-web-worker"><a href="#9-说一下-web-worker" class="headerlink" title="9. 说一下 web worker"></a>9. 说一下 web worker</h2><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。web worker 是运行在后台的 js，独立于其他脚本，通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>
<p>在 Web Workers 中执行的脚本不能访问 Web 页面和 DOM API，虽然不会导致浏览器 UI 停止响应，但是仍然会消耗 CPU 周期，导致系统反应变慢。 </p>
<p>如何创建 web worker：</p>
<ol>
<li> 检测浏览器对于 web worker 的支持性</li>
<li> 创建 web worker 文件（js，回传函数等）</li>
<li> 创建 web worker 对象</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Workers<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Worker<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;support&quot;</span>&gt;</span>not support<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;stopButton&quot;</span>&gt;</span>Stop Task<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;helloButton&quot;</span>&gt;</span>Post a Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">stopWorker</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  worker.terminate()</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">messageHandler</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(e.data)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.warn(e.message, e)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">loadDemo</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (Worker) !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;support&quot;</span>).innerHTML = <span class="string">&quot;support&quot;</span></span></span><br><span class="line"><span class="javascript">    worker = <span class="keyword">new</span> Worker(<span class="string">&quot;echoWorker.js&quot;</span>)</span></span><br><span class="line"><span class="javascript">    worker.addEventListener(<span class="string">&quot;message&quot;</span>, messageHandler, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">    worker.addEventListener(<span class="string">&quot;error&quot;</span>, errorHandler, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;helloButton&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      worker.postMessage(<span class="string">&quot;for you&quot;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;stopButton&quot;</span>).onclick = stopWorker</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, loadDemo, <span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">messageHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  postMessage(<span class="string">&quot;say: &quot;</span> + e.data)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">&quot;message&quot;</span>, messageHandler, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h2 id="10-HTML5的离线缓存怎么使用，它的工作原理是什么"><a href="#10-HTML5的离线缓存怎么使用，它的工作原理是什么" class="headerlink" title="10. HTML5的离线缓存怎么使用，它的工作原理是什么"></a>10. HTML5的离线缓存怎么使用，它的工作原理是什么</h2><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>
<p><strong>原理：</strong>HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>
<p><strong>使用方法：</strong> （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">manifest</span>=<span class="string">&quot;index.manifest&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js/app.js</span><br><span class="line">    css/style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse/logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    / /offline.html</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>
<li>  <strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li>
<li>  <strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>
</ul>
<p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p>
<p><strong>如何更新缓存：</strong></p>
<p>（1）更新 manifest 文件</p>
<p>（2）通过 javascript 操作</p>
<p>（3）清除浏览器缓存</p>
<p><strong>注意事项：</strong></p>
<p>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p>
<p>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p>
<p>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p>
<p>（4）FALLBACK 中的资源必须和 manifest 文件同源。</p>
<p>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p>
<p>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p>
<p>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>
<h2 id="11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？"><a href="#11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？" class="headerlink" title="11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？"></a>11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h2><ul>
<li>  <strong>在线的情况下</strong>，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li>
<li>  <strong>离线的情况下</strong>，浏览器会直接使用离线存储的资源。</li>
</ul>
<h2 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h2><ul>
<li>title与h1的区别<ul>
<li>定义：<ul>
<li>  title是网站标题，一个页面只能有一个</li>
<li>  h1是文章主题</li>
</ul>
</li>
<li>作用：<ul>
<li>  title概括网站信息，可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的，是显示在网页Tab栏里的；</li>
<li>  h1突出文章主题，面对用户，更突出其视觉效果，指向页面主体信息，是显示在网页中的。</li>
</ul>
</li>
<li>注意：<ul>
<li>  如果title为空，但是页面存在h1,b,strong标签，搜索引擎会默认页面title为h1内的内容，所以得出结论h1是在没有外界干扰下除title以外第二个能强调页面主旨的标记，在一个页面中应该使用且只使用一次h1标记。</li>
</ul>
</li>
</ul>
</li>
<li>b与strong的区别<ul>
<li>定义：<ul>
<li>  b(bold)是实体标签，用来给文字加粗</li>
<li>  strong是逻辑标签，作用是加强字符语气</li>
</ul>
</li>
<li>区别：<ul>
<li>  b标签只是加粗的样式，没有实际含义，常用来表达无强调或着中意味的粗体文字</li>
<li>  strong表示标签内字符重要，用以强调，其默认格式是加粗，但是可以通过css添加样式，使用别的样式强调</li>
<li>  建议：为了符合css3的规范语义化，b应尽量少用而改用strong</li>
</ul>
</li>
</ul>
</li>
<li>i与em的区别<ul>
<li>定义：<ul>
<li>  i(italic)是实体标签，用来使字符倾斜</li>
<li>  em(emphasis)是逻辑标签，作用是强调文本内容</li>
</ul>
</li>
<li>区别：<ul>
<li>  i标签只是斜体的样式，没有实际含义，常用来表达无强调或着重意味的斜体，比如生物学名、术语、外来语；</li>
<li>  em表示标签内字符重要，用以强调，其默认格式是斜体，但是可以通过CSS添加样式。</li>
<li>  建议：为了符合CSS3的规 范，i应尽量少用而改用em</li>
</ul>
</li>
</ul>
</li>
<li>tips:<ul>
<li>  物理元素是告诉浏览器我应该以何种格式显示文字，逻辑元素告诉浏览器这些文字有怎么样的重要性。</li>
<li>  对于搜索引擎来说em和strong比i和b要重视的多。</li>
</ul>
</li>
</ul>
<h2 id="13-iframe-有那些优点和缺点？"><a href="#13-iframe-有那些优点和缺点？" class="headerlink" title="13. iframe 有那些优点和缺点？"></a>13. iframe 有那些优点和缺点？</h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">allow</td>
<td align="left">用于为<code>&lt;iframe&gt;</code>指定其<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Feature_Policy">特征策略</a>.</td>
</tr>
<tr>
<td align="left">allowfullscreen</td>
<td align="left">设置为<code>true</code>时，可以通过调用 <code>&lt;iframe&gt;</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/requestFullScreen"><code>requestFullscreen()</code></a> 方法激活全屏模式。<br />这是一个历史遗留属性，已经被重新定义为 <code>allow=&quot;fullscreen&quot;</code>。</td>
</tr>
<tr>
<td align="left">allowpaymentrequest</td>
<td align="left">设置为<code>true</code>时，跨域的 <code>&lt;iframe&gt;</code> 就可以调用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API">Payment Request API</a>。<br />这是一个历史遗留属性，已经被重新定义为 <code>allow=&quot;payment&quot;</code>.</td>
</tr>
<tr>
<td align="left">csp</td>
<td align="left">对嵌入的资源配置<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">内容安全策略</a>。</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left">以CSS像素格式<a href="https://developer.mozilla.org/zh-CN/docs/HTML/HTML5">HTML5</a>，或像素格式HTML 4.01，或百分比格式指定frame的高度。默认值为<code>150</code>。</td>
</tr>
<tr>
<td align="left">importance</td>
<td align="left">表示 <code>&lt;iframe&gt; </code>的 <code>src</code> 属性指定的资源的加载优先级。允许的值有：<br /><code>auto</code> (default)：不指定优先级。浏览器根据自身情况决定资源的加载顺序<br /><code>high</code>：资源的加载优先级较高<br /><code>low</code>：资源的加载优先级较低</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">用于定位嵌入的浏览上下文的名称。该名称可以用作 &lt;a&gt; 标签与 &lt;form&gt; 标签的 target 属性值，也可以用作 &lt;input&gt; 标签和 &lt;button&gt; 标签的 formtarget 属性值，还可以用作 window.open() 方法的 windowName 参数值。</td>
</tr>
<tr>
<td align="left">referrerpolicy</td>
<td align="left">表示在获取 iframe 资源时如何发送 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/referrer">referrer</a> 首部：<br /><code>no-referrer</code>: 不发送 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 首部。<br /><code>no-referrer-when-downgrade</code> (default): 向不受 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/TLS">TLS</a> (<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/https">HTTPS</a>) 保护的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a> 发送请求时，不发送 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 首部。<br /><code>origin</code>: referrer 首部中仅包含来源页面的源。换言之，仅包含来源页面的 <a href="https://developer.mozilla.org/en-US/docs/Archive/Mozilla/URIScheme">scheme</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host">host</a>, 以及 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Port">port (en-US)</a>。<br /><code>origin-when-cross-origin</code>: 发起跨域请求时，仅在 referrer 中包含来源页面的源。发起同源请求时，仍然会在 referrer 中包含来源页面在服务器上的路径信息。<br /><code>same-origin</code>: 对于 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Same-origin_policy">same origin</a> （同源）请求，发送 referrer 首部，否则不发送。<br /><code>strict-origin</code>: 仅当被请求页面和来源页面具有相同的协议安全等级时才发送 referrer 首部（比如从采用 HTTPS 协议的页面请求另一个采用 HTTPS 协议的页面）。如果被请求页面的协议安全等级较低，则不会发送 referrer 首部（比如从采用 HTTPS 协议的页面请求采用 HTTP 协议的页面）。<br /><code>strict-origin-when-cross-origin</code>: 当发起同源请求时，在 referrer 首部中包含完整的 URL。当被请求页面与来源页面不同源但是有相同协议安全等级时（比如 HTTPS→HTTPS），在 referrer 首部中仅包含来源页面的源。当被请求页面的协议安全等级较低时（比如 HTTPS→HTTP），不发送 referrer 首部。<br /><code>unsafe-url</code>: 始终在 referrer 首部中包含源以及路径 （但不包括 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash">fragment</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/password">密码</a>，或<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/username">用户名</a>）。<strong>这个值是不安全的</strong>, 因为这样做会暴露受 TLS 保护的资源的源和路径信息。</td>
</tr>
<tr>
<td align="left">sandbox</td>
<td align="left">该属性对呈现在 iframe 框架中的内容启用一些额外的限制条件。属性值可以为空字符串（这种情况下会启用所有限制），也可以是用空格分隔的一系列指定的字符串。有效的值有：<br /> <code>allow-downloads-without-user-activation</code> : 允许在没有征求用户同意的情况下下载文件.<br /> <code>allow-forms</code>: 允许嵌入的浏览上下文提交表单。如果没有使用该关键字，则无法提交表单。<br /> <code>allow-modals</code>: 允许嵌入的浏览上下文打开模态窗口。 <br /><code>allow-orientation-lock</code>: 允许嵌入的浏览上下文锁定屏幕方向（译者注：比如智能手机、平板电脑的水平朝向或垂直朝向）。<br /> <code>allow-pointer-lock</code>: 允许嵌入的浏览上下文使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Pointer_Lock_API">Pointer Lock API</a>.<br /> <code>allow-popups</code>: 允许弹窗 (例如 window.open, target=”_blank”, <code>showModalDialog</code>)。如果没有使用该关键字，相应的功能将自动被禁用。 <br /><code>allow-popups-to-escape-sandbox</code>:  允许沙箱化的文档打开新窗口，并且新窗口不会继承沙箱标记。例如，安全地沙箱化一个广告页面，而不会在广告链接到的新页面中启用相同的限制条件。<br /> <code>allow-presentation</code>: 允许嵌入的浏览上下文开始一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/PresentationRequest"> presentation session</a>。 <br /><code>allow-same-origin</code>: 如果没有使用该关键字，嵌入的浏览上下文将被视为来自一个独立的源，这将使 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Same-origin_policy">same-origin policy</a> 同源检查失败。<br /> <code>allow-scripts</code>: 允许嵌入的浏览上下文运行脚本（但不能创建弹窗）。如果没有使用该关键字，就无法运行脚本。 <br /><code>allow-storage-access-by-user-activation</code> : 允许嵌入的浏览上下文通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage_Access_API">Storage Access API</a> 使用父级浏览上下文的存储功能。<br /> <code>allow-top-navigation</code>: 允许嵌入的浏览上下文导航（加载）内容到顶级的浏览上下文。<br /> <code>allow-top-navigation-by-user-activation</code>: 允许嵌入的浏览上下文<strong>在经过用户允许后</strong>导航（加载）内容到顶级的浏览上下文。</td>
</tr>
<tr>
<td align="left">src</td>
<td align="left">被嵌套的页面的 URL 地址。使用 <code>about:blank</code> 值可以嵌入一个遵从<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>的空白页。在 Firefox （version 65及更高版本）、基于 Chromium 的浏览器、Safari/iOS 中使用代码移除 <code>iframe</code> 的 <code>src</code> 属性（例如通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/removeAttribute"><code>Element.removeAttribute()</code></a> ）会导致 <code>about:blank</code> 被载入 frame。</td>
</tr>
<tr>
<td align="left">srcdoc</td>
<td align="left">该属性是一段HTML代码，这些代码会被渲染到 iframe 中。如果浏览器不支持 <code>srcdoc</code> 属性，则会渲染 <code>src</code> 属性表示的内容。</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left">以CSS像素格式<a href="https://developer.mozilla.org/zh-CN/docs/HTML/HTML5">HTML5</a>，或以像素格式HTML 4.01，或以百分比格式指定的 frame 的宽度。默认值是<code>300</code>。</td>
</tr>
</tbody></table>
<p><strong>优点：</strong></p>
<ul>
<li>  用来加载速度较慢的内容（如广告）</li>
<li>  可以使脚本可以并行下载</li>
<li>  可以实现跨子域通信</li>
<li>  如果有多个网页引用iframe，那么只需要修改iframe的内容，就可以实现调用每一个页面的更改，方便快捷。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  iframe 会阻塞主页面的 onload 事件</li>
<li>  代码复杂，无法被一些搜索引擎索引到，搜索引擎爬虫还不能很好的处理iframe中的内容，所以不利于搜索引擎优化。</li>
<li>  会产生很多页面，不容易管理</li>
<li>  很多移动设备无法完全显示框架，设备兼容性差</li>
<li>  iframe框架页面会增加服务器的http请求，对于大型网站是不可取的</li>
</ul>
<h2 id="14-label-的作用是什么？如何使用？"><a href="#14-label-的作用是什么？如何使用？" class="headerlink" title="14. label 的作用是什么？如何使用？"></a>14. label 的作用是什么？如何使用？</h2><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>
<ul>
<li>  使用方法1：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mobile&quot;</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mobile&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  使用方法2：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h2><p><strong>（1）SVG：</strong> SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p>
<p>其特点如下：</p>
<ul>
<li>  不依赖分辨率</li>
<li>  支持事件处理器</li>
<li>  最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
<li>  复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>
<li>  不适合游戏应用</li>
</ul>
<p><strong>（2）Canvas：</strong> Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p>
<p>其特点如下：</p>
<ul>
<li>  依赖分辨率</li>
<li>  不支持事件处理器</li>
<li>  弱的文本渲染能力</li>
<li>  能够以 .png 或 .jpg 格式保存结果图像</li>
<li>  最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>
</ul>
<p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p>
<h2 id="16-head-标签有什么作用，其中什么标签必不可少？"><a href="#16-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="16. head 标签有什么作用，其中什么标签必不可少？"></a>16. head 标签有什么作用，其中什么标签必不可少？</h2><p>标签用于定义文档的头部，它是所有头部元素的容器。 标签中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p>
<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>
<p>下面这些标签可用在 head 部分：<code>&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;&lt;noscript&gt;</code>。</p>
<p><strong>经过测试，好像没有必需的标签</strong></p>
<table>
<thead>
<tr>
<th>元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;title&gt;</td>
<td align="left">定义文档的标题，显示在浏览器的标题栏或标签页上，一般会完整地概括整个网页的内容</td>
</tr>
<tr>
<td>&lt;base&gt;</td>
<td align="left">指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个 &lt;base&gt; 元素。</td>
</tr>
<tr>
<td>&lt;link&gt;</td>
<td align="left">规定外部资源与当前文档的关系，常用于链接样式表：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;xxx.css&quot; type=&quot;text/css&quot;&gt;</code><br />还有其它作用：<br />1. 用于 SEO ，主要是给搜索引擎看的：<code>&lt;link rel=&quot;canonical&quot; href=&quot;...&quot;&gt;</code><br />2. 提供 rss 订阅：<code>&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;...&quot;&gt;</code><br />3. 表示页面 icon ：<code>&lt;link rel=&quot;icon&quot; href=&quot;https://xxx.png&quot;&gt;</code><br />4. 对页面提供预处理：<code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//xxx.com&quot;&gt;</code>，提前对一个域名做 dns 查询。强制对域名进行预读取在有的情况下很有用。比如, 在网站的主页上，强制在整个网站上对频繁引用的域名做预解析处理，即使它们不在主页本身上使用。虽然主页的性能可能不受影响，但是会提高站点整体性能。</td>
</tr>
<tr>
<td>&lt;style&gt;</td>
<td align="left">包含文档的样式信息。</td>
</tr>
<tr>
<td>&lt;meta&gt;</td>
<td align="left">一种通用的元数据信息表示标签。见上述5</td>
</tr>
<tr>
<td>&lt;script&gt;</td>
<td align="left">用于嵌入或引用可执行脚本。见上述4</td>
</tr>
<tr>
<td>&lt;noscript&gt;</td>
<td align="left">如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在此中定义脚本未被执行时的替代内容。可以包含除&lt;script&gt;外任何可以出现在&lt;body&gt;标签中的内容</td>
</tr>
</tbody></table>
<h2 id="17-文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#17-文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="17. 文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>17. 文档声明（Doctype）和<code>&lt;!Doctype html&gt;</code>有何作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><p><strong>文档声明的作用：</strong> 文档声明是为了告诉浏览器，当前<code>HTML</code>文档使用什么版本的<code>HTML</code>来写的，这样浏览器才能按照声明的版本来正确的解析。</p>
<p><code>&lt;!Doctype html&gt;</code><strong>的作用：</strong><code>&lt;!doctype html&gt;</code> 的作用就是让浏览器进入标准模式，使用最新的 <code>HTML5</code> 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。</p>
<p><strong>严格模式与混杂模式的区分：</strong></p>
<ul>
<li>  <strong>严格模式</strong>： 又称为标准模式，指浏览器按照<code>W3C</code>标准解析代码；</li>
<li>  <strong>混杂模式</strong>： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；</li>
</ul>
<p><strong>区分</strong>：网页中的<code>DTD</code>，直接影响到使用的是严格模式还是浏览模式，可以说<code>DTD</code>的使用与这两种方式的区别息息相关。</p>
<ul>
<li>  如果文档包含严格的<code>DOCTYPE</code> ，那么它一般以严格模式呈现（<strong>严格 DTD ——严格模式</strong>）；</li>
<li>  包含过渡 <code>DTD</code> 和 <code>URI</code> 的 <code>DOCTYPE</code> ，也以严格模式呈现，但有过渡 <code>DTD</code> 而没有 <code>URI</code> （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（<strong>有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式</strong>）；</li>
<li>  <code>DOCTYPE</code> 不存在或形式不正确会导致文档以混杂模式呈现（<strong>DTD不存在或者格式不正确——混杂模式</strong>）；</li>
<li>  <code>HTML5</code> 没有 <code>DTD</code> ，因此也就没有严格模式与混杂模式的区别，<code>HTML5</code> 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(<strong>HTML5 没有严格和混杂之分</strong>在使用HTML5的时候，在开头只写了这一句话，浏览器也能解析，原因是：HTML5不基于 SGML，所以不需要引用DTD，但是需要DOCTYPE来规范浏览器的行为，让浏览器按照W3C的标准解析渲染页面。 而HTML4.01和XHTML1.0基于SGML，所以需要引用DTD，才能告诉浏览器使用哪种DTD来解析文档。)。</li>
</ul>
<p>总之，<strong>严格模式让各个浏览器统一执行一套规范，兼容模式保证了旧网站的正常运行。</strong></p>
<p>在怪异模式下，盒模型为IE模型 ；严格模式下为W3C标准的盒模型</p>
<p>参考：<a href="https://juejin.cn/post/6989264337143595044%EF%BC%9Bhttps://juejin.cn/post/6969072081308745764">https://juejin.cn/post/6989264337143595044；https://juejin.cn/post/6969072081308745764</a></p>
<h2 id="18-浏览器乱码的原因是什么？如何解决？"><a href="#18-浏览器乱码的原因是什么？如何解决？" class="headerlink" title="18. 浏览器乱码的原因是什么？如何解决？"></a>18. 浏览器乱码的原因是什么？如何解决？</h2><p><strong>产生乱码的原因：</strong></p>
<ul>
<li>  网页源代码是<code>gbk</code>的编码，而内容中的中文字是<code>utf-8</code>编码的，这样浏览器打开即会出现<code>html</code>乱码，反之也会出现乱码；</li>
<li>  <code>html</code>网页编码是<code>gbk</code>，而程序从数据库中调出呈现是<code>utf-8</code>编码的内容也会造成编码乱码；</li>
<li>  浏览器不能自动检测网页编码，造成网页乱码。</li>
</ul>
<p><strong>解决办法：</strong></p>
<ul>
<li>  使用软件编辑HTML网页内容；</li>
<li>  如果网页设置编码是<code>gbk</code>，而数据库储存数据编码格式是<code>UTF-8</code>，此时需要程序查询数据库数据显示数据前进程序转码；</li>
<li>  如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li>
</ul>
<h2 id="19-渐进增强和优雅降级之间的区别"><a href="#19-渐进增强和优雅降级之间的区别" class="headerlink" title="19. 渐进增强和优雅降级之间的区别"></a>19. 渐进增强和优雅降级之间的区别</h2><p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。 </p>
<p><strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p>
<p><strong>两者区别：</strong></p>
<ul>
<li>  优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li>
<li>  降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>
</ul>
<p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</p>
<p>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p>
<h2 id="20-说一下-HTML5-drag-API"><a href="#20-说一下-HTML5-drag-API" class="headerlink" title="20. 说一下 HTML5 drag API"></a>20. 说一下 HTML5 drag API</h2><p>参考：<a href="https://juejin.cn/post/7014414669221724190">https://juejin.cn/post/7014414669221724190</a></p>
<p><strong>draggable</strong></p>
<ul>
<li>  当我们想让元素变成可拖拽时，我们就需要设置 draggable 属性。</li>
<li>  属性值未设置的情况下，默认是 auto，此时拖拽行为为浏览器默认行为，只有选中的文字，链接，图片可以拖动。</li>
<li>  draggable 属性值不是 Boolean 类型，需要显式设置为 true 或者 false，true 为可拖动，false 为不可拖动</li>
</ul>
<p><strong>拖拽事件</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发时刻</th>
</tr>
</thead>
<tbody><tr>
<td>dragstart</td>
<td>当用户开始拖拽一个元素或选中的文本时触发</td>
</tr>
<tr>
<td>drag</td>
<td>当拖拽元素或选中的文本时触发</td>
</tr>
<tr>
<td>dragend</td>
<td>当拖拽操作结束时触发</td>
</tr>
<tr>
<td>dragenter</td>
<td>当拖拽元素或选中的文本到一个可放置的目标时触发</td>
</tr>
<tr>
<td>dragover</td>
<td>当元素或选中的文本被拖到一个可放置的目标上时触发（每100毫秒触发一次）</td>
</tr>
<tr>
<td>drop</td>
<td>当元素或选中的文本在可放置的目标上被释放时触发</td>
</tr>
<tr>
<td>dragleave</td>
<td>当拖拽元素或选中的文本离开一个可放置的目标时触发。</td>
</tr>
<tr>
<td>dragexit</td>
<td>和dragleave类似，但是兼容性不好，建议不要使用。</td>
</tr>
</tbody></table>
<p><strong>事件分类</strong>：</p>
<ul>
<li>  可拖拽元素：dragstart，drag，dragend</li>
<li>  可放置的元素：dragenter，dragover，drop，dragleave</li>
</ul>
<p>拖拽事件的 event 对象 dragEvent 继承 mouseEvent，dragEvent 有个属性 dataTransfer，dataTransfer 属性是一个 DataTransfer 对象</p>
<p><strong>拖拽数据对象</strong>涉及到三个类：DataTransfer, DataTransferItemList, DataTransferItem</p>
<ul>
<li>DataTransfer<ul>
<li>  DataTransfer 对象用于保存在拖放操作期间拖动的数据，同时还可以设置拖拽样式，读取拖拽文件等等。它可以包含一个或多个数据项，每个数据项包含一个或多个数据类型。</li>
<li>  所有拖拽事件中我们都可以通过 event.dataTransfer 访问到它。</li>
</ul>
</li>
<li>dropEffect 和 effectAllowed<ul>
<li>  <code>dropEffect</code> 用于表示放置区接受什么行为的拖放，一般在 dragenter 和 dragover 中设置；</li>
<li>  对应的 <code>effectAllowed</code> 表示这次拖拽的行为是什么行为，要在 dragstart 中设置。</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>拖放示例-文本<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#drop-area</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#660000</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#drag-el</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: palegoldenrod;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;drop-area&quot;</span>&gt;</span>423423423<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;drag-el&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> dragEl = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#drag-el&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> dropArea = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#drop-area&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    dragEl.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      event.dataTransfer.setData(<span class="string">&#x27;text/plain&#x27;</span>, event.target.id)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    dropArea.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 通知浏览器不要执行事件的常规内置操作</span></span></span><br><span class="line"><span class="javascript">      event.preventDefault()</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    dropArea.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> id = event.dataTransfer.getData(<span class="string">&#x27;text/plain&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      dropArea.appendChild(<span class="built_in">document</span>.getElementById(id))</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="21-为什么-script-标签放在-body-最后，css-放在-head-里面"><a href="#21-为什么-script-标签放在-body-最后，css-放在-head-里面" class="headerlink" title="21. 为什么 script 标签放在 body 最后，css 放在 head 里面"></a>21. 为什么 script 标签放在 body 最后，css 放在 head 里面</h2><h2 id="22-导入-css-的方式，为什么建议用-link-而不是-import（见02-CSS）"><a href="#22-导入-css-的方式，为什么建议用-link-而不是-import（见02-CSS）" class="headerlink" title="22. 导入 css 的方式，为什么建议用 link 而不是 @import（见02.CSS）"></a>22. 导入 css 的方式，为什么建议用 link 而不是 @import（见02.CSS）</h2><p>import会增加http请求（进而影响加载速度）</p>
<h2 id="23-HTML-的全局属性"><a href="#23-HTML-的全局属性" class="headerlink" title="23. HTML 的全局属性"></a>23. HTML 的全局属性</h2><h2 id="24-Geolocation-API（地理定位）用于定位用户的位置。"><a href="#24-Geolocation-API（地理定位）用于定位用户的位置。" class="headerlink" title="24. Geolocation API（地理定位）用于定位用户的位置。"></a>24. Geolocation API（地理定位）用于定位用户的位置。</h2><h2 id="25-WebSockets"><a href="#25-WebSockets" class="headerlink" title="25. WebSockets"></a>25. WebSockets</h2><h2 id="26-Communication-API"><a href="#26-Communication-API" class="headerlink" title="26. Communication API"></a>26. Communication API</h2><h2 id="27-lt-img-gt-title-和-alt-的区别"><a href="#27-lt-img-gt-title-和-alt-的区别" class="headerlink" title="27. &lt;img&gt; title 和 alt 的区别"></a>27. &lt;img&gt; title 和 alt 的区别</h2>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器原理</title>
    <url>/2021/12/21/browser/</url>
    <content><![CDATA[<p>绝大部分内容来自：<a href="https://juejin.cn/user/3544481220801815">https://juejin.cn/user/3544481220801815</a></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2021/12/21/browser/06.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="06.浏览器原理面试题"></p>
<h2 id="一、浏览器安全"><a href="#一、浏览器安全" class="headerlink" title="一、浏览器安全"></a>一、浏览器安全</h2><h3 id="1-什么是-XSS-攻击？"><a href="#1-什么是-XSS-攻击？" class="headerlink" title="1. 什么是 XSS 攻击？"></a>1. 什么是 XSS 攻击？</h3><ol>
<li><p>概念</p>
<p>  XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>
<p> XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>
<p> 攻击者可以通过这种攻击方式可以进行以下操作：</p>
<ul>
<li>  获取页面的数据，如DOM、cookie、localStorage；</li>
<li>  DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li>
<li>  破坏页面结构；</li>
<li>  流量劫持（将链接指向某网站）；</li>
</ul>
</li>
<li><p>攻击类型</p>
<p> XSS 可以分为存储型、反射型和 DOM 型：</p>
<ul>
<li><p>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</p>
<p>  <strong>存储型 XSS 的攻击步骤：</strong></p>
<ol>
<li> 攻击者将恶意代码提交到⽬标⽹站的数据库中。</li>
<li> ⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li> ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>
<li> 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>  这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p>
</li>
<li><p>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 </p>
<p>  <strong>反射型 XSS 的攻击步骤：</strong></p>
<ol>
<li> 攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li> ⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>
<li> ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>
<li> 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>  反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。</p>
<p>  反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p>
</li>
<li><p>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</p>
<p>  <strong>DOM 型 XSS 的攻击步骤：</strong></p>
<ol>
<li> 攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li> ⽤户打开带有恶意代码的 URL。</li>
<li> ⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</li>
<li> 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>  DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-如何防御-XSS-攻击？"><a href="#2-如何防御-XSS-攻击？" class="headerlink" title="2. 如何防御 XSS 攻击？"></a>2. 如何防御 XSS 攻击？</h3><p>可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p>
<ul>
<li><p>  可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</p>
</li>
<li><p>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</p>
<blockquote>
<ol>
<li>  CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li>
<li>  通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式</li>
</ol>
</blockquote>
</li>
<li><p>  对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</p>
</li>
</ul>
<h3 id="3-什么是-CSRF-攻击？"><a href="#3-什么是-CSRF-攻击？" class="headerlink" title="3. 什么是 CSRF 攻击？"></a>3. 什么是 CSRF 攻击？</h3><p>参考：<a href="https://juejin.cn/post/6844903689702866952">https://juejin.cn/post/6844903689702866952</a></p>
<ol>
<li><p>概念</p>
<p> CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>
<p> CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p>
</li>
<li><p>攻击类型</p>
<p> 常见的 CSRF 攻击有三种：</p>
<ul>
<li>  GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li>
<li>  POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>
<li>  链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>
</ul>
</li>
</ol>
<h3 id="4-如何防御-CSRF-攻击？"><a href="#4-如何防御-CSRF-攻击？" class="headerlink" title="4. 如何防御 CSRF 攻击？"></a>4. 如何防御 CSRF 攻击？</h3><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p>
<ul>
<li>  <strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li>
<li>  <strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li>
<li>  <strong>对 Cookie 进行双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li>
<li>  <strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li>
</ul>
<h3 id="5-什么是中间人攻击？如何防范中间人攻击？"><a href="#5-什么是中间人攻击？如何防范中间人攻击？" class="headerlink" title="5. 什么是中间人攻击？如何防范中间人攻击？"></a>5. 什么是中间人攻击？如何防范中间人攻击？</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p>
<p>攻击过程如下:</p>
<ul>
<li>  客户端发送请求到服务端，请求被中间⼈截获</li>
<li>  服务器向客户端发送公钥</li>
<li>  中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</li>
<li>  客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li>
<li>  中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器</li>
<li>  服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li>
</ul>
<h3 id="6-有哪些可能引起前端安全的问题"><a href="#6-有哪些可能引起前端安全的问题" class="headerlink" title="6. 有哪些可能引起前端安全的问题?"></a>6. 有哪些可能引起前端安全的问题?</h3><ul>
<li>  跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；</li>
<li>  iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</li>
<li>  跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击</li>
<li>  恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</li>
</ul>
<h3 id="7-网络劫持有哪几种，如何防范？"><a href="#7-网络劫持有哪几种，如何防范？" class="headerlink" title="7. 网络劫持有哪几种，如何防范？"></a>7. 网络劫持有哪几种，如何防范？</h3><p>⽹络劫持分为两种:</p>
<ol>
<li><strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持)<ul>
<li>  DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li>
<li>  302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li>
</ul>
</li>
<li> <strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</li>
</ol>
<p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>
<h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><h3 id="1-进程与线程的概念"><a href="#1-进程与线程的概念" class="headerlink" title="1. 进程与线程的概念"></a>1. 进程与线程的概念</h3><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p>
<ul>
<li>  进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li>
<li>  线程是进程中的更小单位，描述了执行一段指令所需的时间。</li>
</ul>
<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>
<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。<strong>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</strong></p>
<p>如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。</p>
<p>进程和线程之间的关系有以下四个特点：</p>
<ol>
<li> <strong>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></li>
<li> <strong>线程之间共享进程中的数据。</strong></li>
<li> <strong>当一个进程关闭之后，操作系统会回收进程所占用的内存，</strong> 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</li>
<li> <strong>进程之间的内容相互隔离。</strong> 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</li>
</ol>
<p><strong>Chrome浏览器的架构图</strong>：</p>
<p><img src="/2021/12/21/browser/06-2-1.png"></p>
<p>从图中可以看出，最新的 Chrome 浏览器包括：</p>
<ul>
<li>  1 个浏览器主进程</li>
<li>  1 个 GPU 进程</li>
<li>  1 个网络进程</li>
<li>  多个渲染进程</li>
<li>  多个插件进程</li>
</ul>
<p>这些进程的功能：</p>
<ul>
<li>  <strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li>  <strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li>  <strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li>  <strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li>  <strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
<p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>
<p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p>
<ul>
<li>  <strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li>
<li>  <strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li>
</ul>
<h3 id="2-进程和线程的区别"><a href="#2-进程和线程的区别" class="headerlink" title="2. 进程和线程的区别"></a>2. 进程和线程的区别</h3><ul>
<li>  进程可以看做独立应用，线程不能</li>
<li>  资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li>
<li>  通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li>
<li>  调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li>  系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</li>
</ul>
<h3 id="3-浏览器渲染进程的线程有哪些"><a href="#3-浏览器渲染进程的线程有哪些" class="headerlink" title="3. 浏览器渲染进程的线程有哪些"></a>3. 浏览器渲染进程的线程有哪些</h3><p>浏览器的渲染进程的线程总共有五种：</p>
<p><img src="/2021/12/21/browser/06-2-3.png"></p>
<ol>
<li><p><strong>GUI渲染线程</strong> 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。</p>
<p> 注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
</li>
<li><p><strong>JS引擎线程</strong> JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；</p>
<p> 注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
</li>
<li><p><strong>时间触发线程</strong> <strong>时间触发线程</strong>属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；</p>
<p> 注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p>
</li>
<li><p><strong>定时器触发进程</strong> <strong>定时器触发进程</strong>即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；</p>
<p> 注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p>
</li>
<li><p><strong>异步http请求线程</strong></p>
<ul>
<li>  XMLHttpRequest连接后通过浏览器新开一个线程请求；</li>
<li>  检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</li>
</ul>
</li>
</ol>
<h3 id="4-进程之前的通信方式"><a href="#4-进程之前的通信方式" class="headerlink" title="4. 进程之前的通信方式"></a>4. 进程之前的通信方式</h3><ol>
<li><p><strong>管道通信</strong></p>
<p> 管道是一种最基本的进程间通信机制。<strong>管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。</strong></p>
<p> 管道的特点：</p>
<ul>
<li>  只能单向通信</li>
<li>  只能血缘关系的进程进行通信</li>
<li>  依赖于文件系统</li>
<li>  生命周期随进程</li>
<li>  面向字节流的服务</li>
<li>  管道内部提供了同步机制</li>
</ul>
</li>
<li><p><strong>消息队列通信</strong></p>
<p> 消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p>
<p> 使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。</p>
</li>
<li><p><strong>信号量通信</strong></p>
<p> 共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
</li>
<li><p><strong>信号通信</strong></p>
<p> 信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。</p>
</li>
<li><p><strong>共享内存通信</strong></p>
<p> 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
</li>
<li><p><strong>套接字通信</strong></p>
<p> 上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>
</li>
</ol>
<h3 id="5-僵尸进程和孤儿进程是什么？"><a href="#5-僵尸进程和孤儿进程是什么？" class="headerlink" title="5. 僵尸进程和孤儿进程是什么？"></a>5. 僵尸进程和孤儿进程是什么？</h3><ul>
<li>  <strong>孤儿进程</strong>：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
<li>  <strong>僵尸进程</strong>：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</li>
</ul>
<h3 id="6-死锁产生的原因？-如果解决死锁的问题？"><a href="#6-死锁产生的原因？-如果解决死锁的问题？" class="headerlink" title="6. 死锁产生的原因？ 如果解决死锁的问题？"></a>6. 死锁产生的原因？ 如果解决死锁的问题？</h3><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<p>系统中的资源可以分为两类：</p>
<ul>
<li>  可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li>  不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ul>
<p><strong>产生死锁的原因：</strong></p>
<ol>
<li><strong>竞争资源</strong><ul>
<li>  产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li>
<li>  产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li>
</ul>
</li>
<li><strong>进程间推进顺序非法</strong><ul>
<li>  若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。</li>
<li>  例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</li>
</ul>
</li>
</ol>
<p><strong>产生死锁的必要条件：</strong></p>
<ul>
<li>  互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>  请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>  不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li>  环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</li>
</ul>
<p><strong>预防死锁的方法：</strong></p>
<ul>
<li>  资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>  只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li>
<li>  可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>  资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
<h3 id="7-如何实现浏览器内多个标签页之间的通信"><a href="#7-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="7. 如何实现浏览器内多个标签页之间的通信?"></a>7. 如何实现浏览器内多个标签页之间的通信?</h3><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p>
<ul>
<li>  <strong>使用 websocket 协议</strong>，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li>
<li>  <strong>使用 ShareWorker 的方式</strong>，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li>
<li>  <strong>使用 localStorage 的方式</strong>，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li>
<li>  <strong>使用 postMessage 方法</strong>，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</li>
</ul>
<h3 id="8-对Service-Worker的理解"><a href="#8-对Service-Worker的理解" class="headerlink" title="8. 对Service Worker的理解"></a>8. 对Service Worker的理解</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">&#x27;sw.js&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;service worker 注册成功&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;servcie worker 注册失败&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">&#x27;my-cache&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">&#x27;./index.html&#x27;</span>, <span class="string">&#x27;./index.js&#x27;</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;fetch source&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 Service Worker 已经启动了：</p>
<p><img src="/2021/12/21/browser/06-2-8-1.png"></p>
<p>在 Cache 中也可以发现所需的文件已被缓存：</p>
<p><img src="/2021/12/21/browser/06-2-8-2.png"></p>
<h2 id="三、浏览器缓存"><a href="#三、浏览器缓存" class="headerlink" title="三、浏览器缓存"></a>三、浏览器缓存</h2><h3 id="1-对浏览器的缓存机制的理解"><a href="#1-对浏览器的缓存机制的理解" class="headerlink" title="1. 对浏览器的缓存机制的理解"></a>1. 对浏览器的缓存机制的理解</h3><p><strong>浏览器缓存的全过程：</strong></p>
<ul>
<li>  浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；</li>
<li>  下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；</li>
<li>  如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；</li>
<li>  服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li>
<li>  如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</li>
</ul>
<p><img src="/2021/12/21/browser/06-3-1.png"></p>
<p>很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。</p>
<h3 id="2-浏览器资源缓存的位置有哪些？"><a href="#2-浏览器资源缓存的位置有哪些？" class="headerlink" title="2. 浏览器资源缓存的位置有哪些？"></a>2. 浏览器资源缓存的位置有哪些？</h3><p>资源缓存的位置一共有 3 种，按优先级从高到低分别是：</p>
<ol>
<li> <strong>Service Worker：Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。当 Service Worker 没有命中缓存的时候，需要去调用 <code>fetch</code> 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。<strong>但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。</strong></li>
<li> <strong>Memory Cache：</strong> Memory Cache 就是内存缓存，它的效率最快，<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</li>
<li> <strong>Disk Cache：</strong> Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></li>
<li><strong>Push Cache：</strong> Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：<ul>
<li>  所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li>
<li>  可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li>
<li>  一旦连接被关闭，Push Cache 就被释放</li>
<li>  多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li>
<li>  Push Cache 中的缓存只能被使用一次</li>
<li>  浏览器可以拒绝接受已经存在的资源推送</li>
<li>  可以给其他域名推送资源</li>
</ul>
</li>
</ol>
<h3 id="3-协商缓存和强缓存的区别"><a href="#3-协商缓存和强缓存的区别" class="headerlink" title="3. 协商缓存和强缓存的区别"></a>3. 协商缓存和强缓存的区别</h3><ol>
<li><p>强缓存</p>
<p> 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p>
<p> 强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p>
<ol>
<li><p> 服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p>
</li>
<li><p>Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，</p>
<p> <code>Cache-Control</code>可设置的字段：</p>
<ul>
<li>  <code>public</code>：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；</li>
<li>  <code>private</code>：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li>
<li>  <code>no-cache</code>：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li>
<li>  <code>no-store</code>：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li>
<li>  <code>max-age=</code>：设置缓存的最大有效期，单位为秒；</li>
<li>  <code>s-maxage=</code>：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li>
<li>  <code>max-stale[=]</code>：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li>
</ul>
</li>
</ol>
<p> 一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。</p>
<p> <strong>no-cache和no-store很容易混淆：</strong></p>
<ul>
<li>  no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；</li>
<li>  no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。</li>
</ul>
</li>
<li><p>协商缓存</p>
<p> 如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。</p>
<p> 上面已经说到了，命中协商缓存的条件有两个：</p>
<ul>
<li>  <code>max-age=xxx</code> 过期了</li>
<li>  值为<code>no-store</code></li>
</ul>
<p> 使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。</p>
<p> 协商缓存也可以通过两种方式来设置，分别是 http 头信息中的<strong>Etag</strong> 和<strong>Last-Modified</strong>属性。</p>
<ol>
<li> 服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。</li>
<li> 因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</li>
</ol>
<p> 当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p>
<h3 id="4-为什么需要浏览器缓存？"><a href="#4-为什么需要浏览器缓存？" class="headerlink" title="4. 为什么需要浏览器缓存？"></a>4. 为什么需要浏览器缓存？</h3><p>对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p>
<p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p>
<p>使用浏览器缓存，有以下优点：</p>
<ul>
<li>  减少了服务器的负担，提高了网站的性能</li>
<li>  加快了客户端网页的加载速度</li>
<li>  减少了多余网络数据传输 </li>
</ul>
<h3 id="5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h3><ul>
<li>  <strong>点击刷新按钮或者按 F5：</strong> 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li>
<li>  <strong>用户按 Ctrl+F5（强制刷新）：</strong> 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li>
<li>  <strong>地址栏回车：</strong> 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li>
</ul>
<h2 id="四、浏览器组成"><a href="#四、浏览器组成" class="headerlink" title="四、浏览器组成"></a>四、浏览器组成</h2><h3 id="1-对浏览器的理解"><a href="#1-对浏览器的理解" class="headerlink" title="1. 对浏览器的理解"></a>1. 对浏览器的理解</h3><p>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p>
<p>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</p>
<p>浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p>
<ul>
<li>  shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。</li>
<li>  内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。</li>
</ul>
<h3 id="2-对浏览器内核的理解"><a href="#2-对浏览器内核的理解" class="headerlink" title="2. 对浏览器内核的理解"></a>2. 对浏览器内核的理解</h3><p>浏览器内核主要分成两部分：</p>
<ul>
<li>  渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</li>
<li>  JS 引擎：解析和执行 javascript 来实现网页的动态效果。</li>
</ul>
<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h3 id="3-常见的浏览器内核比较"><a href="#3-常见的浏览器内核比较" class="headerlink" title="3. 常见的浏览器内核比较"></a>3. 常见的浏览器内核比较</h3><ul>
<li>  <strong>Trident：</strong> 这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</li>
<li>  <strong>Gecko：</strong> 这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</li>
<li>  <strong>Presto：</strong> Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</li>
<li>  <strong>Webkit：</strong> Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</li>
<li>  <strong>Blink：</strong> 谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</li>
</ul>
<h3 id="4-常见浏览器所用内核"><a href="#4-常见浏览器所用内核" class="headerlink" title="4. 常见浏览器所用内核"></a>4. 常见浏览器所用内核</h3><ol>
<li>  IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</li>
<li>  Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</li>
<li>  Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</li>
<li>  Safari 浏览器内核：Webkit 内核；</li>
<li>  Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</li>
<li>  360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</li>
<li>  搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</li>
<li>  百度浏览器、世界之窗内核：IE 内核；</li>
<li>  2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</li>
<li>  UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</li>
</ol>
<h3 id="5-浏览器的主要组成部分"><a href="#5-浏览器的主要组成部分" class="headerlink" title="5. 浏览器的主要组成部分"></a>5. 浏览器的主要组成部分</h3><ul>
<li>  <strong>⽤户界⾯</strong> 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。</li>
<li>  <strong>浏览器引擎</strong> 在⽤户界⾯和呈现引擎之间传送指令。</li>
<li>  <strong>呈现引擎</strong> 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>
<li>  <strong>⽹络</strong> ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。</li>
<li>  <strong>⽤户界⾯后端</strong> ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。</li>
<li>  <strong>JavaScript 解释器</strong>。⽤于解析和执⾏ JavaScript 代码。</li>
<li>  <strong>数据存储</strong> 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。</li>
</ul>
<p>值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。</p>
<h2 id="五、浏览器渲染原理"><a href="#五、浏览器渲染原理" class="headerlink" title="五、浏览器渲染原理"></a>五、浏览器渲染原理</h2><h3 id="1-浏览器的渲染过程"><a href="#1-浏览器的渲染过程" class="headerlink" title="1. 浏览器的渲染过程"></a>1. 浏览器的渲染过程</h3><p>浏览器渲染主要有以下步骤：</p>
<ul>
<li>  首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>
<li>  然后对 CSS 进行解析，生成 CSSOM 规则树。</li>
<li>  根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>
<li>  当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>
<li>  布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>
</ul>
<p>大致过程如图所示： <img src="/2021/12/21/browser/06-5-1.png" alt="img"></p>
<p><strong>注意：</strong> 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<h3 id="2-浏览器渲染优化"><a href="#2-浏览器渲染优化" class="headerlink" title="2. 浏览器渲染优化"></a>2. 浏览器渲染优化</h3><ol>
<li><p><strong>针对JavaScript：</strong> JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p>
<ol>
<li> 尽量将JavaScript文件放在body的最后</li>
<li> body中间尽量不要写<code>&lt;script&gt;</code>标签</li>
<li>&lt;script&gt;标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：<ul>
<li>  script 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</li>
<li>  async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；</li>
<li>  defer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>针对CSS：使用CSS有三种方式：使用link、@import、内联样式</strong>，其中link和@import都是导入外部样式。它们之间的区别：</p>
<ul>
<li>  <strong>link</strong>：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</li>
<li>  <strong>@import</strong>：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</li>
<li>  <strong>style</strong>：GUI直接渲染</li>
</ul>
<p> 外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p>
<p> 所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p>
</li>
<li><p><strong>针对DOM树、CSSOM树：</strong> 可以通过以下几种方式来减少渲染的时间：</p>
<ul>
<li>  HTML文件的代码层级尽量不要太深</li>
<li>  使用语义化的标签，来避免不标准语义化的特殊处理</li>
<li>  减少CSS代码的层级，因为选择器是从左向右进行解析的</li>
</ul>
</li>
<li><p><strong>减少回流与重绘：</strong></p>
<ul>
<li>  操作DOM时，尽量在低层级的DOM节点进行操作</li>
<li>  不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li>
<li>  使用CSS的表达式</li>
<li>  不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li>
<li>  使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li>
<li>  避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li>
<li>  将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。<ul>
<li>  浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></li>
<li>  <strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></li>
<li>  将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-渲染过程中遇到-JS-文件如何处理？"><a href="#3-渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="3. 渲染过程中遇到 JS 文件如何处理？"></a>3. 渲染过程中遇到 JS 文件如何处理？</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>
<h3 id="4-什么是文档的预解析？"><a href="#4-什么是文档的预解析？" class="headerlink" title="4. 什么是文档的预解析？"></a>4. 什么是文档的预解析？</h3><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h3 id="5-CSS-如何阻塞文档解析？"><a href="#5-CSS-如何阻塞文档解析？" class="headerlink" title="5. CSS 如何阻塞文档解析？"></a>5. CSS 如何阻塞文档解析？</h3><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p>
<h3 id="6-如何优化关键渲染路径？"><a href="#6-如何优化关键渲染路径？" class="headerlink" title="6. 如何优化关键渲染路径？"></a>6. 如何优化关键渲染路径？</h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p>
<ol>
<li> 关键资源的数量。</li>
<li> 关键路径长度。</li>
<li> 关键字节的数量。</li>
</ol>
<p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>
<p>优化关键渲染路径的常规步骤如下：</p>
<ol>
<li> 对关键路径进行分析和特性描述：资源数、字节数、长度。</li>
<li> 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</li>
<li> 优化关键字节数以缩短下载时间（往返次数）。</li>
<li> 优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</li>
</ol>
<h3 id="7-什么情况会阻塞渲染？"><a href="#7-什么情况会阻塞渲染？" class="headerlink" title="7. 什么情况会阻塞渲染？"></a>7. 什么情况会阻塞渲染？</h3><p>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</p>
<p>当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p>
<h2 id="六、浏览器本地存储"><a href="#六、浏览器本地存储" class="headerlink" title="六、浏览器本地存储"></a>六、浏览器本地存储</h2><h3 id="1-浏览器本地存储方式及使用场景"><a href="#1-浏览器本地存储方式及使用场景" class="headerlink" title="1. 浏览器本地存储方式及使用场景"></a>1. 浏览器本地存储方式及使用场景</h3><ol>
<li><p>Cookie</p>
<p> Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。</p>
<p> <strong>Cookie的特性：</strong></p>
<ul>
<li>  Cookie一旦创建成功，名称就无法修改</li>
<li>  Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li>
<li>  每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li>
<li>  有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li>
<li>  Cookie在请求一个新的页面的时候都会被发送过去</li>
</ul>
<p> 如果需要域名之间跨域共享Cookie，有两种方法：</p>
<ol>
<li> 使用Nginx反向代理</li>
<li> 在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</li>
</ol>
<p> <strong>Cookie的使用场景：</strong></p>
<ul>
<li>  最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。</li>
<li>  可以用来统计页面的点击次数</li>
</ul>
</li>
<li><p>LocalStorage</p>
<p> LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p>
<p> <strong>LocalStorage的优点：</strong></p>
<ul>
<li>  在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li>
<li>  LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li>
<li>  仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li>
</ul>
<p> <strong>LocalStorage的缺点：</strong></p>
<ul>
<li>  存在浏览器兼容问题，IE8以下版本的浏览器不支持</li>
<li>  如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li>
<li>  LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li>
</ul>
<p> <strong>LocalStorage的常用API：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 localStorage</span></span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 删除保存的数据</span></span><br><span class="line"><span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 删除所有保存的数据</span></span><br><span class="line"><span class="built_in">localStorage</span>.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个索引的Key</span></span><br><span class="line"><span class="built_in">localStorage</span>.key(index)</span><br></pre></td></tr></table></figure>

<p> <strong>LocalStorage的使用场景：</strong></p>
<ul>
<li>  有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li>
<li>  在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li>
</ul>
</li>
<li><p>SessionStorage</p>
<p> SessionStorage 和 LocalStorage 都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p>
<p> <strong>SessionStorage与LocalStorage对比：</strong></p>
<ul>
<li>  SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li>
<li>  SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li>
<li>  LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li>
</ul>
<p> <strong>SessionStorage的常用API：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 sessionStorage</span></span><br><span class="line">sessionStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = sessionStorage.getItem(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除保存的数据</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除所有保存的数据</span></span><br><span class="line">sessionStorage.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个索引的Key</span></span><br><span class="line">sessionStorage.key(index)</span><br></pre></td></tr></table></figure>

<p> <strong>SessionStorage的使用场景</strong></p>
<ul>
<li>  由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</li>
</ul>
</li>
</ol>
<h3 id="2-Cookie-有哪些字段，作用分别是什么"><a href="#2-Cookie-有哪些字段，作用分别是什么" class="headerlink" title="2. Cookie 有哪些字段，作用分别是什么"></a>2. Cookie 有哪些字段，作用分别是什么</h3><p><strong>Cookie由以下字段组成：</strong></p>
<ul>
<li>  <strong>Name</strong>：cookie的名称</li>
<li>  <strong>Value</strong>：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；</li>
<li>  <strong>Size</strong>： cookie的大小</li>
<li>  <strong>Path</strong>：可以访问此cookie的页面路径。 比如domain是abc.com，path是<code>/test</code>，那么只有<code>/test</code>路径下的页面可以读取此cookie。</li>
<li>  <strong>Secure</strong>： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。</li>
<li>  <strong>Domain</strong>：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</li>
<li>  <strong>HTTP</strong>： 该字段包含<code>HTTPOnly</code> 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过<code>document.cookie</code>属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</li>
<li>  <strong>Expires/Max-size</strong> ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</li>
</ul>
<p><strong>总结：</strong> 服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</p>
<h3 id="3-Cookie、LocalStorage、SessionStorage-区别"><a href="#3-Cookie、LocalStorage、SessionStorage-区别" class="headerlink" title="3. Cookie、LocalStorage、SessionStorage 区别"></a>3. Cookie、LocalStorage、SessionStorage 区别</h3><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p>
<ul>
<li>  <strong>cookie：</strong> 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li>
<li>  <strong>sessionStorage：</strong> html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li>
<li>  <strong>localStorage：</strong> html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li>
</ul>
<p>上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p>
<h3 id="4-前端储存的⽅式有哪些？"><a href="#4-前端储存的⽅式有哪些？" class="headerlink" title="4. 前端储存的⽅式有哪些？"></a>4. 前端储存的⽅式有哪些？</h3><ul>
<li>  cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；</li>
<li>  localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；</li>
<li>  sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；</li>
<li>  Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐；</li>
<li>  IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。</li>
</ul>
<h3 id="5-IndexedDB-有哪些特点？"><a href="#5-IndexedDB-有哪些特点？" class="headerlink" title="5. IndexedDB 有哪些特点？"></a>5. IndexedDB 有哪些特点？</h3><p>IndexedDB 具有以下特点：</p>
<ul>
<li>  <strong>键值对储存</strong>：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li>
<li>  <strong>异步</strong>：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li>
<li>  <strong>支持事务</strong>：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</li>
<li>  <strong>同源限制：</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</li>
<li>  <strong>储存空间大</strong>：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</li>
<li>  <strong>支持二进制储存</strong>：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</li>
</ul>
<h2 id="七、浏览器同源策略"><a href="#七、浏览器同源策略" class="headerlink" title="七、浏览器同源策略"></a>七、浏览器同源策略</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>跨域问题其实就是浏览器的同源策略造成的。</p>
<blockquote>
<p>  同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p>
</blockquote>
<p>下表给出了与 URL <a href="https://link.juejin.cn/?target=http://store.company.com/dir/page.html">store.company.com/dir/page.ht…</a> 的源进行对比的示例:</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>是否跨域</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=http://store.company.com/dir/page.html">store.company.com/dir/page.ht…</a></td>
<td>同源</td>
<td>完全相同</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://store.company.com/dir/inner/another.html">store.company.com/dir/inner/a…</a></td>
<td>同源</td>
<td>只有路径不同</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=https://store.company.com/secure.html">store.company.com/secure.html</a></td>
<td>跨域</td>
<td>协议不同</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://store.company.com:81/dir/etc.html">store.company.com:81/dir/etc.htm…</a></td>
<td>跨域</td>
<td>端口不同 ( http:// 默认端口是80)</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://news.company.com/dir/other.html">news.company.com/dir/other.h…</a></td>
<td>跨域</td>
<td>主机不同</td>
</tr>
</tbody></table>
<p><strong>同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。</strong></p>
<p><strong>同源政策主要限制了三个方面：</strong></p>
<ul>
<li>  当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li>
<li>  当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li>
<li>  当前域下 ajax 无法发送跨域请求。</li>
</ul>
<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>
<h3 id="2-如何解决跨越问题"><a href="#2-如何解决跨越问题" class="headerlink" title="2. 如何解决跨越问题"></a>2. 如何解决跨越问题</h3><p>参考：<a href="https://www.cnblogs.com/fundebug/p/10329202.html">https://www.cnblogs.com/fundebug/p/10329202.html</a></p>
<ol>
<li><p>CORS</p>
<p> 下面是MDN对于CORS的定义：</p>
<blockquote>
<p>  跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。</p>
</blockquote>
<p> CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现<strong>CORS的关键就是服务器，只要服务器实现了CORS请求</strong>，就可以跨源通信了。</p>
<p> 浏览器将CORS分为<strong>简单请求</strong>和<strong>非简单请求</strong>：</p>
<p> 简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：</p>
<ol>
<li><strong>请求方法是以下三种方法之一：</strong><ul>
<li>  HEAD</li>
<li>  GET</li>
<li>  POST</li>
</ul>
</li>
<li><strong>HTTP的头信息不超出以下几种字段：</strong><ul>
<li>  Accept</li>
<li>  Accept-Language</li>
<li>  Content-Language</li>
<li>  Last-Event-ID</li>
<li>  Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
</li>
</ol>
<p> 若不满足以上条件，就属于非简单请求了。</p>
<ol>
<li><p><strong>简单请求过程：</strong></p>
<p> 对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com  // 和Orign一直</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span>   <span class="comment">// 表示是否允许发送Cookie</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar   <span class="comment">// 指定返回其他字段的值</span></span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span>   <span class="comment">// 表示文档类型</span></span><br></pre></td></tr></table></figure>

<p> 如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。</p>
<p> <strong>在简单请求中，在服务器内，至少需要设置字段：</strong><code>Access-Control-Allow-Origin</code></p>
</li>
<li><p><strong>非简单请求过程</strong></p>
<p> 非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，<strong>称为预检请求</strong>。</p>
<p> 浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。</p>
<p> 预检请求使用的<strong>请求方法是OPTIONS</strong>，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：</p>
<ul>
<li>  <strong>Access-Control-Request-Method</strong>：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</li>
<li>  <strong>Access-Control-Request-Headers</strong>： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</li>
</ul>
<p> 服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。</p>
<p> 服务器回应的CORS的字段如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com  // 允许跨域的源地址</span></span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT <span class="comment">// 服务器支持的所有跨域请求的方法</span></span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header  <span class="comment">// 服务器支持的所有头信息字段</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span>   <span class="comment">// 表示是否允许发送Cookie</span></span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span>  <span class="comment">// 用来指定本次预检请求的有效期，单位为秒</span></span><br></pre></td></tr></table></figure>

<p> 只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p> <strong>在非简单请求中，至少需要设置以下字段：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>  </span><br><span class="line"><span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span></span><br><span class="line"><span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="减少OPTIONS请求次数："><a href="#减少OPTIONS请求次数：" class="headerlink" title="减少OPTIONS请求次数："></a>减少OPTIONS请求次数：</h5><p> OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。</p>
<h5 id="CORS中Cookie相关问题："><a href="#CORS中Cookie相关问题：" class="headerlink" title="CORS中Cookie相关问题："></a>CORS中Cookie相关问题：</h5><p> 在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：</p>
<ul>
<li>  在请求中设置 <code>withCredentials</code></li>
</ul>
<p> 默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>  Access-Control-Allow-Credentials 设置为 true</li>
<li>  Access-Control-Allow-Origin 设置为非 <code>*</code></li>
</ul>
</li>
</ol>
</li>
<li><p>JSONP</p>
<p> <strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>
<ol>
<li><p>原生JS实现：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line">    <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span><br><span class="line">    script.src = <span class="string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">    <span class="comment">// 回调执行函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleCallback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p> 服务端返回如下（返回时即执行全局函数）：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleCallback(&#123;<span class="string">&quot;success&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;user&quot;</span>: <span class="string">&quot;admin&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>Vue axios实现：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$http = axios;</span><br><span class="line"><span class="built_in">this</span>.$http.jsonp(<span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">jsonp</span>: <span class="string">&#x27;handleCallback&#x27;</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> 后端node.js代码：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = querystring.parse(req.url.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> fn = params.callback;</span><br><span class="line">    <span class="comment">// jsonp返回设置</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/javascript&#x27;</span> &#125;);</span><br><span class="line">    res.write(fn + <span class="string">&#x27;(&#x27;</span> + <span class="built_in">JSON</span>.stringify(params) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p> <strong>JSONP的缺点：</strong></p>
<ul>
<li>  具有局限性， 仅支持get方法</li>
<li>  不安全，可能会遭受XSS攻击</li>
</ul>
</li>
</ol>
</li>
<li><p>postMessage 跨域</p>
<p> postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>  页面和其打开的新窗口的数据传递</li>
<li>  多窗口之间消息传递</li>
<li>  页面与嵌套的iframe消息传递</li>
<li>  上面三个场景的跨域数据传递</li>
</ul>
<p> 用法：postMessage(data,origin)方法接受两个参数：</p>
<ul>
<li>  <strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>
<li>  <strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li>
</ul>
<ol>
<li><p>a.html：(domain1.com/a.html)</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> style=<span class="string">&quot;display:none;&quot;</span>&gt;&lt;<span class="regexp">/iframe&gt;&lt;script&gt;           var iframe = document.getElementById(&#x27;iframe&#x27;);    iframe.onload = function() &#123;        var data = &#123;            name: &#x27;aym&#x27;        &#125;;        /</span><span class="regexp">/ 向domain2传送跨域数据        iframe.contentWindow.postMessage(JSON.stringify(data), &#x27;http:/</span><span class="regexp">/www.domain2.com&#x27;);    &#125;;    /</span><span class="regexp">/ 接受domain2返回数据    window.addEventListener(&#x27;message&#x27;, function(e) &#123;        alert(&#x27;data from domain2 ---&gt; &#x27; + e.data);    &#125;, false);&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>b.html：(domain2.com/b.html)</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 接收domain1的数据</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.data);</span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            data.number = <span class="number">16</span>;</span><br><span class="line">            <span class="comment">// 处理后再发回domain1</span></span><br><span class="line">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>nginx 代理跨域</p>
<p> nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>
<ol>
<li><p>nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>
 <figure class="highlight http"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>nginx反向代理接口跨域 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。 实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>
<p> nginx具体配置：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#proxy服务器server &#123;    listen       <span class="number">81</span>;    server_name  www.domain1.com;    location / &#123;        proxy_pass   http:<span class="comment">//www.domain2.com:8080;  #反向代理        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名        index  index.html index.htm;        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*        add_header Access-Control-Allow-Credentials true;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>nodejs 中间件代理跨域</p>
<p> node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<ol>
<li><p><strong>非vue框架的跨域</strong> 使用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<ul>
<li>  前端代码：</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();<span class="comment">// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open(&#x27;get&#x27;, &#x27;http://www.domain1.com:3000/login?user=admin&#x27;, true);xhr.send();</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  中间件服务器代码：</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">&#x27;/&#x27;</span>, proxy(&#123;</span><br><span class="line">    <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 修改响应头信息，实现跨域并允许带cookie</span></span><br><span class="line">    <span class="attr">onProxyRes</span>: <span class="function"><span class="keyword">function</span>(<span class="params">proxyRes, req, res</span>) </span>&#123;</span><br><span class="line">        res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="line">        res.header(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 修改响应信息中的cookie域名</span></span><br><span class="line">    <span class="attr">cookieDomainRewrite</span>: <span class="string">&#x27;www.domain1.com&#x27;</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">&#125;));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Proxy server is listen at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>vue框架的跨域</strong></p>
<p> node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p>
<p> webpack.config.js部分配置：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">proxy</span>: [&#123;</span><br><span class="line">            <span class="attr">context</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">secure</span>: <span class="literal">false</span>,  <span class="comment">// 当代理某些https服务报错时用</span></span><br><span class="line">            <span class="attr">cookieDomainRewrite</span>: <span class="string">&#x27;www.domain1.com&#x27;</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="attr">noInfo</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>document.domain + iframe 跨域</p>
<p> 此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1）父窗口：(domain.com/a.html)</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://child.domain.com/b.html&quot;</span>&gt;&lt;<span class="regexp">/iframe&gt;&lt;script&gt;    document.domain = &#x27;domain.com&#x27;;    var user = &#x27;admin&#x27;;&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>子窗口：(child.domain.com/a.html)</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;    <span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>;    <span class="comment">// 获取父窗口中变量    console.log(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user);&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>location.hash + iframe 跨域</p>
<p> 实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p> 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<ol>
<li><p>a.html：(domain1.com/a.html)</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> style=<span class="string">&quot;display:none;&quot;</span>&gt;&lt;<span class="regexp">/iframe&gt;&lt;script&gt;    var iframe = document.getElementById(&#x27;iframe&#x27;);    /</span><span class="regexp">/ 向b.html传hash值    setTimeout(function() &#123;        iframe.src = iframe.src + &#x27;#user=admin&#x27;;    &#125;, 1000);        /</span><span class="regexp">/ 开放给同域c.html的回调方法    function onCallback(res) &#123;        alert(&#x27;data from c.html ---&gt; &#x27; + res);    &#125;&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>b.html：(.domain2.com/b.html)</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain1.com/c.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听a.html传来的hash值，再传给c.html</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        iframe.src = iframe.src + location.hash;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>c.html：(<a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=http://www.domain1.com/c.html">www.domain1.com/c.html</a>)</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 监听b.html传来的hash值</span></span><br><span class="line">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 再通过操作同域a.html的js回调，将结果传回</span></span><br><span class="line">        <span class="built_in">window</span>.parent.parent.onCallback(<span class="string">&#x27;hello: &#x27;</span> + location.hash.replace(<span class="string">&#x27;#user=&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>window.name + iframe 跨域</p>
<p> window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<ol>
<li><p>a.html：(domain1.com/a.html)</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="function"><span class="keyword">function</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    <span class="comment">// 加载跨域页面</span></span><br><span class="line">    iframe.src = url;</span><br><span class="line">    <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span></span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">            iframe.contentWindow.location = <span class="string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;</span><br><span class="line">            state = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">    <span class="comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destoryFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        iframe.contentWindow.document.write(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求跨域b页面数据</span></span><br><span class="line">proxy(<span class="string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>proxy.html：(domain1.com/proxy.html)</p>
<p> 中间代理页，与a.html同域，内容为空即可。</p>
</li>
<li><p>b.html：(domain2.com/b.html)</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;    </span><br><span class="line">    <span class="built_in">window</span>.name = <span class="string">&#x27;This is domain2 data!&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p> 通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
</li>
</ol>
</li>
<li><p>WebSocket 协议跨域</p>
<p> WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p>
<p> 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<ol>
<li><p>前端代码：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=<span class="string">&quot;text&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> socket = io(<span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 连接成功处理</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">socket.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 监听服务端消息</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    socket.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(<span class="string">&#x27;data from server: ---&gt; &#x27;</span> + msg); </span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 监听服务端关闭</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    socket.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(<span class="string">&#x27;Server socket has closed.&#x27;</span>); </span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    socket.send(<span class="built_in">this</span>.value);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>Nodejs socket后台：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        client.send(<span class="string">&#x27;hello：&#x27;</span> + msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;data from client: ---&gt; &#x27;</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Client socket has closed.&#x27;</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="3-正向代理和反向代理的区别"><a href="#3-正向代理和反向代理的区别" class="headerlink" title="3. 正向代理和反向代理的区别"></a>3. 正向代理和反向代理的区别</h3><ul>
<li><p><strong>正向代理：</strong></p>
<p>  客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p>
</li>
<li><p><strong>反向代理：</strong></p>
<p>  服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p>
</li>
</ul>
<p>两者区别如图示： </p>
<p><img src="/2021/12/21/browser/06-6-3.png"></p>
<p>正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p>
<h3 id="4-Nginx-的概念及其工作原理"><a href="#4-Nginx-的概念及其工作原理" class="headerlink" title="4. Nginx 的概念及其工作原理"></a>4. Nginx 的概念及其工作原理</h3><p>Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。</p>
<p>传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。</p>
<p>Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。</p>
<h2 id="八、浏览器事件机制"><a href="#八、浏览器事件机制" class="headerlink" title="八、浏览器事件机制"></a>八、浏览器事件机制</h2><h3 id="1-事件是什么？事件模型？"><a href="#1-事件是什么？事件模型？" class="headerlink" title="1. 事件是什么？事件模型？"></a>1. 事件是什么？事件模型？</h3><p>事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
<p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：</p>
<ul>
<li>  <strong>DOM0 级事件模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。</li>
<li>  <strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li>
<li>  <strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li>
</ul>
<h3 id="2-如何阻止事件冒泡"><a href="#2-如何阻止事件冒泡" class="headerlink" title="2. 如何阻止事件冒泡"></a>2. 如何阻止事件冒泡</h3><ul>
<li>  普通浏览器使用：event.stopPropagation()</li>
<li>  IE浏览器使用：event.cancelBubble = true;</li>
</ul>
<h3 id="3-对事件委托的理解"><a href="#3-对事件委托的理解" class="headerlink" title="3. 对事件委托的理解"></a>3. 对事件委托的理解</h3><ol>
<li><p>事件委托的概念</p>
<p> 事件委托本质上是利用了<strong>浏览器事件冒泡</strong>的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。</p>
<p> 使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。</p>
</li>
<li><p>事件委托的特点</p>
<ul>
<li><p>减少内存消耗</p>
<p>  如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item n<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。</p>
</li>
<li><p>动态绑定事件</p>
<p>  给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span></span><br><span class="line"><span class="comment">// 给父层元素绑定事件</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 兼容性处理</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">var</span> target = event.target || event.srcElement;</span><br><span class="line">  <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">  <span class="keyword">if</span> (target.nodeName.toLocaleLowerCase === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;the content is: &#x27;</span>, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p>
</li>
</ul>
</li>
<li><p>局限性</p>
<p> 当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</p>
<p> 当然事件委托不是只有优点，它也是有<strong>缺点</strong>的，事件委托会影响页面性能，主要影响因素有：</p>
<ul>
<li>  元素中，绑定事件委托的次数；</li>
<li>  点击的最底层元素，到绑定事件元素之间的<code>DOM</code>层数；</li>
</ul>
<p> 在必须使用事件委托的地方，可以进行如下的处理：</p>
<ul>
<li>  只在必须的地方，使用事件委托，比如：<code>ajax</code>的局部刷新区域</li>
<li>  尽量的减少绑定的层级，不在<code>body</code>元素上，进行绑定</li>
<li>  减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。</li>
</ul>
</li>
</ol>
<h3 id="4-事件委托的使用场景"><a href="#4-事件委托的使用场景" class="headerlink" title="4. 事件委托的使用场景"></a>4. 事件委托的使用场景</h3><p>场景：给页面的所有的a标签添加click事件，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e.target.nodeName == <span class="string">&quot;A&quot;</span>)</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。</p>
<p>这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> node = e.target;</span><br><span class="line">	<span class="keyword">while</span> (node.parentNode.nodeName != <span class="string">&quot;BODY&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node.nodeName == <span class="string">&quot;A&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node = node.parentNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-同步和异步的区别"><a href="#5-同步和异步的区别" class="headerlink" title="5. 同步和异步的区别"></a>5. 同步和异步的区别</h3><ul>
<li>  <strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li>
<li>  <strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</li>
</ul>
<h3 id="6-对事件循环的理解"><a href="#6-对事件循环的理解" class="headerlink" title="6. 对事件循环的理解"></a>6. 对事件循环的理解</h3><p>因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。</p>
<p><img src="/2021/12/21/browser/06-8-6.png" alt="img"></p>
<p>Event Loop 执行顺序如下所示：</p>
<ul>
<li>  首先执行同步代码，这属于宏任务</li>
<li>  当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li>
<li>  执行所有微任务</li>
<li>  当执行完所有微任务后，如有必要会渲染页面</li>
<li>  然后开始下一轮 Event Loop，执行宏任务中的异步代码</li>
</ul>
<h3 id="7-宏任务和微任务分别有哪些"><a href="#7-宏任务和微任务分别有哪些" class="headerlink" title="7. 宏任务和微任务分别有哪些"></a>7. 宏任务和微任务分别有哪些</h3><ul>
<li>  微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li>
<li>  宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</li>
</ul>
<h3 id="8-什么是执行栈"><a href="#8-什么是执行栈" class="headerlink" title="8. 什么是执行栈"></a>8. 什么是执行栈</h3><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。 </p>
<p><img src="/2021/12/21/browser/06-8-8-1.png" alt="img"> </p>
<p>当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了。</p>
<p>平时在开发中，可以在报错中找到执行栈的痕迹：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/21/browser/06-8-8-2.png" alt="img"> </p>
<p>可以看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的。当使用递归时，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;  bar()&#125;bar()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/21/browser/06-8-8-3.png" alt="img"></p>
<h3 id="9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？（注意node11版本之前和之后eventloop执行顺序的不同）"><a href="#9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？（注意node11版本之前和之后eventloop执行顺序的不同）" class="headerlink" title="9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？（注意node11版本之前和之后eventloop执行顺序的不同）"></a>9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？（注意node11版本之前和之后eventloop执行顺序的不同）</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。</p>
<p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>
<p><img src="/2021/12/21/browser/06-8-9-1.png"></p>
<ol>
<li> <strong>Timers（计时器阶段）</strong>：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</li>
<li> <strong>Pending callbacks</strong>：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。</li>
<li> <strong>Idle/Prepare</strong>：仅供内部使用。</li>
<li><strong>Poll（轮询阶段）</strong>：<ul>
<li>  当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。</li>
<li>  当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。</li>
</ul>
</li>
<li> <strong>Check（查询阶段）</strong>：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</li>
<li> <strong>Close callbacks</strong>：执行一些关闭回调，比如socket.on(‘close’, …)等。</li>
</ol>
<p>下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)&#125;, <span class="number">0</span>)</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p>
<ul>
<li>  首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li>
<li>  进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li>
<li>  那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li>
</ul>
<p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.readFile(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p>
<p>上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前<strong>清空</strong> microtask 队列，下图中的 Tick 就代表了 microtask </p>
<p><img src="/2021/12/21/browser/06-8-9-2.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer21&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。</p>
<p>最后来看 Node 中的 <code>process.nextTick</code>，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会<strong>清空队列中的所有回调函数</strong>，并且优先于其他 microtask 执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line"> process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">   process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">     process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于以上代码，永远都是先把 nextTick 全部打印出来。</p>
<h3 id="10-事件触发的过程是怎样的"><a href="#10-事件触发的过程是怎样的" class="headerlink" title="10. 事件触发的过程是怎样的"></a>10. 事件触发的过程是怎样的</h3><p>事件触发有三个阶段：</p>
<ul>
<li>  <code>window</code> 往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>  传播到事件触发处时触发注册的事件</li>
<li>  从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li>
</ul>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，<strong>如果给一个 *<em><code>body</code>*</em> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下会先打印冒泡然后是捕获</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕获 &#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通常使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：</p>
<ul>
<li>  <code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li>
<li>  <code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li>
<li>  <code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li>
</ul>
<p>一般来说，如果只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。</p>
<p><code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    event.stopImmediatePropagation()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕获 &#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="九、浏览器垃圾回收机制"><a href="#九、浏览器垃圾回收机制" class="headerlink" title="九、浏览器垃圾回收机制"></a>九、浏览器垃圾回收机制</h2><h3 id="1-V8的垃圾回收机制是怎样的"><a href="#1-V8的垃圾回收机制是怎样的" class="headerlink" title="1. V8的垃圾回收机制是怎样的"></a>1. V8的垃圾回收机制是怎样的</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p>
<ol>
<li><p><strong>新生代算法</strong></p>
<p> 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p>
<p> 在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p>
</li>
<li><p><strong>老生代算法</strong></p>
<p> 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p>
<p> 先来说下什么情况下对象会出现在老生代空间中：</p>
<ul>
<li>  新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li>
<li>  To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li>
</ul>
<p> 老生代中的空间很复杂，有如下几个空间</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">enum AllocationSpace &#123;</span><br><span class="line">  <span class="comment">// TODO(v8:7464): Actually map this space&#x27;s memory as read-only.</span></span><br><span class="line">  RO_SPACE,    <span class="comment">// 不变的对象空间</span></span><br><span class="line">  NEW_SPACE,   <span class="comment">// 新生代用于 GC 复制算法的空间</span></span><br><span class="line">  OLD_SPACE,   <span class="comment">// 老生代常驻对象空间</span></span><br><span class="line">  CODE_SPACE,  <span class="comment">// 老生代代码对象空间</span></span><br><span class="line">  MAP_SPACE,   <span class="comment">// 老生代 map 对象</span></span><br><span class="line">  LO_SPACE,    <span class="comment">// 老生代大空间对象</span></span><br><span class="line">  NEW_LO_SPACE,  <span class="comment">// 新生代大空间对象</span></span><br><span class="line">  FIRST_SPACE = RO_SPACE,</span><br><span class="line">  LAST_SPACE = NEW_LO_SPACE,</span><br><span class="line">  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,</span><br><span class="line">  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 在老生代中，以下情况会先启动标记清除算法：</p>
<ul>
<li>  某一个空间没有分块的时候</li>
<li>  空间中被对象超过一定限制</li>
<li>  空间不能保证新生代中的对象移动到老生代中</li>
</ul>
<p> 在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。</p>
<p> 清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>
</li>
</ol>
<h3 id="2-哪些操作会造成内存泄漏？"><a href="#2-哪些操作会造成内存泄漏？" class="headerlink" title="2. 哪些操作会造成内存泄漏？"></a>2. 哪些操作会造成内存泄漏？</h3><ul>
<li>  第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li>  第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li>  第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>  第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
<h3 id="执行栈，调用栈，Event-loop"><a href="#执行栈，调用栈，Event-loop" class="headerlink" title="执行栈，调用栈，Event loop"></a>执行栈，调用栈，Event loop</h3>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS面试题</title>
    <url>/2021/11/27/css/</url>
    <content><![CDATA[<p>绝大部分内容来自：<a href="https://juejin.cn/user/3544481220801815">https://juejin.cn/user/3544481220801815</a></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2021/11/27/css/02.CSS%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="02.CSS面试题"></p>
<h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><ol>
<li><p>基本选择器</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>通用选择器</td>
<td>*</td>
<td>所有元素</td>
<td>2</td>
</tr>
<tr>
<td>元素类型选择器</td>
<td>&lt;元素类型&gt;（例如：div）</td>
<td>所有指定类型的元素</td>
<td>1</td>
</tr>
<tr>
<td>元素类选择器</td>
<td>&lt;类型&gt;(或 *.&lt;类型&gt;)<br />&lt;元素类型&gt;.&lt;类名&gt;</td>
<td>属于指定类的元素；<br />当跟元素类型一起使用时，匹配属于指定类的特定类型的元素</td>
<td>1</td>
</tr>
<tr>
<td>ID选择器</td>
<td>#&lt;id值&gt;</td>
<td>具有指定全局属性 id 值的元素</td>
<td>1</td>
</tr>
<tr>
<td>属性选择器</td>
<td>[&lt;条件&gt;]<br />&lt;元素类型&gt;[&lt;条件&gt;]</td>
<td>具有匹配指定条件的属性的元素；<br />当跟元素类型一起使用时，匹配满足条件的特定类型的元素<br />条件说明（括号内为最低支持版本）：<br />1.[attr]：选择定义attr属性的元素，忽略属性值（2）<br />2.[attr=“val”]：选择定义attr属性，且属性值为val的元素（2）<br />3.[attr^=“val”]：选择定义attr属性，且属性值以字符串val打头的元素（3）<br />4.[attr$=“val”]：选择定义attr属性，且属性值以字符串val结尾的元素（3）<br />5.[attr*=“val”]：选择定义attr属性，且属性值包含字符串val的元素（3）<br />6.[attr~=“val”]：选择定义attr属性，且属性值具有多个值，其中一个为字符串val的元素（2）<br />7.[attr|=“val”]：选择定义attr属性，且属性值为连字符分割的多个值，其中第一个为字符串val的元素（2）</td>
<td>视情况定</td>
</tr>
</tbody></table>
</li>
<li><p>复合选择器</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>并集选择器</td>
<td>&lt;选择器&gt;,&lt;选择器&gt;,&lt;选择器&gt;</td>
<td>单个选择器匹配的所有元素的并集</td>
<td>1</td>
</tr>
<tr>
<td>后代选择器</td>
<td>&lt;第一个选择器&gt; &lt;第二个选择器&gt;</td>
<td>目标元素为匹配第一个选择器的元素的后代，且匹配第二个选择器</td>
<td>1</td>
</tr>
<tr>
<td>子代选择器</td>
<td>&lt;第一个选择器&gt; &gt; &lt;第二个选择器&gt;</td>
<td>目标元素为匹配第一个选择器的元素的直接后代，且匹配第二个选择器</td>
<td>2</td>
</tr>
<tr>
<td>相邻兄弟选择器</td>
<td>&lt;第一个选择器&gt; + &lt;第二个选择器&gt;</td>
<td>目标元素紧跟匹配第一个选择器的元素，且匹配第二个选择器</td>
<td>2</td>
</tr>
<tr>
<td>普通兄弟选择器</td>
<td>&lt;第一个选择器&gt; ~ &lt;第二个选择器&gt;</td>
<td>目标元素位于匹配第一个选择器的元素之后，且匹配第二个选择器</td>
<td>3</td>
</tr>
</tbody></table>
</li>
<li><p>伪元素选择器</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>::first-line 选择器</td>
<td>::first-line</td>
<td>文本内容的首行</td>
<td>1</td>
</tr>
<tr>
<td>::first-letter 选择器</td>
<td>::first-letter</td>
<td>文本内容的首字母</td>
<td>1</td>
</tr>
<tr>
<td>:before 选择器</td>
<td>:before</td>
<td>说明：在选中元素的内容之前插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:after 选择器</td>
<td>:after</td>
<td>说明：在选中元素的内容之后插入内容</td>
<td>2</td>
</tr>
</tbody></table>
<blockquote>
<p>  伪元素选择器的前缀是两个冒号（ :: ），但浏览器认为选择器只有一个冒号（也就是说将 ::first-line看做 ::first-line）。这样它的格式就跟伪类选择器的格式一致了，这是为了向后兼容。</p>
</blockquote>
</li>
<li><p>伪类选择器</p>
<ol>
<li><p>结构性伪类选择器</p>
 <table>
       <tr>
         <th>选择器类型</th>
         <th>选择器</th>
         <th>匹配/说明</th>
         <th>最低支持CSS版本</th>
     </tr>
     <tr>
         <td>:root 选择器</td>
         <td>:root</td>
         <td>选择文档中的根元素，总是返回html</td>
         <td>3</td>
     </tr>
     <tr>
         <td rowspan="4">子元素选择器</td>
         <td>:first-child</td>
         <td>选择元素的第一个元素</td>
         <td>2</td>
     </tr>
     <tr>
         <td>:last-child</td>
         <td>选择元素的最后一个元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:only-child</td>
         <td>选择元素的唯一子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:only-of-type</td>
         <td>选择元素指定类型的唯一子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td rowspan="4">:nth-child 选择器</td>
         <td>:nth-child(n)</td>
         <td>选择父元素的第n个子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:nth-last-child(n)</td>
         <td>选择父元素的倒数第n个子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:nth-of-type(n)</td>
         <td>选择父元素定义类型的第n个子元素</td>
         <td>3</td>
     </tr>
     <tr>
         <td>:nth-last-of-type(n)</td>
         <td>选择父元素定义类型的倒数第n个子元素</td>
         <td>3</td>
     </tr>
 </table></li>
<li><p>UI 伪类选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>:enabled</td>
<td>选择启用状态的元素</td>
<td>3</td>
</tr>
<tr>
<td>:disabled</td>
<td>选择禁用状态的元素</td>
<td>3</td>
</tr>
<tr>
<td>:checked</td>
<td>选择被选中的input的元素（只用于单选按钮和复选框）</td>
<td>3</td>
</tr>
<tr>
<td>:default</td>
<td>选择默认元素</td>
<td>3</td>
</tr>
<tr>
<td>:valid<br />:invalid</td>
<td>根据输入验证选择有效或者无效的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:in-range<br />:out-of-range</td>
<td>选择在指定范围之内或者之外受限的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:required<br />:optional</td>
<td>根据是否允许 :required 属性选择input元素</td>
<td>3</td>
</tr>
</tbody></table>
</li>
<li><p>动态伪类选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>匹配/说明</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>:link</td>
<td>选择链接元素</td>
<td>1</td>
</tr>
<tr>
<td>:visited</td>
<td>选择用户已访问的链接元素</td>
<td>1</td>
</tr>
<tr>
<td>:hover</td>
<td>鼠标悬停在其上的元素</td>
<td>2</td>
</tr>
<tr>
<td>:active</td>
<td>当前被用户激活的元素，通常意味着用户即将点击（或者按压）该元素</td>
<td>2</td>
</tr>
<tr>
<td>:focus</td>
<td>当前获得焦点的元素</td>
<td>2</td>
</tr>
</tbody></table>
</li>
<li><p>其它伪类选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>匹配</th>
<th>最低支持CSS版本</th>
</tr>
</thead>
<tbody><tr>
<td>:not(&lt;选择器&gt;)</td>
<td>对括号内选择器的选择取反</td>
<td>3</td>
</tr>
<tr>
<td>:empty</td>
<td>没有子元素的元素</td>
<td>3</td>
</tr>
<tr>
<td>:lang(&lt;目标语言&gt;)</td>
<td>选择基于lang全局属性值的元素</td>
<td>1</td>
</tr>
<tr>
<td>:target</td>
<td>URL片段标识符指向的元素</td>
<td>3</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<p><strong>从层叠、继承、优先级来讨论如果有多个应用于某个元素的css样式时，为什么会显示这个样式，而不会显示另外一个样式：</strong></p>
<ul>
<li><p>层叠</p>
<ul>
<li>  层叠的概念是如果优先级相等，对于同一元素，后面的css样式会覆盖前面的css样式；</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li>  继承的概念是子元素会继承父元素的某些属性，从而表现出和父元素一样的样式；</li>
<li>  这里要注意的是有些元素可以被继承（eg：color，font-family）,有些则不能被继承（eg：height，width）；</li>
</ul>
</li>
<li><p>优先级</p>
<ul>
<li><p>选择器优先级的计算方式</p>
<ul>
<li>  第一位加1：如果某个元素具有内联样式，虽然没有选择器，具有内联样式时此位恒为1；</li>
<li>  第二位加1：如果选择器包含一个id选择器时；</li>
<li>  第三位加1：如果选择器包含一个类选择器、伪类选择器或属性选择器时；</li>
<li>  第四位加1：如果选择器包含一个元素选择器或伪元素选择器时；</li>
</ul>
<p>  注：通用选择器 (<code>*</code>)，组合符 (<code>+</code>, <code>&gt;</code>, <code>~</code>, ‘ ‘)，和否定伪类 (<code>:not</code>) 不会影响优先级。</p>
</li>
<li><p>注意事项</p>
<ul>
<li>  !important声明的样式的优先级最高，权重为正无穷；</li>
<li>  如果优先级相同，则最后出现的样式生效；</li>
<li>  继承得到的样式的优先级最低；</li>
<li>  通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li>
<li>  样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p>
<ol>
<li> <strong>display</strong>：规定元素应该生成的框的类型</li>
<li><strong>文本属性</strong>：<ul>
<li>  vertical-align：垂直文本对齐</li>
<li>  text-decoration：规定添加到文本的装饰</li>
<li>  text-shadow：文本阴影效果</li>
<li>  white-space：空白符的处理</li>
<li>  unicode-bidi：设置文本的方向</li>
</ul>
</li>
<li> <strong>盒子模型的属性</strong>：width、height、margin、border、padding</li>
<li> <strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li>
<li> <strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
<li> <strong>生成内容属性</strong>：content、counter-reset、counter-increment</li>
<li> <strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li>
<li> <strong>页面样式属性</strong>：size、page-break-before、page-break-after</li>
<li> <strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li>
</ol>
<p><strong>二、有继承性的属性</strong></p>
<ol>
<li><strong>字体系列属性</strong><ul>
<li>  font-family：字体系列</li>
<li>  font-weight：字体的粗细</li>
<li>  font-size：字体的大小</li>
<li>  font-style：字体的风格</li>
</ul>
</li>
<li><strong>文本系列属性</strong><ul>
<li>  text-indent：文本缩进</li>
<li>  text-align：文本水平对齐</li>
<li>  line-height：行高</li>
<li>  word-spacing：单词之间的间距</li>
<li>  letter-spacing：中文或者字母之间的间距</li>
<li>  text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li>
<li>  color：文本颜色</li>
</ul>
</li>
<li><strong>元素可见性</strong><ul>
<li>  visibility：控制元素显示隐藏</li>
</ul>
</li>
<li><strong>列表布局属性</strong><ul>
<li>  list-style：列表风格，包括list-style-type、list-style-image等</li>
</ul>
</li>
<li><strong>光标属性</strong><ul>
<li>  cursor：光标显示为何种形态</li>
</ul>
</li>
</ol>
<h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>此元素不会被显示。</td>
</tr>
<tr>
<td>block</td>
<td>此元素将显示为块级元素，此元素前后会带有换行符。</td>
</tr>
<tr>
<td>inline</td>
<td>默认。此元素会被显示为内联元素，元素前后没有换行符。</td>
</tr>
<tr>
<td>inline-block</td>
<td>行内块元素。（CSS2.1 新增的值）</td>
</tr>
<tr>
<td>list-item</td>
<td>此元素会作为列表显示。</td>
</tr>
<tr>
<td>run-in</td>
<td>此元素会根据上下文作为块级元素或内联元素显示。</td>
</tr>
<tr>
<td>compact</td>
<td>CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td>
</tr>
<tr>
<td>marker</td>
<td>CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。<br />1.inline-table: 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。<br />2.table-row-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。<br />3.table-header-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。<br />4.table-footer-group: 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。<br />5.table-row: 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。<br />6.table-column-group: 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。<br />7.table-column: 此元素会作为一个单元格列显示（类似 &lt;col&gt;）<br />8.table-cell: 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;）<br />9.table-caption: 此元素会作为一个表格标题显示（类似 &lt;caption&gt;）</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 display 属性的值。</td>
</tr>
</tbody></table>
<h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><ol>
<li> <strong>block：</strong> 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</li>
<li> <strong>inline：</strong> 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li>
<li> <strong>inline-block：</strong> 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</li>
</ol>
<p>对于行内元素和块级元素，其特点如下：</p>
<ol>
<li><strong>行内元素</strong><ul>
<li>  设置宽高无效；</li>
<li>  可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li>
<li>  不会自动换行；</li>
</ul>
</li>
<li><strong>块级元素</strong><ul>
<li>  可以设置宽高；</li>
<li>  设置margin和padding都有效；</li>
<li>  可以自动换行；</li>
<li>  多个块状，默认排列从上到下。</li>
</ul>
</li>
</ol>
<h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul>
<li>  <strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li>
<li>  <strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li>
<li>  <strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li>
<li>  <strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li>
<li>  <strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li>
<li>  <strong>clip/clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li>
<li>  **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li>
</ul>
<h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p><strong>两者都是外部引用CSS的方式，它们的区别如下：</strong></p>
<ul>
<li>  link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li>
<li>  link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>  link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li>
<li>  link支持使用Javascript控制DOM去改变样式；而@import不支持。</li>
</ul>
<p><strong>link先于@import加载，为什么@import和link优先级相同，@import的样式没有覆盖link？</strong></p>
<ul>
<li>  浏览器渲染的动作一般会执行多次的。最后一次渲染，一定是基于之前加载过的所有样式整合后渲染树进行绘制页面的，已经被渲染过的页面元素，也会被重新渲染。</li>
<li>  那么我们就可以把@import这种导入 CSS 文件的方式理解成一种替换，CSS 解析引擎在对一个 CSS 文件进行解析时，如在文件顶部遇到@import，将被替换为该@import导入的 CSS 文件中的全部样式。</li>
<li>  @import引入的样式，其虽然后被加载，却会在加载完毕后置于样式表顶部，最终渲染时自然会被下面的同名样式层叠。</li>
</ul>
<p><strong>为什么建议用link而不是@import</strong></p>
<ul>
<li>  每个@import都会产生一个新的http请求，消耗服务器资源</li>
<li>  @import混合js文件时，在IE中引发资源文件的下载顺序被打乱（即使排列在@import后面的js文件先于@import下载），而且会打乱甚至破坏@import自身的并行下载 </li>
<li>  link混合@import会破坏并行下载，这会导致原本并行下载的样式变成一个一个的同步下载</li>
<li>  仅用link标签，可确保样式在所有浏览器里面都能被并行且按照顺序被下载</li>
<li>  如果import加载的样式比较大，容易出现加载延迟，甚至有闪屏的情况</li>
</ul>
<h3 id="7-transition和animation的区别"><a href="#7-transition和animation的区别" class="headerlink" title="7. transition和animation的区别"></a>7. transition和animation的区别</h3><ul>
<li>  <strong>transition是过渡属性</strong>，强调过渡，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</li>
<li>  <strong>animation是动画属性</strong>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</li>
</ul>
<h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者区别如下：</strong></p>
<ol>
<li><strong>在渲染树中</strong><ul>
<li>  <code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li>
<li>  <code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li>
</ul>
</li>
<li><strong>是否是继承属性</strong><ul>
<li>  <code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li>
<li>  <code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；</li>
</ul>
</li>
<li> 修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</li>
<li> 如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</li>
</ol>
<h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. 伪元素和伪类的区别和作用？</h3><p><strong>定义</strong></p>
<ul>
<li><p>  伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。</p>
</li>
<li><p>  伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</p>
</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><p>表示方法</p>
<p>  CSS2 中伪类、伪元素都是以单冒号<code>:</code>表示，CSS2.1 后规定伪类用单冒号表示，伪元素用双冒号<code>::</code>表示，浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first-line, :first-letter 等)的单冒号写法。对于 CSS2 之后所有新增的伪元素(如::selection)，应该采用双冒号的写法。但是因为兼容性问题，大部分还是用的单冒号。</p>
</li>
<li><p>定义不同</p>
<p>  伪类即假的类，通常可以添加类来达到效果，伪元素即假元素，需要通过添加元素才能达到效果。</p>
</li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li>  伪类和伪元素都是用来表示文档树以外的”元素”。</li>
<li>  伪类和伪元素分别用单冒号<code>:</code>和双冒号<code>::</code>来表示。</li>
<li>  伪类和伪元素的区别，最关键的点在于如果没有伪元素(或伪类)，是否需要添加元素才能达到目的，如果是则是伪元素，反之则是伪类。</li>
</ul>
<h3 id="10-对requestAnimationframe的理解"><a href="#10-对requestAnimationframe的理解" class="headerlink" title="10. 对requestAnimationframe的理解"></a>10. 对requestAnimationframe的理解</h3><p>参考：<a href="https://juejin.cn/post/6991297852462858277#heading-3">https://juejin.cn/post/6991297852462858277#heading-3</a></p>
<p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是<strong>请求动画帧</strong>。</p>
<p>MDN对该方法的描述：</p>
<blockquote>
<p>  window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
</blockquote>
<p><strong>语法：</strong> <code>window.requestAnimationFrame(callback);</code>  其中，callback是<strong>下一次重绘之前更新动画帧所调用的函数</strong>(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p>
<p><strong>取消动画：</strong> 使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p>
<p><strong>优势：</strong></p>
<ul>
<li>  <strong>CPU节能</strong>：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li>
<li>  <strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li>
<li>  <strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
</ul>
<p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p>
<ul>
<li>  settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li>
<li>  settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li>
</ul>
<h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><ul>
<li><p>盒⼦模型的概念</p>
<p>  盒⼦模型（boxmodel）。⽹⻚中，每⼀个元素都占有⼀定的空间，⽆论是div、h1~h6、还是p，都可以看成是盒⼦。</p>
</li>
<li><p>盒⼦模型的组成</p>
<ul>
<li><p>⼀个元素占有空间的⼤小由⼏个部分构成，其中包括</p>
<ul>
<li>  元素的内容（content），</li>
<li>  元素的内边距（padding），内容与边框之间的距离</li>
<li>  元素的边框（border），</li>
<li>  元素的外边距（margin），边框与外部元素之间的距离</li>
</ul>
<p>  四个部分，这四个部分⼀起构成了盒⼦模型。</p>
</li>
<li><p>注意：margin重叠，也叫margin塌陷</p>
<p>  标准⽂档流中，两个盒⼦，分别有上下外边距，竖直⽅向的margin不叠加，只取较⼤的值作为margin(⽔平⽅向的margin是可以叠加的)。</p>
</li>
<li><p>  margin这个属性，本质上描述的是兄弟和兄弟之间的距离；最好不要⽤这个marign表达⽗⼦之间的距离。如果向设置⽗⼦之间的距离，我们最好使⽤⽗元素的padding。</p>
</li>
</ul>
</li>
<li><p>盒⼦模型的分类</p>
<ul>
<li>  盒模型分为：W3C标准盒⼦、IE盒⼦</li>
<li>  W3C标准盒⼦（content-box）：⼜称内容盒⼦，是指块元素box-sizing属性为content-box的盒模型。⼀般在现代浏览器中使⽤的都是正常盒模型content-box。它所说的width⼀般只包含内容，不包含padding与margin，并且盒⼦的⼤小会以内容优先，⾃动扩展，⼦元素可以撑开⽗元素.</li>
<li>  IE盒⼦（border-box）：⼜称怪异盒模型（边框盒⼦），是指块元素box-sizing属性为border-box的盒模型。⼀般在IE浏览器中默认为这种怪异盒模型，但是由于其⾃⾝的特殊性，⼿机⻚⾯中也有使⽤怪异盒模型。怪异盒模型中，⽗元素的盒模型确定，⼦元素⽆法撑开⽗元素的盒模型。</li>
</ul>
</li>
</ul>
<h3 id="12-为什么有时候⽤translate来改变位置⽽不是定位？"><a href="#12-为什么有时候⽤translate来改变位置⽽不是定位？" class="headerlink" title="12. 为什么有时候⽤translate来改变位置⽽不是定位？"></a>12. 为什么有时候⽤translate来改变位置⽽不是定位？</h3><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p>
<p>参考：<a href="https://juejin.cn/post/6844904077394984968#heading-0">https://juejin.cn/post/6844904077394984968#heading-0</a></p>
<h3 id="13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？"><a href="#13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？" class="headerlink" title="13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？"></a>13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？</h3><p>浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个<code>&lt;li&gt;</code>放在一行，这导致<code>&lt;li&gt;</code>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p>
<p><strong>解决办法：</strong></p>
<p>（1）为<code>&lt;li&gt;</code>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p>
<p>（2）将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</p>
<p>（3）将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即font-size:0。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p>
<p>（4）消除<code>&lt;ul&gt;</code>的字符间隔letter-spacing:-8px，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符间隔设为默认letter-spacing:normal。</p>
<h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><p>参考：<a href="https://juejin.cn/post/6844903518520901639#heading-43%EF%BC%8Chttps://juejin.cn/post/6844903829679390728#heading-3">https://juejin.cn/post/6844903518520901639#heading-43，https://juejin.cn/post/6844903829679390728#heading-3</a></p>
<ol>
<li><p> 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）见1</p>
</li>
<li><p>边框</p>
 <table>
       <tr>
         <th>属性</th>
         <th  colspan="2">说明</th>
     </tr>
     <tr>
         <td rowspan="6">border-image</td>
         <td colspan="2">使用图像作为边框的简写属性</td>
     </tr>
     <tr>
         <td>border-image-outset</td>
         <td>指定图像向边框盒外部扩展的区域</td>
     </tr>
     <tr>
         <td>border-image-repeat</td>
         <td>指定边框图像的缩放和重复方式</td>
     </tr>
     <tr>
         <td>border-image-slice</td>
         <td>指定边框图像的切割方式</td>
     </tr>
     <tr>
         <td>border-image-source</td>
         <td>设置边框图片的来源路径</td>
     </tr>
     <tr>
         <td>border-image-width</td>
         <td>设置边框图像的宽度</td>
     </tr>
     <tr>
         <td rowspan="5">border-radius</td>
         <td colspan="2">使用圆角边框的简写属性</td>
     </tr>
     <tr>
         <td>border-top-left-radius</td>
         <td>将边框左上角设置为圆角</td>
     </tr>
     <tr>
         <td>border-top-right-radius</td>
         <td>将边框右上角设置为圆角</td>
     </tr>
     <tr>
         <td>border-bottom-left-radius</td>
         <td>将边框左下角设置为圆角</td>
     </tr>
     <tr>
         <td>border-bottom-right-radius</td>
         <td>将边框右下角设置为圆角</td>
     </tr>
     <tr>
         <td>box-shadow</td>
         <td colspan="2">设置元素的一个或多个阴影效果</td>
     </tr>
 </table>    </li>
<li><p>背景</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background-clip</td>
<td>规定背景的绘制区域。</td>
</tr>
<tr>
<td>background-origin</td>
<td>规定背景图片的定位区域。</td>
</tr>
<tr>
<td>background-size</td>
<td>规定背景图片的尺寸。</td>
</tr>
</tbody></table>
</li>
<li><p>渐变</p>
<ul>
<li><p>线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(direction, color-stop1, color-stop2, ...);</span><br></pre></td></tr></table></figure></li>
<li><p>径向渐变（Radial Gradients）- 由它们的中心定义</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(center, shape size, start-color, ..., last-color);</span><br></pre></td></tr></table></figure></li>
<li><p>圆锥渐变（Conic Gradient）</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">conic-gradient</span>(red, orange, yellow, green, teal, blue, purple);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>文本属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@font-face</td>
<td>指定网页使用的字体</td>
</tr>
<tr>
<td>hanging-punctuation</td>
<td>规定标点字符是否位于线框之外。</td>
</tr>
<tr>
<td>punctuation-trim</td>
<td>规定是否对标点字符进行修剪。</td>
</tr>
<tr>
<td>text-align-last</td>
<td>设置如何对齐最后一行或紧挨着强制换行符之前的行。</td>
</tr>
<tr>
<td>text-emphasis</td>
<td>向元素的文本应用重点标记以及重点标记的前景色。</td>
</tr>
<tr>
<td>text-justify</td>
<td>规定当 text-align 设置为 “justify” 时所使用的对齐方法。</td>
</tr>
<tr>
<td>text-outline</td>
<td>规定文本的轮廓。</td>
</tr>
<tr>
<td>text-overflow</td>
<td>规定当文本溢出包含元素时发生的事情。</td>
</tr>
<tr>
<td>text-shadow</td>
<td>向文本添加阴影。</td>
</tr>
<tr>
<td>text-wrap</td>
<td>规定文本的换行规则。</td>
</tr>
<tr>
<td>word-break</td>
<td>规定非中日韩文本的换行规则。</td>
</tr>
<tr>
<td>word-wrap</td>
<td>允许对长的不可分割的单词进行分割并换行到下一行。</td>
</tr>
</tbody></table>
</li>
<li><p>转换和变形</p>
<p> <strong>2D新转换属性</strong></p>
<p> 以下列出了所有的转换属性:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>适用于2D或3D转换的元素</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许您更改转化元素位置</td>
</tr>
</tbody></table>
<p> <strong>2D 转换方法</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>matrix(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td>定义 2D 转换，使用六个值的矩阵。</td>
</tr>
<tr>
<td>translate(<em>x</em>,<em>y</em>)</td>
<td>定义 2D 转换，沿着 X 和 Y 轴移动元素。</td>
</tr>
<tr>
<td>translateX(<em>n</em>)</td>
<td>定义 2D 转换，沿着 X 轴移动元素。</td>
</tr>
<tr>
<td>translateY(<em>n</em>)</td>
<td>定义 2D 转换，沿着 Y 轴移动元素。</td>
</tr>
<tr>
<td>scale(<em>x</em>,<em>y</em>)</td>
<td>定义 2D 缩放转换，改变元素的宽度和高度。</td>
</tr>
<tr>
<td>scaleX(<em>n</em>)</td>
<td>定义 2D 缩放转换，改变元素的宽度。</td>
</tr>
<tr>
<td>scaleY(<em>n</em>)</td>
<td>定义 2D 缩放转换，改变元素的高度。</td>
</tr>
<tr>
<td>rotate(<em>angle</em>)</td>
<td>定义 2D 旋转，在参数中规定角度。</td>
</tr>
<tr>
<td>skew(<em>x-angle</em>,<em>y-angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 X 和 Y 轴。</td>
</tr>
<tr>
<td>skewX(<em>angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 X 轴。</td>
</tr>
<tr>
<td>skewY(<em>angle</em>)</td>
<td>定义 2D 倾斜转换，沿着 Y 轴。</td>
</tr>
</tbody></table>
<p> <strong>3D转换属性</strong></p>
<p> 下表列出了所有的转换属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transform</td>
<td>向元素应用 2D 或 3D 转换。</td>
</tr>
<tr>
<td>transform-origin</td>
<td>允许你改变被转换元素的位置。</td>
</tr>
<tr>
<td>transform-style</td>
<td>规定被嵌套元素如何在 3D 空间中显示。</td>
</tr>
<tr>
<td>perspective</td>
<td>规定 3D 元素的透视效果。</td>
</tr>
<tr>
<td>perspective-origin</td>
<td>规定 3D 元素的底部位置。</td>
</tr>
<tr>
<td>backface-visibility</td>
<td>定义元素在不面对屏幕时是否可见。</td>
</tr>
</tbody></table>
<p> <strong>3D 转换方法</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>, <em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td>
</tr>
<tr>
<td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>定义 3D 转化。</td>
</tr>
<tr>
<td>translateX(<em>x</em>)</td>
<td>定义 3D 转化，仅使用用于 X 轴的值。</td>
</tr>
<tr>
<td>translateY(<em>y</em>)</td>
<td>定义 3D 转化，仅使用用于 Y 轴的值。</td>
</tr>
<tr>
<td>translateZ(<em>z</em>)</td>
<td>定义 3D 转化，仅使用用于 Z 轴的值。</td>
</tr>
<tr>
<td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>定义 3D 缩放转换。</td>
</tr>
<tr>
<td>scaleX(<em>x</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 X 轴的值。</td>
</tr>
<tr>
<td>scaleY(<em>y</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 Y 轴的值。</td>
</tr>
<tr>
<td>scaleZ(<em>z</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 Z 轴的值。</td>
</tr>
<tr>
<td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td>
<td>定义 3D 旋转。</td>
</tr>
<tr>
<td>rotateX(<em>angle</em>)</td>
<td>定义沿 X 轴的 3D 旋转。</td>
</tr>
<tr>
<td>rotateY(<em>angle</em>)</td>
<td>定义沿 Y 轴的 3D 旋转。</td>
</tr>
<tr>
<td>rotateZ(<em>angle</em>)</td>
<td>定义沿 Z 轴的 3D 旋转。</td>
</tr>
<tr>
<td>perspective(<em>n</em>)</td>
<td>定义 3D 转换元素的透视视图。</td>
</tr>
</tbody></table>
</li>
<li><p>反射</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片</span><br></pre></td></tr></table></figure></li>
<li><p>颜色</p>
<ul>
<li><p>rgba：rgb为颜色值，a为透明度</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">1</span>);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>,.<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>hsla：h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”。使用HSLA时，透明度不会影响其后代元素</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">hsla</span>( <span class="number">112</span>, <span class="number">72%</span>, <span class="number">33%</span>, <span class="number">0.68</span>);</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">hsla</span>( <span class="number">49</span>, <span class="number">65%</span>, <span class="number">60%</span>, <span class="number">0.68</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>滤镜</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>原图<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>黑白色filter: grayscale(100%)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter: grayscale(100%);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>褐色filter:sepia(1)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:sepia(1);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>饱和度saturate(2)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:saturate(2);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>色相旋转hue-rotate(90deg)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:hue-rotate(90deg);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>反色filter:invert(1)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:invert(1);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>透明度opacity(.5)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:opacity(.5);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>亮度brightness(.5)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:brightness(.5);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>对比度contrast(2)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:contrast(2);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>模糊blur(3px)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:blur(3px);&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>阴影drop-shadow(5px 5px 5px #000)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;filter:drop-shadow(5px 5px 5px #000);&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>过渡</p>
<p> 下表列出了所有的过渡属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition.html">transition</a></td>
<td>简写属性，用于在一个属性中设置四个过渡属性。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-property.html">transition-property</a></td>
<td>规定应用过渡的 CSS 属性的名称。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-duration.html">transition-duration</a></td>
<td>定义过渡效果花费的时间。默认是 0。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-timing-function.html">transition-timing-function</a></td>
<td>规定过渡效果的时间曲线。默认是 “ease”。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-transition-delay.html">transition-delay</a></td>
<td>规定过渡效果何时开始。默认是 0。</td>
</tr>
</tbody></table>
</li>
<li><p>动画</p>
<p> 下面的表格列出了 @keyframes 规则和所有动画属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-keyframes.html">@keyframes</a></td>
<td>规定动画。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation.html">animation</a></td>
<td>所有动画属性的简写属性，除了 animation-play-state 属性。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-name.html">animation-name</a></td>
<td>规定 @keyframes 动画的名称。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-duration.html">animation-duration</a></td>
<td>规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-timing-function.html">animation-timing-function</a></td>
<td>规定动画的速度曲线。默认是 “ease”。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-delay.html">animation-delay</a></td>
<td>规定动画何时开始。默认是 0。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-iteration-count.html">animation-iteration-count</a></td>
<td>规定动画被播放的次数。默认是 1。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-direction.html">animation-direction</a></td>
<td>规定动画是否在下一周期逆向地播放。默认是 “normal”。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-animation-play-state.html">animation-play-state</a></td>
<td>规定动画是否正在运行或暂停。默认是 “running”。</td>
</tr>
</tbody></table>
</li>
<li><p>多列布局</p>
<p> 下表列出了所有 CSS3 的多列属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-count.html">column-count</a></td>
<td>指定元素应该被分割的列数。</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-fill.html">column-fill</a></td>
<td>指定如何填充列</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-gap.html">column-gap</a></td>
<td>指定列与列之间的间隙</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule.html">column-rule</a></td>
<td>所有 column-rule-* 属性的简写</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule-color.html">column-rule-color</a></td>
<td>指定两列间边框的颜色</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule-style.html">column-rule-style</a></td>
<td>指定两列间边框的样式</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-rule-width.html">column-rule-width</a></td>
<td>指定两列间边框的厚度</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-span.html">column-span</a></td>
<td>指定元素要跨越多少列</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-column-width.html">column-width</a></td>
<td>指定列的宽度</td>
</tr>
<tr>
<td><a href="https://link.juejin.cn/?target=http://www.runoob.com/cssref/css3-pr-columns.html">columns</a></td>
<td>设置 column-width 和 column-count 的简写</td>
</tr>
</tbody></table>
</li>
<li><p> 弹性盒布局</p>
</li>
<li><p> 栅格布局</p>
</li>
<li><p>盒模型</p>
<p> 在 CSS3 中, 增加了一些新的用户界面特性来调整元素尺寸，框尺寸和外边框，主要包括以下用户界面属性：</p>
<ul>
<li>  resize：none | both | horizontal | vertical | inherit</li>
<li>  box-sizing: content-box | border-box | inherit</li>
<li>  outline:outline-color outline-style outline-width outine-offset</li>
<li>  overflow-x：横向溢出处理方式</li>
<li>  overflow-y：纵向溢出处理方式</li>
</ul>
<p> resize属性指定一个元素是否应该由用户去调整大小。</p>
<p> box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。</p>
<p> outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</p>
</li>
<li><p>媒体查询</p>
<p> 从 CSS 版本 2 开始，就可以通过媒体类型在 CSS 中获得媒体支持。如果您曾经使用过打印样式表，那么您可能已经使用过媒体类型。清单 1 展示了一个示例。</p>
<p> <strong>清单 1. 使用媒体类型</strong></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;site.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;print.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p> <strong>清单 2. 媒体查询规则</strong></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">800px</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  <code>@media all</code> 是媒体类型，也就是说，将此 CSS 应用于所有媒体类型。</p>
</li>
<li><p>  <code>(min-width:800px)</code> 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 CSS。</p>
</li>
</ul>
<p> <strong>清单 3.</strong> <code>and</code> <strong>条件</strong></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>:<span class="number">800px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">1200px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>:portrait) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>清单 4.</strong> <code>or</code> <strong>关键词</strong></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>:<span class="number">800px</span>) <span class="keyword">or</span> (<span class="attribute">orientation</span>:portrait) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>清单 5. 使用</strong> <code>not</code></p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="keyword">not</span> <span class="attribute">min-width</span>:<span class="number">800px</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其它</p>
<ul>
<li>  自定义属性和变量</li>
<li>  calc 函数</li>
<li>  <code>opacity </code> 属性</li>
</ul>
</li>
</ol>
<h3 id="15-替换元素的概念及计算规则"><a href="#15-替换元素的概念及计算规则" class="headerlink" title="15. 替换元素的概念及计算规则"></a>15. 替换元素的概念及计算规则</h3><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p>
<p>替换元素除了内容可替换这一特性以外，还有以下特性：</p>
<ul>
<li>  <strong>内容的外观不受页面上的CSS的影响</strong>：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li>
<li>  <strong>有自己的尺寸</strong>：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如</li>
<li>  <strong>在很多CSS属性上有自己的一套表现规则</strong>：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li>
<li>  <strong>所有的替换元素都是内联水平元素</strong>：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li>
</ul>
<p>替换元素的尺寸从内而外分为三类：</p>
<ul>
<li>  <strong>固有尺寸：</strong> 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li>
<li>  <strong>HTML尺寸：</strong> 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li>
<li>  <strong>CSS尺寸：</strong> 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</li>
</ul>
<p>这三层结构的计算规则具体如下： （1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。 （2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。 （3）如果有CSS尺寸，则最终尺寸由CSS属性决定。 （4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。 （5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。 （6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p>
<h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><ol>
<li> <strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</li>
<li> <strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</li>
<li> <strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</li>
<li> <strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</li>
<li> <strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</li>
<li> <strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</li>
<li><strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。<ul>
<li>  在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li>
<li>  在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li>
<li>  WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li>
</ul>
</li>
</ol>
<h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p>
<p><strong>优点：</strong></p>
<ul>
<li>  利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li>
<li>  <code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li>
<li>  <code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li>
<li>  维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li>
</ul>
<h3 id="18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？"><a href="#18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？" class="headerlink" title="18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？"></a>18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h3><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p>
<p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p>
<p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p>
<p>当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。</p>
<p>还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">my-image &#123; <span class="attr">background</span>: (low.png); &#125;</span><br><span class="line">@media only screen and (min-device-pixel-ratio: <span class="number">1.5</span>) &#123;</span><br><span class="line">  #my-image &#123; <span class="attr">background</span>: (high.png); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-margin-和-padding-的使用场景"><a href="#19-margin-和-padding-的使用场景" class="headerlink" title="19. margin 和 padding 的使用场景"></a>19. margin 和 padding 的使用场景</h3><ul>
<li>  需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li>
<li>  需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li>
</ul>
<h3 id="20-对line-height-的理解及其赋值方式"><a href="#20-对line-height-的理解及其赋值方式" class="headerlink" title="20. 对line-height 的理解及其赋值方式"></a>20. 对line-height 的理解及其赋值方式</h3><ol>
<li><strong>line-height的概念：</strong><ul>
<li>  line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；</li>
<li>  如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</li>
<li>  一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</li>
<li>  把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</li>
<li>  line-height 和 height 都能撑开一个高度；</li>
</ul>
</li>
<li><strong>line-height 的赋值方式：</strong><ul>
<li>  带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li>
<li>  纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li>
<li>  百分比：将计算后的值传递给后代</li>
</ul>
</li>
</ol>
<h3 id="21-CSS-优化和提高性能的方法有哪些？"><a href="#21-CSS-优化和提高性能的方法有哪些？" class="headerlink" title="21. CSS 优化和提高性能的方法有哪些？"></a>21. CSS 优化和提高性能的方法有哪些？</h3><ul>
<li><strong>加载性能：</strong><ol>
<li> css压缩：将写好的css进行打包压缩，可以减小文件体积。</li>
<li> css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。</li>
<li> 减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li>
</ol>
</li>
<li><strong>选择器性能：</strong><ol>
<li> 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li>
<li> 如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li>
<li> 避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</li>
<li> 尽量少的去对标签进行选择，而是用class。</li>
<li> 尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li>
<li> 了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li>
</ol>
</li>
<li><strong>渲染性能：</strong><ol>
<li> 慎重使用高性能属性：浮动、定位。</li>
<li> 尽量减少页面重排、重绘。</li>
<li> 去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li>
<li> 属性值为0时，不加单位。</li>
<li> 属性值为浮动小数0.**，可以省略小数点之前的0。</li>
<li> 标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li>
<li> 不使用@import前缀，它会影响css的加载速度。</li>
<li> 选择器优化嵌套，尽量避免层级过深。</li>
<li> css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li>
<li> 正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li>
<li> 不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</li>
</ol>
</li>
<li><strong>可维护性、健壮性：</strong><ol>
<li> 将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li>
<li> 样式与内容分离：将css代码定义到外部css中。</li>
</ol>
</li>
</ul>
<h3 id="22-CSS预处理器-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器/后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器/后处理器是什么？为什么要使用它们？</h3><p>参考：<a href="https://juejin.cn/post/7005755782926958605#heading-4%EF%BC%8Chttps://juejin.cn/post/7001860784586227720#heading-8">https://juejin.cn/post/7005755782926958605#heading-4，https://juejin.cn/post/7001860784586227720#heading-8</a></p>
<p><strong>预处理器，</strong> 如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p>
<p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p>
<p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p>
<p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p>
<p>使用原因：</p>
<ul>
<li>  结构清晰， 便于扩展</li>
<li>  可以很方便的屏蔽浏览器私有语法的差异</li>
<li>  可以轻松实现多重继承</li>
<li>  完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li>
</ul>
<h3 id="23-before-和-after-的双冒号和单冒号有什么区别？"><a href="#23-before-和-after-的双冒号和单冒号有什么区别？" class="headerlink" title="23. ::before 和 :after 的双冒号和单冒号有什么区别？"></a>23. ::before 和 :after 的双冒号和单冒号有什么区别？</h3><p>参考：<a href="https://juejin.cn/post/6992961262560739364#heading-7">https://juejin.cn/post/6992961262560739364#heading-7</a></p>
<ol>
<li> 冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素。 </li>
<li> <code>::before</code>就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在于页面之中。</li>
</ol>
<p><strong>注意：</strong> <code>:before </code>和 <code>:after</code> 这两个伪元素，是在<code>CSS2.1</code>里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着<code>Web</code>的进化，在<code>CSS3</code>的规范里，伪元素的语法被修改成使用双冒号，成为<code>::before</code>、<code>::after</code>。</p>
<h3 id="24-display-inline-block-什么时候会显示间隙？"><a href="#24-display-inline-block-什么时候会显示间隙？" class="headerlink" title="24. display:inline-block 什么时候会显示间隙？"></a>24. display:inline-block 什么时候会显示间隙？</h3><p>参考：<a href="https://juejin.cn/post/6979864063257870344">https://juejin.cn/post/6979864063257870344</a></p>
<ul>
<li>  元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据white-space的处理方式（默认是normal，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，空白符占据一定宽度，所以inline-block的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素font-size:16px时，间距为8px。</li>
<li>解决：<ol>
<li> 将html标签要display:inline-block 的元素写在一行。缺点：代码可读性差。</li>
<li> 给父元素设置font-size:0,给子元素设置需要的font-size值。缺点:是子元素如果里面有文字，文字会消失不见，所以又要给子元素设置font-size,增加了代码量。</li>
<li> 给元素设置float:left。缺点:高度塌陷，要清楚浮动。</li>
<li> 设置子元素的margin-left为负值，但是元素之间的间隙大小是根据上下文的字体大小确定的，而每个浏览器的换行空隙大小不同，所以这个方法不通用。</li>
<li> 设置父元素 display:table;word-spacing:-1em;目前这个方法可以完美解决，且兼容其他浏览器。</li>
</ol>
</li>
</ul>
<h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul>
<li><p> 单行文本溢出：</p>
   <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure></li>
<li><p>多行文本溢出：<a href="https://juejin.cn/post/6963904955262435336">https://juejin.cn/post/6963904955262435336</a></p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-line-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure>

<p>  注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p>
</li>
</ul>
<h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p>
<p><strong>为什么要使用它们？</strong></p>
<ul>
<li>  结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</li>
<li>  可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li>
</ul>
<h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p><a href="https://juejin.cn/post/6971013190524076069">https://juejin.cn/post/6971013190524076069</a></p>
<p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。</p>
<p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- link元素中的CSS媒体查询 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 800px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;example.css&quot;</span> /&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 样式表中的CSS媒体查询 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> </span></span><br><span class="line"><span class="css"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123; </span></span><br><span class="line"><span class="css">  <span class="selector-class">.facet_sidebar</span> &#123; </span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: none; </span></span><br><span class="line"><span class="css">  &#125; </span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p>
<h3 id="28-对-CSS-工程化的理解"><a href="#28-对-CSS-工程化的理解" class="headerlink" title="28. 对 CSS 工程化的理解"></a>28. 对 CSS 工程化的理解</h3><p>CSS 工程化是为了解决以下问题：</p>
<ol>
<li> <strong>宏观设计</strong>：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li>
<li> <strong>编码优化</strong>：怎样写出更好的 CSS？</li>
<li> <strong>构建</strong>：如何处理我的 CSS，才能让它的打包结果最优？</li>
<li> <strong>可维护性</strong>：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li>
</ol>
<p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p>
<ul>
<li>  预处理器：Less、 Sass 等；</li>
<li>  重要的工程化插件： PostCss；</li>
<li>  Webpack loader 等 。</li>
</ul>
<p>基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：</p>
<p><strong>（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？</strong></p>
<p>预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码： </p>
<p><img src="/2021/11/27/css/02-28-1.png"></p>
<p>那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：</p>
<ol>
<li> 宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；</li>
<li> 编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；</li>
<li> 可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。</li>
</ol>
<p>这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：</p>
<ul>
<li>  嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；</li>
<li>  支持定义 css 变量；</li>
<li>  提供计算函数；</li>
<li>  允许对代码片段进行 extend 和 mixin；</li>
<li>  支持循环语句的使用；</li>
<li>  支持将 CSS 文件模块化，实现复用。</li>
</ul>
<p><strong>（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</strong></p>
<p><img src="/2021/11/27/css/02-28-2.png" alt="img"> 它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。</p>
<p>PostCss 在业务中的使用场景非常多：</p>
<ul>
<li>  提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li>
<li>  当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 <a href="https://link.juejin.cn/?target=https://github.com/postcss/autoprefixer">Autoprefixer</a> 插件可以帮助我们自动增加浏览器前缀；</li>
<li>  允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li>
</ul>
<p><strong>（3）Webpack 能处理 CSS 吗？如何实现？</strong> Webpack 能处理 CSS 吗：</p>
<ul>
<li>  <strong>Webpack 在裸奔的状态下，是不能处理 CSS 的</strong>，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；</li>
<li>  Webpack 在 loader 的辅助下，是可以处理 CSS 的。</li>
</ul>
<p>如何用 Webpack 实现对 CSS 的处理：</p>
<ul>
<li>  Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</li>
<li>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：<ul>
<li>  css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；</li>
<li>  style-loader：创建style标签，把 CSS 内容写入标签。</li>
</ul>
</li>
</ul>
<p>在实际使用中，<strong>css-loader 的执行顺序一定要安排在 style-loader 的前面</strong>。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</p>
<h3 id="29-如何判断元素是否到达可视区域"><a href="#29-如何判断元素是否到达可视区域" class="headerlink" title="29. 如何判断元素是否到达可视区域"></a>29. 如何判断元素是否到达可视区域</h3><p>以图片显示为例：</p>
<ul>
<li>  <code>window.innerHeight</code> 是浏览器可视区的高度；</li>
<li>  <code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离；</li>
<li>  <code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）；</li>
<li>  内容达到显示区域的：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></li>
</ul>
<p><img src="/2021/11/27/css/02-29.png"></p>
<h3 id="30-z-index属性在什么情况下会失效"><a href="#30-z-index属性在什么情况下会失效" class="headerlink" title="30. z-index属性在什么情况下会失效"></a>30. z-index属性在什么情况下会失效</h3><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p>
<p>z-index属性在下列情况下会失效：</p>
<ul>
<li>  父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li>
<li>  元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li>
<li>  元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li>
</ul>
<h3 id="31-CSS3中的transform有哪些属性"><a href="#31-CSS3中的transform有哪些属性" class="headerlink" title="31. CSS3中的transform有哪些属性"></a>31. CSS3中的transform有哪些属性</h3><p>见14</p>
<h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><ul>
<li><p>绝对单位</p>
<ol>
<li> in（英寸）</li>
<li> cm（厘米）</li>
<li> mm（毫米）</li>
<li> pt（points）</li>
<li> pc（Picas）</li>
</ol>
<p>  1in = 2.54cm = 25.4 mm = 72pt = 6pc</p>
</li>
<li><p>相对单位</p>
<ol>
<li><p>像素（px），是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p>
<ul>
<li>  CSS像素：为web开发者提供，在CSS中使用的一个抽象单位；</li>
<li>  物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的。（绝对单位）</li>
</ul>
<p> px是相对单位，因为1px在不同设备上渲染的物理像素数量不一致，不同设备上一个物理像素的大小也不一致。为保证阅读体验一致，CSS的px 相对 物理像素 是动态的，px和物理像素之间的关系根据设备像素比（DPR）确定。</p>
</li>
<li><p> 百分比（%），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p>
</li>
<li><p>em和rem相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：em相对于父元素，rem相对于根元素。</p>
<ul>
<li>  em： 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li>
<li>  rem： rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。当根元素未设置font-size值时，默认取16px。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li>
</ul>
</li>
<li><p>vw/vh是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p>
<ul>
<li>  vw：相对于视窗的宽度，视窗宽度是100vw；</li>
<li>  vh：相对于视窗的高度，视窗高度是100vh；</li>
<li>  vmin：vw和vh中的较小值；</li>
<li>  vmax：vw和vh中的较大值；</li>
</ul>
</li>
<li><p> ex：表示元素内字符x的高度，一个小写字母，比如“d”，它会有一部分高出来，ex不包括高出来的这一部分的。</p>
</li>
<li><p> ch：表示元素内数字0的宽度</p>
</li>
</ol>
</li>
</ul>
<p>注意：</p>
<ul>
<li>  影响em变化的因素只有font-size，而影响 ex、ch 变化的因素除font-size外还有font-family，因为font-family的改变也会使得x或者0字符的大小发生变化。</li>
<li>vw/vh 和百分比很类似，两者的区别：<ul>
<li>  百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li>
<li>  vw/vm：相对于视窗的尺寸</li>
</ul>
</li>
</ul>
<h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p>
<ul>
<li>  px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li>
<li>  em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li>
<li>  em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>  对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li>
<li>  对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li>
</ul>
<h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>基本样式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>123-边框图片<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: <span class="number">1px</span> dashed <span class="number">#ff6c60</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">    左边固定宽度，高度不固定 <span class="tag">&lt;/<span class="name">br</span>&gt;</span> <span class="tag">&lt;/<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span>高度有可能会很小，也可能很大。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">    这里的内容可能比左侧高，也可能比左侧低。宽度需要自适应。<span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    基本的样式是，两个div相距20px, 左侧div宽 120px</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>双<code>inline-block</code>方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-inline-block</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;	// 消除空格的影响</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-inline-block</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.wrapper-inline-block</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;	// 顶端对齐</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-inline-block</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">140px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这种方法是通过<code>width: calc(100% - 140px)</code>来动态计算右侧盒子的宽度。需要知道右侧盒子距离左边的距离，以及左侧盒子具体的宽度(content+padding+border)，以此计算父容器宽度的<code>100%</code>需要减去的数值。同时，还需要知道右侧盒子的宽度是否包含<code>border</code>的宽度。 在这里，为了简单的计算右侧盒子准确的宽度，设置了子元素的<code>box-sizing:border-box;</code>以及父元素的<code>box-sizing: content-box;</code>。 同时，作为两个<code>inline-block</code>的盒子，必须设置<code>vertical-align</code>来使其顶端对齐。 另外，为了<strong>准确地应用</strong>计算出来的宽度，需要消除<code>div</code>之间的空格，需要通过设置父容器的<code>font-size: 0;</code>,或者用注释消除<code>html</code>中的空格等方法。 <strong>缺点:</strong></p>
<ul>
<li>  需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的<code>box-sizing</code></li>
<li>  需要消除空格字符的影响</li>
<li>  需要设置<code>vertical-align: top</code>满足顶端对齐。</li>
</ul>
</li>
<li><p>双<code>float</code>方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-double-float</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;		// 清除浮动</span><br><span class="line">    <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-double-float</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.wrapper-double-float</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-double-float</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">140px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 本方案和双<code>float</code>方案原理相同，都是通过动态计算宽度来实现自适应。但是，由于浮动的<code>block</code>元素在有空间的情况下会<a href="https://www.w3.org/TR/CSS21/visuren.html#bfc-next-to-float">依次紧贴，排列在一行</a>，所以无需设置<code>display: inline-block;</code>，自然也就少了顶端对齐，空格字符占空间等问题。</p>
<p> 不过由于应用了浮动，父元素需要清除浮动。 <strong>缺点:</strong></p>
<ul>
<li>  需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的<code>box-sizing</code>。</li>
<li>  父元素需要清除浮动。</li>
</ul>
</li>
<li><p><code>float+margin-left</code>方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-float</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;   // 清除浮动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面两种方案都是利用了CSS的<code>calc()</code>函数来计算宽度值。下面两种方案则是利用了<code>block</code>级别的元素盒子的宽度具有<strong>填满父容器，并随着父容器的宽度自适应</strong>的<strong>流动特性</strong>。 但是<code>block</code>级别的元素都是独占一行的，所以要想办法让两个<code>block</code>排列到一起。 我们知道，<code>block</code>级别的元素会认为浮动的元素不存在，但是<code>inline</code>级别的元素能识别到浮动的元素。这样，<code>block</code>级别的元素就可以和浮动的元素同处一行了。 为了让右侧盒子和左侧盒子保持距离，需要为左侧盒子留出足够的距离。这个距离的大小为左侧盒子的宽度以及两个盒子之间的距离之和。然后将该值设置为右侧盒子的<code>margin-left</code>。 <strong>缺点：</strong></p>
<ul>
<li>  需要清除浮动</li>
<li>  需要计算右侧盒子的<code>margin-left</code></li>
</ul>
</li>
<li><p>使用absolute+margin-left方法</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-absolute</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-absolute</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>缺点:</strong></p>
<ul>
<li>  使用了绝对定位，若是用在某个div中，需要更改父容器的<code>position</code>。</li>
<li>  没有清除浮动的方法，若左侧盒子高于右侧盒子，就会超出父容器的高度。因此只能通过设置父容器的<code>min-height</code>来放置这种情况。</li>
</ul>
</li>
<li><p>使用float+BFC方法</p>
<p> 上面的方法都需要通过左侧盒子的宽度，计算某个值，下面三种方法都是不需要计算的。只需要设置两个盒子之间的间隔。</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-float-bfc</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float-bfc</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-float-bfc</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个方案同样是利用了左侧浮动，但是右侧盒子通过<code>overflow: auto;</code>形成了BFC，因此右侧盒子不会与浮动的元素重叠。</p>
<p> 这种情况下，只需要为左侧的浮动盒子设置<code>margin-right</code>，就可以实现两个盒子的距离了。而右侧盒子是<code>block</code>级别的，所以宽度能实现自适应。 <strong>缺点:</strong></p>
<ul>
<li>  父元素需要清除浮动</li>
</ul>
</li>
<li><p>flex方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-flex</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-flex</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-flex</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> flex可以说是最好的方案了，代码少，使用简单。有朝一日，大家都改用现代浏览器，就可以使用了。 需要注意的是，flex容器的一个默认属性值:align-items: stretch;。这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start;</p>
</li>
<li><p>grid方案</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper-grid</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">120px</span> <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    grid-column: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper-grid</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    grid-column: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意:</p>
<ul>
<li>  grid布局也有列等高的默认效果。需要设置: align-items: start;。</li>
<li>  grid布局还有一个值得注意的小地方和flex不同:在使用margin-left的时候，grid布局默认是box-sizing设置的盒宽度之间的位置。而flex则是使用两个div的border或者padding外侧之间的距离。</li>
</ul>
</li>
</ol>
<p><strong>极限情况</strong></p>
<p>最后可以再看一下在父容器极限小的情况下，不同方案的表现。主要分成四种情况：</p>
<ul>
<li><p>动态计算宽度的情况</p>
<p>  两种方案: 双inline-block方案和双float方案。宽度极限小时，右侧的div宽度会非常小，由于遵循流动布局，所以右侧div会移动到下一行。</p>
</li>
<li><p>动态计算右侧margin-left的情况</p>
<p>  两种方案: float+margin-left方案和absolute+margin-left方案。宽度极限小时，由于右侧的div忽略了文档流中左侧div的存在，所以其依旧会存在于这一行，并被隐藏。</p>
</li>
<li><p><code>float+BFC</code>方案的情况</p>
<p>  这种情况下，由于BFC与float的特殊关系，右侧div在宽度减小到最小后，也会掉落到下一行。</p>
</li>
<li><p><code>flex</code>和<code>grid</code>的情况</p>
<p>  这种情况下，默认两种布局方式都不会放不下的div移动到下一行。不过 flex布局可以通过 flex-flow: wrap;来设置多余的div移动到下一行。 grid布局暂不支持。</p>
</li>
</ul>
<p>参考：<a href="https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/">https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/</a></p>
<h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><ol>
<li><p>float 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.output</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">min-width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.side</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.side-left</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.side-right</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">          <span class="comment">/* width: calc(100%-600px); */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">600px</span>);</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- calc() 函数用于动态计算长度值。</span></span><br><span class="line"><span class="comment">需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)； --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;output&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;side side-left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;div class=&quot; mid&quot;&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;side side-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>position 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.output</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="comment">/* left: 300px;</span></span></span><br><span class="line"><span class="comment"><span class="css">          width: calc(100% - 600px); */</span></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">          <span class="comment">/* 兼容性最好的写法： */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">right</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;output&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>table 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>:orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>:lightblue;</span></span><br><span class="line"><span class="css">          <span class="comment">/* 继承父类的剩余部分 */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>flex 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orchid;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="comment">/* flex: 1; */</span></span></span><br><span class="line"><span class="css">          <span class="attribute">flex</span>: auto;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>grid 布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="css">          grid-template-rows: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          grid-template-<span class="attribute">columns</span>:<span class="number">300px</span> auto <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="comment">/* grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 */</span></span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.mid</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: lightgoldenrodyellow;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner mid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>圣杯布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>144-圣杯布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      *&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="css">          <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">min-width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background</span>: purple;</span></span><br><span class="line"><span class="css">          <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1.什么是圣杯布局和双飞翼布局</span></span><br><span class="line"><span class="comment">两者实现的功能都一样, 都是用于实现两侧的宽度不变, 中间的宽度自适应的三栏布局的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.圣杯布局的步骤</span></span><br><span class="line"><span class="comment">2.1搞一个容器, 里面放三个盒子</span></span><br><span class="line"><span class="comment">2.2设置两侧盒子的宽度(固定)</span></span><br><span class="line"><span class="comment">2.3设置中间盒子的宽度等于容器的宽度(100%)</span></span><br><span class="line"><span class="comment">2.4设置容器的padding等于两侧盒子的宽度</span></span><br><span class="line"><span class="comment">2.5让三个盒子都在同一个方向上浮动</span></span><br><span class="line"><span class="comment">2.6设置左边盒子的margin-left=-100%</span></span><br><span class="line"><span class="comment">2.7通过定位调整左边的盒子, 让左边的盒子不要盖住中间的区域</span></span><br><span class="line"><span class="comment">2.8设置右边盒子的margin-left=-自身的宽度</span></span><br><span class="line"><span class="comment">2.9通过定位调整右边的盒子, 让右边的盒子不要盖住中间的区域</span></span><br><span class="line"><span class="comment">3.0给容器设置一个最小的宽度, 防止缩小后变形</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>双飞翼布局</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>145-双飞翼布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        *&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>, <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span>&gt;<span class="selector-class">.center-in</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: purple;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1.双飞翼布局的实现步骤</span></span><br><span class="line"><span class="comment">1.1搞一个容器, 里面放三个盒子</span></span><br><span class="line"><span class="comment">1.2设置两侧盒子的宽度(固定)</span></span><br><span class="line"><span class="comment">1.3设置中间盒子的宽度等于容器的宽度(100%)</span></span><br><span class="line"><span class="comment">1.4让三个盒子都在同一个方向上浮动</span></span><br><span class="line"><span class="comment">1.5给中间的盒子添加一个子盒子</span></span><br><span class="line"><span class="comment">1.6给子盒子设置margin 0 两侧盒子的宽度</span></span><br><span class="line"><span class="comment">   由于是给子盒子设置margin,所以不会对父盒子排版产生任何影响</span></span><br><span class="line"><span class="comment">1.7设置左边盒子的margin-left=-100%</span></span><br><span class="line"><span class="comment">1.8设置右边盒子的margin-left=-自身的宽度</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center-in&quot;</span>&gt;</span>中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容中间的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-水平垂直居中的实现"><a href="#5-水平垂直居中的实现" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul>
<li><p>水平居中</p>
<ul>
<li><p>行内元素</p>
<ol>
<li> 给父元素设置 text-align:center,即可实现行内元素水平居中</li>
</ol>
</li>
<li><p>块级元素</p>
<ol>
<li><p> 该元素设置 margin:0 auto即可</p>
</li>
<li><p>若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: -moz-fit-content;</span><br><span class="line">    <span class="attribute">width</span>: -webkit-fit-content;</span><br><span class="line">    <span class="attribute">width</span>:fit-content;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器</p>
</li>
<li><p>使用flex 2012年版本布局, 可以轻松的实现水平居中, 子元素设置如下</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用flex 2009年版本, 父元素display: box;box-pack: center;如下设置:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    -webkit-box-orient: horizontal;</span><br><span class="line">    -webkit-box-pack: center;</span><br><span class="line">    <span class="attribute">display</span>: -moz-box;</span><br><span class="line">    -moz-box-orient: horizontal;</span><br><span class="line">    -moz-box-pack: center;</span><br><span class="line">    <span class="attribute">display</span>: -o-box;</span><br><span class="line">      -o-box-orient: horizontal;</span><br><span class="line">      -o-box-pack: center;</span><br><span class="line">      <span class="attribute">display</span>: -ms-box;</span><br><span class="line">      -ms-box-orient: horizontal;</span><br><span class="line">      -ms-box-pack: center;</span><br><span class="line">      <span class="attribute">display</span>: box;</span><br><span class="line">      box-orient: horizontal;</span><br><span class="line">      box-pack: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用CSS3中新增的transform属性, 子元素设置如下:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">      <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用绝对定位方式, 以及负值的margin-left, 子元素设置如下:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">width</span>:固定;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">0.5</span>宽度;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">width</span>:固定;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>垂直居中</p>
<ul>
<li><p>单行文本</p>
<ol>
<li> 设置 line-height 等于父元素高度</li>
</ol>
</li>
<li><p>行内块级元素</p>
<ol>
<li><p>若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span>, <span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>元素高度不定</p>
<ol>
<li><p>可用 <strong>vertical-align</strong> 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的。 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle;</p>
<ul>
<li>  <strong>优点</strong>：元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断。</li>
<li>  <strong>缺点</strong>：IE6~7, 甚至IE8 beta中无效。</li>
</ul>
</li>
<li><p>可用 <strong>Flex 2012版</strong>, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《<a href="https://link.juejin.cn/?target=http://louiszhai.github.io/2017/01/13/flex/">弹性盒模型Flex指南</a>》</p>
<p> 父元素做如下设置即可保证子元素垂直居中:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>优点</strong></p>
<ul>
<li><p>  内容块的宽高任意, 优雅的溢出.</p>
</li>
<li><p>  可用于更复杂高级的布局技术中.</p>
</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li>  IE8/IE9不支持</li>
<li>  需要浏览器厂商前缀</li>
<li>  渲染上可能会有一些问题</li>
</ul>
</li>
</ul>
</li>
<li><p>使用flex 2009版.</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: box;</span><br><span class="line">      box-orient: vertical;</span><br><span class="line">      box-pack: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>优点</strong>：实现简单, 扩展性强</li>
<li>  <strong>缺点</strong>：兼容性差, 不支持IE</li>
</ul>
</li>
<li><p>可用 <strong>transform</strong> , 设置父元素相对定位(position:relative), 子元素如下css样式：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);  </span><br><span class="line">    -ms-<span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>优点</strong>：代码量少</li>
<li>  <strong>缺点</strong>：IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象</li>
</ul>
</li>
</ol>
</li>
<li><p>元素高度固定</p>
<ol>
<li><p>设置父元素相对定位(position:relative), 子元素如下css样式:</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>:固定;</span><br><span class="line">    <span class="attribute">margin-top</span>:-<span class="number">0.5</span>高度;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>优点</strong>：适用于所有浏览器.</li>
<li>  <strong>缺点</strong>：父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条</li>
</ul>
</li>
<li><p>  设置父元素相对定位(position:relative), 子元素如下css样式:</p>
</li>
</ol>
<pre><code>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">height</span>:固定;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>:auto <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  -   **优点**：简单
  -   **缺点**：没有足够空间时, 子元素会被截断, 但不会有滚动条.
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p>
<ul>
<li>  <strong>适配不同像素密度，</strong> 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li>
<li>  <strong>适配不同屏幕大小，</strong> 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li>
</ul>
<p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p>
<p><a href="https://www.cnblogs.com/zhangnan35/p/12682925.html">https://www.cnblogs.com/zhangnan35/p/12682925.html</a></p>
<h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p>
<p>以下6个属性设置在<strong>容器上</strong>：</p>
<ul>
<li>  flex-direction属性决定主轴的方向（即项目的排列方向）。</li>
<li>  flex-wrap属性定义，如果一条轴线排不下，如何换行。</li>
<li>  flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li>
<li>  justify-content属性定义了项目在主轴上的对齐方式。</li>
<li>  align-items属性定义项目在交叉轴上如何对齐。</li>
<li>  align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>
</ul>
<p>以下6个属性设置在<strong>项目上</strong>：</p>
<ul>
<li>  order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>
<li>  flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>
<li>  flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>  flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li>
<li>  flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li>
<li>  align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
<p><strong>简单来说：</strong> flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p>
<h3 id="8-响应式设计的概念及基本原理"><a href="#8-响应式设计的概念及基本原理" class="headerlink" title="8. 响应式设计的概念及基本原理"></a>8. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p>
<p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。 关于兼容： 页面头部必须有meta声明的<code>viewport</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;’viewport’&quot;</span> <span class="attr">content</span>=<span class="string">&quot;”width=device-width,&quot;</span> <span class="attr">initial-scale</span>=<span class="string">&quot;1.&quot;</span> <span class="attr">maximum-scale</span>=<span class="string">&quot;1,user-scalable=no”&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p>
<p><strong>浮动的工作原理：</strong></p>
<ul>
<li>  浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li>
<li>  浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li>
</ul>
<p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p>
<p><strong>浮动元素引起的问题？</strong></p>
<ul>
<li>  父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>  与浮动元素同级的非浮动元素会跟随其后</li>
<li>  若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li>
</ul>
<p><strong>清除浮动的方式如下：</strong><a href="https://juejin.cn/post/6992534186347216909#heading-3">https://juejin.cn/post/6992534186347216909#heading-3</a></p>
<ul>
<li>  给父级div定义<code>height</code>属性</li>
<li>  最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li>
<li>  包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li>
<li>  使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout，从而使元素获得清除浮动的特性。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">    content: <span class="string">&quot;\200B&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用-clear-属性清除浮动的原理？"><a href="#2-使用-clear-属性清除浮动的原理？" class="headerlink" title="2. 使用 clear 属性清除浮动的原理？"></a>2. 使用 clear 属性清除浮动的原理？</h3><p>使用clear属性清除浮动，其语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">clear</span>:none|left|right|both</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p>
<p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p>
<p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p>
<p>一般使用伪元素的方式清除浮动：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;  </span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;  </span><br><span class="line">    <span class="attribute">display</span>: block;   </span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p>
<h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p>
<ul>
<li>  Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。</li>
<li>  Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li>
</ul>
<p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p>
<p><strong>创建BFC的条件：</strong></p>
<ul>
<li>  根元素：body；</li>
<li>  元素设置浮动：float 除 none 以外的值；</li>
<li>  元素设置绝对定位：position (absolute、fixed)；</li>
<li>  display 值为：inline-block、table-cell、table-caption、flex等；</li>
<li>  overflow 值为：hidden、auto、scroll；</li>
</ul>
<p><strong>BFC的特点：</strong></p>
<ul>
<li>  垂直方向上，自上而下排列，和文档流的排列方式一致。</li>
<li>  在BFC中上下相邻的两个容器的margin会重叠</li>
<li>  计算BFC的高度时，需要计算浮动元素的高度</li>
<li>  BFC区域不会与浮动的容器发生重叠</li>
<li>  BFC是独立的容器，容器内部元素不会影响外部元素</li>
<li>  每个元素的左margin值和容器的左border相接触</li>
</ul>
<p><strong>BFC的作用：</strong></p>
<ul>
<li>  <strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li>
<li>  <strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li>
<li>  <strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p>
<h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong> 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p>
<p><strong>计算原则：</strong> 折叠合并后外边距的计算原则如下：</p>
<ul>
<li>  如果两者都是正数，那么就去最大者</li>
<li>  如果是一正一负，就会正值减去负值的绝对值</li>
<li>  两个都是负值时，用0减去两个中绝对值大的那个</li>
</ul>
<p><strong>解决办法：</strong> 对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong> </p>
<ol>
<li>兄弟之间重叠<ul>
<li>  底部元素变为行内盒子：<code>display: inline-block</code></li>
<li>  底部元素设置浮动：<code>float</code></li>
<li>  底部元素的position的值为<code>absolute/fixed</code></li>
</ul>
</li>
<li>父子之间重叠<ul>
<li>  父元素加入：<code>overflow: hidden</code></li>
<li>  父元素添加透明边框：<code>border:1px solid transparent</code></li>
<li>  子元素变为行内盒子：<code>display: inline-block</code></li>
<li>  子元素加入浮动属性或定位</li>
</ul>
</li>
</ol>
<h3 id="5-元素的层叠顺序"><a href="#5-元素的层叠顺序" class="headerlink" title="5. 元素的层叠顺序"></a>5. 元素的层叠顺序</h3><p>参考：<a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/</a></p>
<p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p>
<p><img src="/2021/11/27/css/02-3-5.png" alt="02-3-5"></p>
<p>上图，由上到下分别是： </p>
<ol>
<li> 背景和边框：建立当前层叠上下文元素的背景和边框。 </li>
<li> 负的z-index：当前层叠上下文中，z-index属性值为负的元素。 </li>
<li> 块级盒：文档流内非行内级非定位后代元素。</li>
<li> 浮动盒：非定位浮动元素。 </li>
<li> 行内盒：文档流内行内级非定位后代元素。 </li>
<li> z-index:0：层叠级数为0的定位元素。 </li>
<li> 正z-index：z-index属性值为正的定位元素。</li>
</ol>
<p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p>
<h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><table>
<thead>
<tr>
<th>属性值</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>absolute</td>
<td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td>
</tr>
<tr>
<td>fixed</td>
<td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td>
</tr>
<tr>
<td>static</td>
<td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定从父元素继承position属性的值</td>
</tr>
<tr>
<td>sticky</td>
<td>元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。<br />该值总是创建一个新的<a href="https://developer.mozilla.org/en/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context">层叠上下文（stacking context</a>）。注意，一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的<code>overflow</code> 是 <code>hidden</code>, <code>scroll</code>, <code>auto</code>, 或 <code>overlay</code>时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为</td>
</tr>
</tbody></table>
<p>前面三者的定位方式如下：</p>
<ul>
<li><p>  <strong>relative：</strong> 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</p>
</li>
<li><p>  <strong>fixed：</strong> 元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</p>
</li>
<li><p>  <strong>absolute：</strong> 元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。</p>
</li>
</ul>
<h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. display、float、position的关系</h3><ol>
<li> 首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</li>
<li> 然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</li>
<li> 如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</li>
<li> 如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</li>
</ol>
<p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p>
<h3 id="8-absolute与fixed共同点与不同点"><a href="#8-absolute与fixed共同点与不同点" class="headerlink" title="8. absolute与fixed共同点与不同点"></a>8. absolute与fixed共同点与不同点</h3><p><strong>共同点：</strong></p>
<ul>
<li>  改变行内元素的呈现方式，将display置为inline-block </li>
<li>  使元素脱离普通文档流，不再占据文档物理空间</li>
<li>  覆盖非定位文档元素</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>  abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</li>
<li>  在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</li>
</ul>
<h3 id="9-对-sticky-定位的理解"><a href="#9-对-sticky-定位的理解" class="headerlink" title="9. 对 sticky 定位的理解"></a>9. 对 sticky 定位的理解</h3><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：<strong>position: sticky;</strong> 基于用户的滚动位置来定位。</p>
<p>粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>
<p><strong>参考</strong>：<a href="https://juejin.cn/post/6844903973627887624#comment">https://juejin.cn/post/6844903973627887624#comment</a></p>
<p><strong>基本概念</strong></p>
<ul>
<li><p>流盒</p>
<p>  指的是粘性定位元素最近的<code>可滚动元素</code>（overflow属性值不是visible的元素）的尺寸盒子，如果没有可滚动元素，则表示浏览器视窗盒子。</p>
</li>
<li><p>粘性约束矩形</p>
<p>  即粘性布局元素的父级元素矩形</p>
</li>
</ul>
<p><strong>特性</strong></p>
<ul>
<li>  当粘性约束矩形在可视范围内为<code>relative</code>，反之，则为<code>fixed</code></li>
<li>  粘性定位元素如果和它的父元素一样高，则垂直滚动的时候，粘性定位效果是不会出现的</li>
<li>  它的定位效果完全受限于父级元素们。如果父元素的<code>overflow</code>属性设置了<code>scroll</code>，<code>auto</code>,<code>overlay</code>值，那么，粘性定位将会失效</li>
<li>  同一容器中多个粘贴定位元素独立偏移，因此可能重叠；位置上下靠在一起的不同容器中的粘贴定位元素则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li>
</ul>
<h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><ol>
<li><p>border：平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是由三角形组成的，将其它边的边框设置成透明即可</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid green;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>clip-path剪裁</p>
<p> <code>clip-path</code>属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</p>
<p> <code>clip-path</code>的语法有四种：</p>
<ul>
<li>  inset（定义矩形）</li>
<li>  circle（定义圆）</li>
<li>  ellipse（定义椭圆）</li>
<li>  polygon（定义多边形）</li>
</ul>
<p> polygon的值为多个坐标点组成，坐标第一个值是x方向，第二个值是y方向。左上角是原点，右下角是(100%,100%)的点</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: cyan;</span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">100%</span>, <span class="number">50%</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">100%</span>);    // 对应三角形三个顶点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    heigt: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-top-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现一个宽高自适应的正方形"><a href="#3-实现一个宽高自适应的正方形" class="headerlink" title="3. 实现一个宽高自适应的正方形"></a>3. 实现一个宽高自适应的正方形</h3><ol>
<li><p>利用vw来实现：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用元素的margin/padding百分比是相对父元素width的性质来实现：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用子元素的margin-top的值来实现：</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-画一条0-5px的线"><a href="#4-画一条0-5px的线" class="headerlink" title="4. 画一条0.5px的线"></a>4. 画一条0.5px的线</h3><ul>
<li><p>  <strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：<code>transform: scale(0.5,0.5);</code></p>
</li>
<li><p>  <strong>采用meta viewport的方式</strong>，<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;/&gt;</code>，这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p>
</li>
</ul>
<h3 id="5-设置小于12px的字体"><a href="#5-设置小于12px的字体" class="headerlink" title="5. 设置小于12px的字体"></a>5. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>  使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li>
<li>  使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</li>
<li>  使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li>
</ul>
<h3 id="6-如何解决-1px-问题？"><a href="#6-如何解决-1px-问题？" class="headerlink" title="6. 如何解决 1px 问题？"></a>6. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">window.devicePixelRatio = 设备的物理像素 / CSS像素。</span><br></pre></td></tr></table></figure>

<p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2。 这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 </p>
<p><strong>解决1px 问题的三种思路：</strong></p>
<p><strong>思路一</strong>：直接写 0.5px</p>
<p>如果之前 1px 的样式这样写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span></span><br></pre></td></tr></table></figure>

<p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="built_in">window</span>.devicePixelRatio&#125;&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">0.5px</span> solid <span class="number">#333</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p>
<p><strong>思路二</strong>：伪元素先放大后缩小</p>
<p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p>
<p>思路是<strong>先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。</strong></p>
<p>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">      <span class="attribute">position</span>:absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">      <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">      <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思路三</strong>：viewport 缩放来解决</p>
<p>这个思路就是对 meta 标签里几个关键属性下手：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span></span><br><span class="line">metaEl.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">`width=device-width,user-scalable=no,initial-scale=<span class="subst">$&#123;scale&#125;</span>,maximum-scale=<span class="subst">$&#123;scale&#125;</span>,minimum-scale=<span class="subst">$&#123;scale&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>
<h3 id="7-纯CSS实现圆角三角形"><a href="#7-纯CSS实现圆角三角形" class="headerlink" title="7. 纯CSS实现圆角三角形"></a>7. 纯CSS实现圆角三角形</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.rounded-triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">30%</span>;    // 圆角弧度</span><br><span class="line">    <span class="attribute">background</span>: cyan;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">60</span>edg) <span class="built_in">skewX</span>(-<span class="number">30</span>edg) <span class="built_in">scale</span>(<span class="number">1</span>, .<span class="number">866</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.rounded-triangle</span>:before,</span><br><span class="line">    .rounded-triangle:after &#123;</span><br><span class="line">      content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">background-color</span>: inherit;</span><br><span class="line">      <span class="attribute">width</span>:  <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">border-top-right-radius</span>: <span class="number">30%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.rounded-triangle</span>:before &#123;</span><br><span class="line">      transform: <span class="built_in">rotate</span>(-<span class="number">135deg</span>) <span class="built_in">skewX</span>(-<span class="number">45deg</span>) <span class="built_in">scale</span>(<span class="number">1.414</span>, .<span class="number">707</span>) <span class="built_in">translate</span>(<span class="number">0</span>,-<span class="number">50%</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.rounded-triangle</span>:after &#123;</span><br><span class="line">      transform: <span class="built_in">rotate</span>(<span class="number">135deg</span>) <span class="built_in">skewY</span>(-<span class="number">45deg</span>) <span class="built_in">scale</span>(.<span class="number">707</span>, <span class="number">1.414</span>) <span class="built_in">translate</span>(<span class="number">50%</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h3>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue面试题</title>
    <url>/2021/12/17/vue/</url>
    <content><![CDATA[<p>绝大部分内容来自：<a href="https://juejin.cn/user/3544481220801815">https://juejin.cn/user/3544481220801815</a></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2021/12/17/vue/04.Vue%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<h2 id="一、Vue-基础"><a href="#一、Vue-基础" class="headerlink" title="一、Vue 基础"></a>一、Vue 基础</h2><h3 id="1-Vue的基本原理"><a href="#1-Vue的基本原理" class="headerlink" title="1. Vue的基本原理"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p>
<p><img src="/2021/12/17/vue/04-1-1.png"></p>
<h3 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2. 双向数据绑定的原理"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p>
<ol>
<li> 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>
<li> compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li> Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>
<li> MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>
<li> 如果是数组需要单独处理，重写所有能修改数组的方法，并覆盖掉数组原型上的对应方法。</li>
<li> 注意：defineProperty 只能监测到 getter/setter 操作，对于对象的增加删除属性操作监听不到（可以用 vm.$set$，vm.$delete$ 解决），对于数组直接用下标获取元素的方式（可以用 vm.$set$ 和 splice），和直接修改数组的 length 也无法监听（可以用 splice ）</li>
</ol>
<p><img src="/2021/12/17/vue/04-1-2.png"></p>
<h3 id="3-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>defineProperty 只能监测到 getter/setter 操作，对于对象的增加删除属性操作监听不到（可以用 vm.$set$，vm.$delete$ 解决），对于数组直接用下标获取元素的方式（可以用 vm.$set$ 和 splice），和直接修改数组的 length 也无法监听（可以用 splice ）。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p>
<p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法，而且无法用 polyfill 实现。</p>
<h3 id="4-MVVM、MVC、MVP的区别"><a href="#4-MVVM、MVC、MVP的区别" class="headerlink" title="4. MVVM、MVC、MVP的区别"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p>
<p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p>
<ol>
<li><p>MVC</p>
<p> MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p>
<p> <img src="/2021/12/17/vue/04-1-4-1.png"></p>
</li>
<li><p>MVVM</p>
<p> MVVM 分为 Model、View、ViewModel：</p>
<ul>
<li>  Model代表数据模型，数据和业务逻辑都在Model层中定义；</li>
<li>  View代表UI视图，负责数据的展示；</li>
<li>  ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li>
</ul>
<p> Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p>
<p> 这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。</p>
<p> <img src="/2021/12/17/vue/04-1-4-2.png"></p>
</li>
<li><p>MVP</p>
<p> MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p>
<p> <img src="/2021/12/17/vue/04-1-4-3.png"></p>
</li>
</ol>
<h3 id="5-Computed-和-Watch-的区别"><a href="#5-Computed-和-Watch-的区别" class="headerlink" title="5. Computed 和 Watch 的区别"></a>5. Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p>
<ul>
<li>  它支持缓存，只有依赖的数据发生了变化，才会重新计算,<strong>计算属性是基于它们的响应式依赖进行缓存的</strong></li>
<li>  不支持异步，当Computed中有异步操作时，无法监听数据的变化</li>
<li>  computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li>
<li>  如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li>
<li>  如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li>
</ul>
<p><strong>对于Watch：</strong></p>
<ul>
<li>  它不支持缓存，数据变化时，它就会触发相应的操作</li>
<li>  支持异步监听</li>
<li>  监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li>
<li>  当一个属性发生变化时，就需要执行相应的操作</li>
<li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<ul>
<li>  immediate：组件加载立即触发回调函数</li>
<li>  deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li>
</ul>
</li>
</ul>
<p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p>
<p><strong>总结：</strong></p>
<ul>
<li>  computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li>
<li>  watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li>
</ul>
<p><strong>运用场景：</strong></p>
<ul>
<li>  当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li>
<li>  当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h3 id="6-Computed-和-Methods-的区别"><a href="#6-Computed-和-Methods-的区别" class="headerlink" title="6. Computed 和 Methods 的区别"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的</p>
<p><strong>不同点：</strong></p>
<ul>
<li>  computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li>
<li>  method 调用总会执行该函数。</li>
</ul>
<h3 id="7-slot是什么？有什么作用？原理是什么？"><a href="#7-slot是什么？有什么作用？原理是什么？" class="headerlink" title="7. slot是什么？有什么作用？原理是什么？"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p>
<ul>
<li>  默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li>
<li>  具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽，默认是 default</li>
<li>  作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li>
</ul>
<p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p>
<h3 id="8-过滤器的作用，如何实现一个过滤器"><a href="#8-过滤器的作用，如何实现一个过滤器" class="headerlink" title="8. 过滤器的作用，如何实现一个过滤器"></a>8. 过滤器的作用，如何实现一个过滤器</h3><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>  需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</li>
<li>  比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用<code>fliters</code>过滤器来处理数据。</li>
</ul>
<p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在**插值表达式 **<code>&#123;&#123; &#125;&#125;</code> 和 <code>v-bind</code> <strong>表达式</strong> 中，然后放在操作符“ <code>|</code> ”后面进行指示。</p>
<p>例如，在显示金额，给商品价格添加单位：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;商品价格：&#123;&#123;item.price | filterPrice&#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line"> filters: &#123;</span><br><span class="line">    filterPrice (price) &#123;</span><br><span class="line">      <span class="keyword">return</span> price ? (<span class="string">&#x27;￥&#x27;</span> + price) : <span class="string">&#x27;--&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-如何保存页面的当前的状态"><a href="#9-如何保存页面的当前的状态" class="headerlink" title="9. 如何保存页面的当前的状态"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p>
<ul>
<li>  前组件会被卸载</li>
<li>  前组件不会被卸载</li>
</ul>
<p>那么可以按照这两种情况分别得到以下方法：</p>
<ul>
<li><p><strong>组件会被卸载：</strong></p>
<ol>
<li><p><strong>将状态存储在LocalStorage / SessionStorage</strong></p>
<p> 只需要在组件即将被销毁的生命周期 <code>componentWillUnmount</code> （react）中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p>
<p> 比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p>
<p> <strong>优点：</strong></p>
<ul>
<li>  兼容性好，不需要额外库或工具。</li>
<li>  简单快捷，基本可以满足大部分需求。</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li>  状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li>
<li>  如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li>
</ul>
</li>
<li><p><strong>路由传值</strong></p>
<p> 通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p>
<p> 在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p>
<p> <strong>优点：</strong></p>
<ul>
<li>  简单快捷，不会污染 LocalStorage / SessionStorage。</li>
<li>  可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li>  如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>组件不会被卸载：</strong></p>
<ol>
<li><p><strong>单页面渲染</strong></p>
<p> 要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p>
<p> <strong>优点：</strong></p>
<ul>
<li>  代码量少</li>
<li>  不需要考虑状态传递过程中的错误</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li>  增加 A 组件维护成本</li>
<li>  需要传入额外的 prop 到 B 组件</li>
<li>  无法利用路由定位页面</li>
</ul>
<p> 除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/kepp-alive&gt;</span><br></pre></td></tr></table></figure>

<p> <strong>router.js</strong></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../src/views/xxx.vue&#x27;</span>),</span><br><span class="line">  <span class="attr">meta</span>:&#123;</span><br><span class="line">    <span class="attr">keepAlive</span>: <span class="literal">true</span> <span class="comment">// 需要被缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10. 常见的事件修饰符及其作用"></a>10. 常见的事件修饰符及其作用</h3><ul>
<li>  <code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li>
<li>  <code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li>
<li>  <code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li>
<li>  <code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li>
<li>  <code>.once</code> ：只会触发一次。</li>
</ul>
<h3 id="11-v-if、v-show、v-html-的原理"><a href="#11-v-if、v-show、v-html-的原理" class="headerlink" title="11. v-if、v-show、v-html 的原理"></a>11. v-if、v-show、v-html 的原理</h3><ul>
<li>  v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li>
<li>  v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li>
<li>  v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li>
</ul>
<h3 id="12-v-if-和-v-show-的区别"><a href="#12-v-if-和-v-show-的区别" class="headerlink" title="12. v-if 和 v-show 的区别"></a>12. v-if 和 v-show 的区别</h3><ul>
<li>  <strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li>
<li>  <strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li>
<li>  <strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li>
<li>  <strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>
<li>  <strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li>
</ul>
<h3 id="13-v-model-是如何实现的，语法糖实际是什么？"><a href="#13-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="13. v-model 是如何实现的，语法糖实际是什么？"></a>13. v-model 是如何实现的，语法糖实际是什么？</h3><ol>
<li><p><strong>作用在表单元素上</strong> 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-on:input</span>=<span class="string">&quot;message=$event.target.value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">&gt;</span></span></span><br><span class="line"><span class="xml">//$event 指代当前触发的事件对象;</span></span><br><span class="line"><span class="xml">//$event.target 指代当前触发的事件对象的dom;</span></span><br><span class="line"><span class="xml">//$event.target.value 就是当前dom的value值;</span></span><br><span class="line"><span class="xml">//在@input方法中，value =&gt; sth;</span></span><br><span class="line"><span class="xml">//在:value中,sth =&gt; value;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>作用在组件上</strong> 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p>
<p> <strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong> 因此父组件 v-model 语法糖本质上可以修改为：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;child :value=<span class="string">&quot;message&quot;</span>  @input=<span class="string">&quot;function(e)&#123;message = e&#125;&quot;</span>&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>

<p> 在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;aa-input v-model=<span class="string">&quot;aa&quot;</span>&gt;&lt;/aa-input&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">aa-input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;aa=$event.target.value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;onmessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">props:&#123;<span class="attr">value</span>:aa,&#125;</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">onmessage</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        $emit(<span class="string">&#x27;input&#x27;</span>,e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input <code>$emit</code>过来的值。</p>
</li>
</ol>
<h3 id="14-v-model-可以被用在自定义组件上吗？如果可以，如何使用？"><a href="#14-v-model-可以被用在自定义组件上吗？如果可以，如何使用？" class="headerlink" title="14. v-model 可以被用在自定义组件上吗？如果可以，如何使用？"></a>14. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3><p>可以。v-model 实际上是一个语法糖，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;searchText&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>实际上相当于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-bind:value=<span class="string">&quot;searchText&quot;</span></span><br><span class="line">  v-on:input=<span class="string">&quot;searchText = $event.target.value&quot;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>用在自定义组件上也是同理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;custom-input v-model=<span class="string">&quot;searchText&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=<span class="string">&quot;searchText&quot;</span></span><br><span class="line">  v-on:input=<span class="string">&quot;searchText = $event&quot;</span></span><br><span class="line">&gt;&lt;/custom-input&gt;</span><br></pre></td></tr></table></figure>

<p>显然，custom-input 与父组件的交互如下：</p>
<ol>
<li> 父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；</li>
<li> custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；</li>
</ol>
<p>所以，custom-input 组件的实现应该类似于这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;custom-input&#x27;</span>, &#123;  <span class="attr">props</span>: [<span class="string">&#x27;value&#x27;</span>],  <span class="attr">template</span>: <span class="string">`    &lt;input      v-bind:value=&quot;value&quot;      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;    &gt;  `</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="15-data-为什么是一个函数而不是对象"><a href="#15-data-为什么是一个函数而不是对象" class="headerlink" title="15. data 为什么是一个函数而不是对象"></a>15. data 为什么是一个函数而不是对象</h3><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p>
<p>而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p>
<p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p>
<h3 id="16-对-keep-alive-的理解，它是如何实现的，具体缓存的是什么？"><a href="#16-对-keep-alive-的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="16. 对 keep-alive 的理解，它是如何实现的，具体缓存的是什么？"></a>16. 对 keep-alive 的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p>
<ol>
<li><p><strong>keep-alive</strong></p>
<p> keep-alive有以下三个属性：</p>
<ul>
<li>  include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li>
<li>  exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li>
<li>  max 数字，最多可以缓存多少组件实例。</li>
</ul>
<p> 注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p>
<p> <strong>主要流程</strong></p>
<ol>
<li> 判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li>
<li> 获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li>
<li> key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li>
<li> 如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li>
</ol>
</li>
<li><p><strong>keep-alive 的实现</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patternTypes: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt; = [<span class="built_in">String</span>, <span class="built_in">RegExp</span>, <span class="built_in">Array</span>] <span class="comment">// 接收：字符串，正则，数组export default &#123;  name: &#x27;keep-alive&#x27;,  abstract: true, // 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。  props: &#123;    include: patternTypes, // 匹配的组件，缓存    exclude: patternTypes, // 不去匹配的组件，不缓存    max: [String, Number], // 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限  &#125;,  created() &#123;    // 用于初始化缓存虚拟DOM数组和vnode的key    this.cache = Object.create(null)    this.keys = []  &#125;,  destroyed() &#123;    // 销毁缓存cache的组件实例    for (const key in this.cache) &#123;      pruneCacheEntry(this.cache, key, this.keys)    &#125;  &#125;,  mounted() &#123;    // prune 削减精简[v.]    // 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容    this.$watch(&#x27;include&#x27;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; matches(val, name))    &#125;)    this.$watch(&#x27;exclude&#x27;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; !matches(val, name))    &#125;)  &#125;,&#125;</span></span><br></pre></td></tr></table></figure>

<p> <strong>render函数：</strong></p>
<ol>
<li> 会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li>
<li> keep-alive 只对第一个组件有效，所以获取第一个子组件。</li>
<li> 和 keep-alive 搭配使用的一般有：动态组件 和router-view</li>
</ol>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render () &#123;  <span class="comment">//  function getFirstComponentChild (children: ?Array&lt;VNode&gt;): ?VNode &#123;    if (Array.isArray(children)) &#123;  for (let i = 0; i &lt; children.length; i++) &#123;    const c = children[i]    if (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) &#123;      return c    &#125;  &#125;  &#125;  &#125;  const slot = this.$slots.default // 获取默认插槽  const vnode: VNode = getFirstComponentChild(slot)// 获取第一个子组件  const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions // 组件参数  if (componentOptions) &#123; // 是否有组件参数    // check pattern    const name: ?string = getComponentName(componentOptions) // 获取组件名    const &#123; include, exclude &#125; = this    if (      // not included      (include &amp;&amp; (!name || !matches(include, name))) ||      // excluded      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))    ) &#123;      // 如果不匹配当前组件的名字和include以及exclude      // 那么直接返回组件的实例      return vnode    &#125;    const &#123; cache, keys &#125; = this    // 获取这个组件的key    const key: ?string = vnode.key == null      // same constructor may get registered as different local components      // so cid alone is not enough (#3269)      ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;)      : vnode.key    if (cache[key]) &#123;      // LRU缓存策略执行      vnode.componentInstance = cache[key].componentInstance // 组件初次渲染的时候componentInstance为undefined      // make current key freshest      remove(keys, key)      keys.push(key)      // 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面    &#125; else &#123;      // 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除      // 使用时间间隔最长的一个      cache[key] = vnode      keys.push(key)      // prune oldest entry      if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;        pruneCacheEntry(cache, keys[0], keys, this._vnode)      &#125;    &#125;    // 将组件的keepAlive属性设置为true    vnode.data.keepAlive = true // 作用：判断是否要执行组件的created、mounted生命周期函数  &#125;  return vnode || (slot &amp;&amp; slot[0])&#125;</span></span><br></pre></td></tr></table></figure>

<p> keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p>
<p> <strong>实现步骤：</strong></p>
<ol>
<li> 获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li>
<li> 通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li>
<li>需要缓存，判断他当前是否在缓存数组里面：<ul>
<li>  存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li>
<li>  不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li>
</ul>
</li>
<li> 最后将这个组件的 keepAlive 设置为 true</li>
</ol>
</li>
<li><p><strong>keep-alive 本身的创建过程和 patch 过程</strong></p>
<p> 缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p>
<p> <strong>首次渲染</strong></p>
<ul>
<li>  组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/instance/lifecyclefunction initLifecycle (vm: Component) &#123;  const options = vm.$options  // locate first non-abstract parent  let parent = options.parent  if (parent &amp;&amp; !options.abstract) &#123; // 判断组件的abstract属性，才往父组件里面挂载DOM    while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;      parent = parent.$parent    &#125;    parent.$children.push(vm)  &#125;  vm.$parent = parent  vm.$root = parent ? parent.$root : vm  vm.$children = []  vm.$refs = &#123;&#125;  vm._watcher = null  vm._inactive = null  vm._directInactive = false  vm._isMounted = false  vm._isDestroyed = false  vm._isBeingDestroyed = false&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/vdom/create-componentinit (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123;    if (      vnode.componentInstance &amp;&amp;      !vnode.componentInstance._isDestroyed &amp;&amp;      vnode.data.keepAlive    ) &#123; // componentInstance在初次是undefined!!!      // kept-alive components, treat as a patch      const mountedNode: any = vnode // work around flow      componentVNodeHooks.prepatch(mountedNode, mountedNode) // prepatch函数执行的是组件更新的过程    &#125; else &#123;      const child = vnode.componentInstance = createComponentInstanceForVnode(        vnode,        activeInstance      )      child.$mount(hydrating ? vnode.elm : undefined, hydrating)    &#125;  &#125;,</span></span><br></pre></td></tr></table></figure>

<p> prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p>
</li>
<li><p><strong>LRU （least recently used）缓存策略</strong></p>
<p> LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 **”如果数据最近被访问过，那么将来被访问的几率也更高”**。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶</p>
<ul>
<li>  新数据插入到链表头部</li>
<li>  每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>
<li>  链表满的时候，将链表尾部的数据丢弃。</li>
</ul>
</li>
</ol>
<h3 id="17-nextTick-原理及作用"><a href="#17-nextTick-原理及作用" class="headerlink" title="17. $nextTick 原理及作用"></a>17. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p>
<p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p>
<p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p>
<p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p>
<ul>
<li>  如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</li>
<li>  同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li>
</ul>
<p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p>
<p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;    <span class="comment">// 获取数据的操作...&#125;)</span></span><br></pre></td></tr></table></figure>

<p>所以，在以下情况下，会用到nextTick：</p>
<ul>
<li>  在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li>
<li>  在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li>
</ul>
<p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p>
<h3 id="18-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#18-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="18. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a>18. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in obj&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;value&quot;</span>&gt;</span> &#123;&#123;value&#125;&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addObjB&quot;</span>&gt;</span>添加 obj.b<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">       data () &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">return</span> &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">obj</span>: &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">                  <span class="attr">a</span>: <span class="string">&#x27;obj.a&#x27;</span> </span></span></span><br><span class="line"><span class="javascript"><span class="xml">              &#125; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">       &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       <span class="attr">methods</span>: &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">          addObjB () &#123; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="built_in">this</span>.obj.b = <span class="string">&#x27;obj.b&#x27;</span> </span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.obj) </span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125; </span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addObjB () (</span><br><span class="line">   <span class="built_in">this</span>.$set(<span class="built_in">this</span>.obj, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;obj.b&#x27;</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p>
<h3 id="19-Vue-中封装的数组方法有哪些，其如何实现页面更新"><a href="#19-Vue-中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="19. Vue 中封装的数组方法有哪些，其如何实现页面更新"></a>19. Vue 中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。 </p>
<p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>
<ul>
<li>  push()</li>
<li>  pop()</li>
<li>  shift()</li>
<li>  unshift()</li>
<li>  splice()</li>
<li>  sort()</li>
<li>  reverse() </li>
</ul>
<p>那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存数组原型const arrayProto = Array.prototype;// 实现 arrayMethods.__proto__ === Array.prototypeexport const arrayMethods = Object.create(arrayProto);// 需要进行功能拓展的方法const methodsToPatch = [  &quot;push&quot;,  &quot;pop&quot;,  &quot;shift&quot;,  &quot;unshift&quot;,  &quot;splice&quot;,  &quot;sort&quot;,  &quot;reverse&quot;];/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function(method) &#123;  // 缓存原生数组方法  const original = arrayProto[method];  def(arrayMethods, method, function mutator(...args) &#123;    // 执行并缓存原生数组功能    const result = original.apply(this, args);    // 响应式处理    const ob = this.__ob__;    let inserted;    switch (method) &#123;    // push、unshift会新增索引，所以要手动observer      case &quot;push&quot;:      case &quot;unshift&quot;:        inserted = args;        break;      // splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。      case &quot;splice&quot;:        inserted = args.slice(2);        break;    &#125;    //     if (inserted) ob.observeArray(inserted);// 获取插入的值，并设置响应式监听    // notify change    ob.dep.notify();// 通知依赖更新    // 返回原生数组方法的执行结果    return result;  &#125;);&#125;);</span></span><br></pre></td></tr></table></figure>

<p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p>
<h3 id="20-Vue-单页应用与多页应用的区别"><a href="#20-Vue-单页应用与多页应用的区别" class="headerlink" title="20. Vue 单页应用与多页应用的区别"></a>20. Vue 单页应用与多页应用的区别</h3><p><strong>概念：</strong></p>
<ul>
<li>  SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li>
<li>  MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li>
</ul>
<p><strong>区别：</strong></p>
<table>
<thead>
<tr>
<th>对比项/模式</th>
<th>SPA</th>
<th>MPA</th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>一个主页面 + 许多模块的组件</td>
<td>许多完整的页面</td>
</tr>
<tr>
<td>体验</td>
<td>页面切换是，体验佳；当初次加载文件过多时，需要做相关的调优</td>
<td>页面切换慢，网速慢的时候，体验尤其不好</td>
</tr>
<tr>
<td>资源文件</td>
<td>组件公用的资源只需要加载一次</td>
<td>每个页面都要自己加载公用的的资源</td>
</tr>
<tr>
<td>适用场景</td>
<td>对体验度和流畅度有较高要求的应用，不利于 SEO，（可借助 SSR 优化 SEO）</td>
<td>适用于对 SEO 要求较高的应用</td>
</tr>
<tr>
<td>过渡动画</td>
<td>Vue 提供了 transition 的封装组件，容易实现</td>
<td>很难实现</td>
</tr>
<tr>
<td>内容更新</td>
<td>相关组件的切换，即局部更新</td>
<td>整体 HTML 的切换，费钱（重复的 http 请求）</td>
</tr>
<tr>
<td>路由模式</td>
<td>可以使用 hash ，也可以使用 history</td>
<td>普通链接跳转</td>
</tr>
<tr>
<td>数据传递</td>
<td>因为单页面，使用全局变量就好（Vuex）</td>
<td>cookie，localStorage 等缓存方案，URL 参数，调用接口保存的等</td>
</tr>
<tr>
<td>相关成本</td>
<td>前期开发成本较高，后期维护较为容易</td>
<td>前期开发成本低，后期维护就比较麻烦，因为可能一个功能需要该很多地方</td>
</tr>
</tbody></table>
<h3 id="21-Vue-template-到-render-的过程"><a href="#21-Vue-template-到-render-的过程" class="headerlink" title="21. Vue template 到 render 的过程"></a>21. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p>
<p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将模板编译为render函数const &#123; render, staticRenderFns &#125; = compileToFunctions(template,options//省略&#125;, this)</span></span><br></pre></td></tr></table></figure>

<p>CompileToFunctions中的主要逻辑如下∶</p>
<ol>
<li><p><strong>调用parse方法将template转化为ast（抽象语法树）</strong></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">constast = parse(template.trim(), options)</span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li>
<li>  <strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li>
</ul>
<p>  AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p>
</li>
<li><p><strong>对静态节点做优化</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimize(ast,options)</span><br></pre></td></tr></table></figure>

<p> 这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p>
<p> 深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p>
</li>
<li><p><strong>生成代码</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> code = generate(ast, options)</span><br></pre></td></tr></table></figure>

<p> generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(render)</code> 生成render函数。</p>
</li>
</ol>
<h3 id="22-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#22-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="22. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>22. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p>
<h3 id="23-简述-mixin、extends-的覆盖逻辑"><a href="#23-简述-mixin、extends-的覆盖逻辑" class="headerlink" title="23. 简述 mixin、extends 的覆盖逻辑"></a>23. 简述 mixin、extends 的覆盖逻辑</h3><ol>
<li><p><strong>mixin 和 extends</strong> mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p>
<ul>
<li>  mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li>
<li>  extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li>
</ul>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>合并策略</th>
<th>对应合并函数</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>mixins/extends 只会将自己有的但是组件上没有的内容混合到组件上，重复定义默认使用组件上的<br />如果 data 里的值是对象，将递归内部对象继续按照该策略合并</td>
<td>mergeDataOrFn，mergeData</td>
</tr>
<tr>
<td>provide</td>
<td>同上</td>
<td>mergeDataOrFn，mergeData</td>
</tr>
<tr>
<td>props</td>
<td>mixins/extends 只会将自己有的但是组件上没有的内容混合到组件上</td>
<td>extend</td>
</tr>
<tr>
<td>methods</td>
<td>同上</td>
<td>extend</td>
</tr>
<tr>
<td>inject</td>
<td>同上</td>
<td>extend</td>
</tr>
<tr>
<td>computed</td>
<td>同上</td>
<td>extend</td>
</tr>
<tr>
<td>组件，过滤求，指令属性</td>
<td>同上</td>
<td>extend</td>
</tr>
<tr>
<td>el</td>
<td>同上</td>
<td>defaultStrat</td>
</tr>
<tr>
<td>propsData</td>
<td>同上</td>
<td>defaultStrat</td>
</tr>
<tr>
<td>watch</td>
<td>合并 watch 监控的回调方法<br />执行顺序是先 mixins/extends 里 watch 定义的回调，然后是组件的回调</td>
<td>strats.watch</td>
</tr>
<tr>
<td>hooks 生命周期钩子</td>
<td>同一种钩子的回调函数会被合并成数组<br />执行顺序是先 mixins/extends 里定义的钩子函数，然后蚕食组件里定义的</td>
<td>mergeHook</td>
</tr>
</tbody></table>
</li>
<li><p><strong>mergeOptions 的执行过程</strong></p>
<ul>
<li><p>  规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</p>
</li>
<li><p>对未合并的选项，进行判断</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!child._base) &#123;  <span class="keyword">if</span> (child.extends) &#123;    parent = mergeOptions(parent, child.extends, vm)  &#125;  <span class="keyword">if</span> (child.mixins) &#123;    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;      parent = mergeOptions(parent, child.mixins[i], vm)    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>  合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</p>
</li>
<li><p>  返回合并结果 options。</p>
</li>
</ul>
</li>
</ol>
<h3 id="24-描述下Vue自定义指令"><a href="#24-描述下Vue自定义指令" class="headerlink" title="24. 描述下Vue自定义指令"></a>24. 描述下Vue自定义指令</h3><p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;</p>
<ol>
<li><p><strong>自定义指令基本内容</strong></p>
<ul>
<li><p>  全局定义：<code>Vue.directive(&quot;focus&quot;,&#123;&#125;)</code></p>
</li>
<li><p>  局部定义：<code>directives:&#123;focus:&#123;&#125;&#125;</code></p>
</li>
<li><p>钩子函数：指令定义对象提供钩子函数</p>
<p>  o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
<p>  o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p>
<p>  o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</p>
<p>  o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</p>
<p>  o unbind：只调用一次，指令与元素解绑时调用。</p>
</li>
<li><p>钩子函数参数 o el：绑定元素</p>
<p>  o bing： 指令核心对象，描述指令全部信息属性</p>
<p>  o name</p>
<p>  o value</p>
<p>  o oldValue</p>
<p>  o expression</p>
<p>  o arg</p>
<p>  o modifers</p>
<p>  o vnode  虚拟节点</p>
<p>  o oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p>
</li>
</ul>
</li>
<li><p><strong>使用场景</strong></p>
<ul>
<li>  普通DOM元素进行底层操作的时候，可以使用自定义指令</li>
<li>  自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li>
</ul>
</li>
<li><p><strong>使用案例</strong></p>
<ul>
<li>初级应用：<ul>
<li>  鼠标聚焦</li>
<li>  下拉菜单</li>
<li>  相对时间转换</li>
<li>  滚动动画</li>
</ul>
</li>
<li>高级应用：<ul>
<li>  自定义指令实现图片懒加载</li>
<li>  自定义指令集成第三方插件</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="25-子组件可以直接改变父组件的数据吗？"><a href="#25-子组件可以直接改变父组件的数据吗？" class="headerlink" title="25. 子组件可以直接改变父组件的数据吗？"></a>25. 子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p>
<p>只能通过 <code>$emit</code> 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<h3 id="26-Vue-是如何收集依赖的？"><a href="#26-Vue-是如何收集依赖的？" class="headerlink" title="26. Vue 是如何收集依赖的？"></a>26. Vue 是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defieneReactive</span> (<span class="params">obj, key, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(Dep.target)&#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。 </p>
<ol>
<li><p><strong>Dep</strong> Dep是整个依赖收集的核心，其关键代码如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;  <span class="keyword">static</span> target;  subs;  <span class="title">constructor</span> (<span class="params"></span>) &#123;    ...    <span class="built_in">this</span>.subs = [];  &#125;  addSub (sub) &#123;    <span class="built_in">this</span>.subs.push(sub)  &#125;  removeSub (sub) &#123;    remove(<span class="built_in">this</span>.sub, sub)  &#125;  depend () &#123;    <span class="keyword">if</span>(Dep.target)&#123;      Dep.target.addDep(<span class="built_in">this</span>)    &#125;  &#125;  notify () &#123;    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subds.slice();    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; subs.length; i++)&#123;      subs[i].update()    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p> Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p>
</li>
<li><p><strong>Watcher</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;  getter;  ...  <span class="title">constructor</span> (<span class="params">vm, expression</span>)&#123;    ...    <span class="built_in">this</span>.getter = expression;    <span class="built_in">this</span>.get();  &#125;  get () &#123;    pushTarget(<span class="built_in">this</span>);    value = <span class="built_in">this</span>.getter.call(vm, vm)    ...    <span class="keyword">return</span> value  &#125;  addDep (dep)&#123;        ...    dep.addSub(<span class="built_in">this</span>)  &#125;  ...&#125;<span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target</span>) </span>&#123;  Dep.target = _target&#125;</span><br></pre></td></tr></table></figure>

<p> Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p>
</li>
<li><p><strong>过程</strong></p>
<p> 在实例化 Vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;  vm._update(vm._render())&#125;<span class="keyword">new</span> Watcher(vm, updateComponent)</span><br></pre></td></tr></table></figure>

<p> get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p>
<p> this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p>
</li>
</ol>
<h3 id="27-对-React-和-Vue-的理解，它们的异同"><a href="#27-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="27. 对 React 和 Vue 的理解，它们的异同"></a>27. 对 React 和 Vue 的理解，它们的异同</h3><ul>
<li><p><strong>相似之处：</strong></p>
<ul>
<li>  都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li>
<li>  都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li>
<li>  都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li>
<li>  都有props的概念，允许组件间的数据传递；</li>
<li>  都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li>
</ul>
</li>
<li><p><strong>不同之处 ：</strong></p>
<ol>
<li><p><strong>数据流</strong></p>
<p> Vue默认支持数据双向绑定，而React一直提倡单向数据流</p>
</li>
<li><p><strong>虚拟DOM</strong></p>
<p> Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。</p>
<ul>
<li>  Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li>
<li>  对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li>
</ul>
</li>
<li><p><strong>组件化</strong></p>
<p> React与Vue最大的不同是模板的编写。</p>
<ul>
<li>  Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li>
<li>  React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li>
</ul>
<p> 具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。</p>
</li>
<li><p><strong>监听数据变化的实现原理不同</strong></p>
<ul>
<li>  Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li>
<li>  React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li>
</ul>
</li>
<li><p><strong>高阶组件</strong></p>
<p> react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p>
<p> 高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p>
</li>
<li><p><strong>构建工具</strong></p>
<p> 两者都有自己的构建工具：</p>
<ul>
<li>  React ==&gt; Create React APP</li>
<li>  Vue ==&gt; vue-cli</li>
</ul>
</li>
<li><p><strong>跨平台</strong></p>
<ul>
<li>  React ==&gt; React Native</li>
<li>  Vue ==&gt; Weex</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="28-Vue-的优点"><a href="#28-Vue-的优点" class="headerlink" title="28. Vue 的优点"></a>28. Vue 的优点</h3><ul>
<li>  轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li>
<li>  简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li>
<li>  双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li>
<li>  组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li>
<li>  视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li>
<li>  虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li>
<li>  运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li>
</ul>
<h3 id="29-assets-和-static-的区别"><a href="#29-assets-和-static-的区别" class="headerlink" title="29. assets 和 static 的区别"></a>29. assets 和 static 的区别</h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p>
<p><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p>
<p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p>
<h3 id="30-delete-和-Vue-delete-删除数组的区别"><a href="#30-delete-和-Vue-delete-删除数组的区别" class="headerlink" title="30. delete 和 Vue.delete 删除数组的区别"></a>30. delete 和 Vue.delete 删除数组的区别</h3><ul>
<li>  <code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li>
<li>  <code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li>
</ul>
<h3 id="31-Vue-如何监听对象或者数组某个属性的变化"><a href="#31-Vue-如何监听对象或者数组某个属性的变化" class="headerlink" title="31. Vue 如何监听对象或者数组某个属性的变化"></a>31. Vue 如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p>
<p>解决方式：</p>
<ul>
<li><p>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.arr, <span class="number">0</span>, <span class="string">&quot;OBKoro1&quot;</span>); <span class="comment">// 改变数组this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>调用以下几个数组的方法</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p>
<p>vm.<code>$set</code> 的实现原理是：</p>
<ul>
<li>  如果目标是数组，直接使用数组的 splice 方法触发响应式；</li>
<li>  如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>
</ul>
<h3 id="32-什么是-mixin-？"><a href="#32-什么是-mixin-？" class="headerlink" title="32. 什么是 mixin ？"></a>32. 什么是 mixin ？</h3><ul>
<li>  Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li>
<li>  如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li>
<li>  然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li>
</ul>
<h3 id="33-Vue-模版编译原理"><a href="#33-Vue-模版编译原理" class="headerlink" title="33. Vue 模版编译原理"></a>33. Vue 模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p>
<ul>
<li>  <strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li>
<li>  <strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li>
<li>  <strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li>
</ul>
<h3 id="34-对-SSR-的理解"><a href="#34-对-SSR-的理解" class="headerlink" title="34. 对 SSR 的理解"></a>34. 对 SSR 的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p>
<p>SSR的优势：</p>
<ul>
<li>  更好的SEO</li>
<li>  首屏加载速度更快</li>
</ul>
<p>SSR的缺点：</p>
<ul>
<li>  开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li>
<li>  当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li>
<li>  更多的服务端负载。</li>
</ul>
<h3 id="35-Vue-的性能优化有哪些"><a href="#35-Vue-的性能优化有哪些" class="headerlink" title="35. Vue 的性能优化有哪些"></a>35. Vue 的性能优化有哪些</h3><ol>
<li><strong>编码阶段</strong><ul>
<li>  尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li>
<li>  v-if和v-for不能连用</li>
<li>  如果需要使用v-for给每项元素绑定事件时使用事件代理</li>
<li>  SPA 页面采用keep-alive缓存组件</li>
<li>  在更多的情况下，使用v-if替代v-show</li>
<li>  key保证唯一</li>
<li>  使用路由懒加载、异步组件</li>
<li>  防抖、节流</li>
<li>  第三方模块按需导入</li>
<li>  长列表滚动到可视区域动态加载</li>
<li>  图片懒加载</li>
</ul>
</li>
<li><strong>SEO优化</strong><ul>
<li>  预渲染</li>
<li>  服务端渲染SSR</li>
</ul>
</li>
<li><strong>打包优化</strong><ul>
<li>  压缩代码</li>
<li>  Tree Shaking/Scope Hoisting</li>
<li>  使用cdn加载第三方模块</li>
<li>  多线程打包happypack</li>
<li>  splitChunks抽离公共文件</li>
<li>  sourceMap优化</li>
</ul>
</li>
<li><strong>用户体验</strong><ul>
<li>  骨架屏</li>
<li>  PWA</li>
<li>  还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li>
</ul>
</li>
</ol>
<h3 id="36-对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#36-对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="36. 对 SPA 单页面的理解，它的优缺点分别是什么？"></a>36. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<ul>
<li><strong>优点：</strong><ul>
<li>  用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>  基于上面一点，SPA 相对对服务器压力小；</li>
<li>  前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>  初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>  前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>  SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
</li>
</ul>
<h3 id="37-template-和-jsx-的有什么分别？"><a href="#37-template-和-jsx-的有什么分别？" class="headerlink" title="37. template 和 jsx 的有什么分别？"></a>37. template 和 jsx 的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p>
<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>
<h3 id="38-Vue-初始化页面闪动问题"><a href="#38-Vue-初始化页面闪动问题" class="headerlink" title="38. Vue 初始化页面闪动问题"></a>38. Vue 初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p>
<p>首先：在css里加上以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[v-cloak] &#123;    <span class="attr">display</span>: none;&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p>
<h3 id="39-extend-有什么作用"><a href="#39-extend-有什么作用" class="headerlink" title="39. extend 有什么作用"></a>39. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建组件构造器</span></span><br><span class="line"><span class="keyword">let</span> Component = Vue.extend(&#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;test&lt;/div&gt;&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// 挂载到 #app 上</span></span><br><span class="line"><span class="keyword">new</span> Component().$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// 除了上面的方式，还可以用来扩展已有的组件</span></span><br><span class="line"><span class="keyword">let</span> SuperComponent = Vue.extend(Component)</span><br><span class="line"><span class="keyword">new</span> SuperComponent(&#123;</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> SuperComponent().$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="40-mixin-和-mixins-区别"><a href="#40-mixin-和-mixins-区别" class="headerlink" title="40. mixin 和 mixins 区别"></a>40. mixin 和 mixins 区别</h3><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;        <span class="comment">// ...逻辑        // 这种方式会影响到每个组件的 beforeCreate 钩子函数    &#125;&#125;)</span></span><br></pre></td></tr></table></figure>

<p>虽然文档不建议在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p>
<p><code>mixins</code> 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。 另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</p>
<h3 id="41-MVVM-的优缺点"><a href="#41-MVVM-的优缺点" class="headerlink" title="41. MVVM 的优缺点?"></a>41. MVVM 的优缺点?</h3><ul>
<li>优点:<ul>
<li>  分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑</li>
<li>  提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</li>
<li>  ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</li>
</ul>
</li>
<li>缺点:<ul>
<li>  Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</li>
<li>  ⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存</li>
<li>  对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li>
</ul>
</li>
</ul>
<h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><h3 id="1-说一下-Vue-的生命周期（Vue2-x-Vue3-0）"><a href="#1-说一下-Vue-的生命周期（Vue2-x-Vue3-0）" class="headerlink" title="1. 说一下 Vue 的生命周期（Vue2.x Vue3.0）"></a>1. 说一下 Vue 的生命周期（Vue2.x Vue3.0）</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p>
<ol>
<li> <strong>beforeCreate（创建前）</strong>：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li>
<li> <strong>created（创建后）</strong> ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li>
<li> <strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li>
<li> <strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li>
<li> <strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li>
<li> <strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li> <strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li>
<li> <strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li>
</ol>
<p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p>
<h3 id="2-Vue-子组件和父组件执行顺序"><a href="#2-Vue-子组件和父组件执行顺序" class="headerlink" title="2. Vue 子组件和父组件执行顺序"></a>2. Vue 子组件和父组件执行顺序</h3><ul>
<li><strong>加载渲染过程：</strong><ol>
<li> 父组件 beforeCreate</li>
<li> 父组件 created</li>
<li> 父组件 beforeMount</li>
<li> 子组件 beforeCreate</li>
<li> 子组件 created</li>
<li> 子组件 beforeMount</li>
<li> 子组件 mounted</li>
<li> 父组件 mounted</li>
</ol>
</li>
<li><strong>更新过程：</strong><ol>
<li> 父组件 beforeUpdate</li>
<li> 子组件 beforeUpdate</li>
<li> 子组件 updated</li>
<li> 父组件 updated</li>
</ol>
</li>
<li><strong>销毁过程：</strong><ol>
<li> 父组件 beforeDestroy</li>
<li> 子组件 beforeDestroy</li>
<li> 子组件 destroyed</li>
<li> 父组件 destoryed</li>
</ol>
</li>
</ul>
<h3 id="3-created-和-mounted-的区别"><a href="#3-created-和-mounted-的区别" class="headerlink" title="3. created 和 mounted 的区别"></a>3. created 和 mounted 的区别</h3><ul>
<li>  created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li>
<li>  mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li>
</ul>
<h3 id="4-一般在哪个生命周期请求异步数据"><a href="#4-一般在哪个生命周期请求异步数据" class="headerlink" title="4. 一般在哪个生命周期请求异步数据"></a>4. 一般在哪个生命周期请求异步数据</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 </p>
<p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>  能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li>
<li>  SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li>
</ul>
<h3 id="5-keep-alive-中的生命周期哪些"><a href="#5-keep-alive-中的生命周期哪些" class="headerlink" title="5. keep-alive 中的生命周期哪些"></a>5. keep-alive 中的生命周期哪些</h3><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p>
<p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p>
<p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p>
<h2 id="三、组件通信"><a href="#三、组件通信" class="headerlink" title="三、组件通信"></a>三、组件通信</h2><h3 id="1-组件通信的方式"><a href="#1-组件通信的方式" class="headerlink" title="1. 组件通信的方式"></a>1. 组件通信的方式</h3><ol>
<li><p>props  /  $emit</p>
<p>  父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p>
<ol>
<li><p>父组件向子组件传值</p>
<ul>
<li>  <code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li>
<li>  <code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li>
<li>  <code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">son</span> <span class="attr">:msg</span>=<span class="string">&quot;msgData&quot;</span> <span class="attr">:fn</span>=<span class="string">&quot;myFunction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> son <span class="keyword">from</span> <span class="string">&quot;./son.vue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">name</span>: father,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">msgData</span>: <span class="string">&quot;父组件数据&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="title">myFunction</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">console</span>.log(<span class="string">&quot;vue&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        son</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件&lt;template&gt;    &lt;div id=&quot;son&quot;&gt;        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;        &lt;button @click=&quot;fn&quot;&gt;按钮&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &quot;son&quot;,    props: [&quot;msg&quot;, &quot;fn&quot;]&#125;;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>子组件向父组件传值</p>
<ul>
<li>  <code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;section&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">com-article</span> <span class="attr">:articles</span>=<span class="string">&quot;articleList&quot;</span> @<span class="attr">onEmitIndex</span>=<span class="string">&quot;onEmitIndex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">com-article</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;currentIndex&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> comArticle <span class="keyword">from</span> <span class="string">&#x27;./test/article.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&#x27;comArticle&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>: &#123; comArticle &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">currentIndex</span>: -<span class="number">1</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">articleList</span>: [<span class="string">&#x27;红楼梦&#x27;</span>, <span class="string">&#x27;西游记&#x27;</span>, <span class="string">&#x27;三国演义&#x27;</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">onEmitIndex</span>(<span class="params">idx</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.currentIndex = idx</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in articles&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;emitIndex(index)&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">props</span>: [<span class="string">&#x27;articles&#x27;</span>],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">emitIndex</span>(<span class="params">index</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;onEmitIndex&#x27;</span>, index) <span class="comment">// 触发父组件的方法，并传递参数index</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>eventBus事件总线（$emit / $on）</p>
<p> <code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下：</p>
<ol>
<li><p><strong>创建事件中心管理组件之间的通信</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event-bus.jsimport Vue from &#x27;vue&#x27;export const EventBus = new Vue()</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>发送事件</strong> 假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">first-com</span>&gt;</span><span class="tag">&lt;/<span class="name">first-com</span>&gt;</span>    <span class="tag">&lt;<span class="name">second-com</span>&gt;</span><span class="tag">&lt;/<span class="name">second-com</span>&gt;</span>  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;import firstCom from &#x27;./</span>firstCom.vue<span class="string">&#x27;import secondCom from &#x27;</span>./secondCom.vue<span class="string">&#x27;export default &#123;  components: &#123; firstCom, secondCom &#125;&#125;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在<code>firstCom</code>组件中发送事件：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>加法<span class="tag">&lt;/<span class="name">button</span>&gt;</span>      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;import &#123;EventBus&#125; from &#x27;./</span>event-bus.js<span class="string">&#x27; // 引入事件中心export default &#123;  data()&#123;    return&#123;      num:0    &#125;  &#125;,  methods:&#123;    add()&#123;      EventBus.$emit(&#x27;</span>addition<span class="string">&#x27;, &#123;        num:this.num++      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>接收事件</strong> 在<code>secondCom</code>组件中发送事件：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>求和: &#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;import &#123; EventBus &#125; from &#x27;./</span>event-bus.js<span class="string">&#x27;export default &#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;,  mounted() &#123;    EventBus.$on(&#x27;</span>addition<span class="string">&#x27;, param =&gt; &#123;      this.count = this.count + param.num;    &#125;)  &#125;&#125;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p>
<p> 虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p>
</li>
</ol>
</li>
<li><p>依赖注入（provide / inject）</p>
<p> 这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p>
<p> <code>provide / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。</p>
<ul>
<li>  <code>provide</code> 钩子用来发送数据或方法</li>
<li>  <code>inject</code>钩子用来接收数据或方法</li>
</ul>
<p> 在父组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> &#123;     </span><br><span class="line">        <span class="attr">num</span>: <span class="built_in">this</span>.num  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在子组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">inject: [<span class="string">&#x27;num&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p> 还可以这样写，这样写就可以访问父组件中的所有属性：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="built_in">this</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">num</span>: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">inject</span>: [<span class="string">&#x27;app&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.app.num)</span><br></pre></td></tr></table></figure>

<p> <strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p>
</li>
<li><p>ref / $refs</p>
<p> 这种方式也是实现<strong>父子组件</strong>之间的通信。</p>
<p> <code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p>
<p> 在子组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  data () &#123;    <span class="keyword">return</span> &#123;      <span class="attr">name</span>: <span class="string">&#x27;JavaScript&#x27;</span>    &#125;  &#125;,  <span class="attr">methods</span>: &#123;    sayHello () &#123;      <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p> 在父组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  <span class="xml"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;  import child from &#x27;./</span>child.vue<span class="string">&#x27;  export default &#123;    components: &#123; child &#125;,    mounted () &#123;      console.log(this.$refs.child.name);  // JavaScript      this.$refs.child.sayHello();  // hello    &#125;  &#125;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>$parent / $children</p>
<ul>
<li>  使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li>
<li>  使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li>
</ul>
<p> 在子组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>    <span class="tag">&lt;<span class="name">p</span>&gt;</span>获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &#x27;Vue&#x27;    &#125;  &#125;,  computed:&#123;    parentVal()&#123;      return this.$parent.msg;    &#125;  &#125;&#125;&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p> 在父组件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello_world&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>点击改变子组件值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;./child.vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>: &#123; child &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">msg</span>: <span class="string">&#x27;Welcome&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 获取到子组件</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.$children[<span class="number">0</span>].message = <span class="string">&#x27;JavaScript&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> 在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。 <strong>需要注意：</strong></p>
<ul>
<li>  通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li>
<li>  在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li>
<li>  在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li>
<li>  <code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li>
</ul>
</li>
<li><p>$attrs / $listeners</p>
<p> 考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p>
<p> 如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p>
<p> 针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p>
<p> 先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p>
<ul>
<li>  <code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li>
<li>  <code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li>
</ul>
<p> A组件（<code>APP.vue</code>）：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>        //此处监听了两个事件，可以在B组件或者C组件中直接触发         <span class="tag">&lt;<span class="name">child1</span> <span class="attr">:p-child1</span>=<span class="string">&quot;child1&quot;</span> <span class="attr">:p-child2</span>=<span class="string">&quot;child2&quot;</span> @<span class="attr">test1</span>=<span class="string">&quot;onTest1&quot;</span> @<span class="attr">test2</span>=<span class="string">&quot;onTest2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child1</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;<span class="regexp">/template&gt;&lt;script&gt;import Child1 from &#x27;./</span>Child1.vue<span class="string">&#x27;;export default &#123;    components: &#123; Child1 &#125;,    methods: &#123;        onTest1() &#123;            console.log(&#x27;</span>test1 running<span class="string">&#x27;);        &#125;,        onTest2() &#123;            console.log(&#x27;</span>test2 running<span class="string">&#x27;);        &#125;    &#125;&#125;;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> B组件（<code>Child1.vue</code>）：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>props: &#123;&#123;pChild1&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">child2</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> Child2 <span class="keyword">from</span> <span class="string">&#x27;./Child2.vue&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">props</span>: [<span class="string">&#x27;pChild1&#x27;</span>],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">components</span>: &#123; Child2 &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;test1&#x27;</span>); <span class="comment">// 触发APP.vue中的test1方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> C 组件 (<code>Child2.vue</code>)：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>props: &#123;&#123;pChild2&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>$attrs: &#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">props</span>: [<span class="string">&#x27;pChild2&#x27;</span>],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;test2&#x27;</span>);<span class="comment">// 触发APP.vue中的test2方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> 在上述代码中：</p>
<ul>
<li>  C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li>
<li>  在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li>
</ul>
</li>
<li><p>总结</p>
<ol>
<li><strong>父子组件间通信</strong><ul>
<li>  子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li>
<li>  通过 ref 属性给子组件设置一个名字。父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件，这样也可以实现通信。</li>
<li>  使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li>
</ul>
</li>
<li><strong>兄弟组件间通信</strong><ul>
<li>  使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li>
<li>  通过 <code>$parent/$refs</code> 来获取到兄弟组件，也可以进行通信。</li>
</ul>
</li>
<li><strong>任意组件之间</strong><ul>
<li>  使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li>
</ul>
</li>
</ol>
<p> 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>
</li>
</ol>
<h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h3 id="1-Vue-Router-的懒加载如何实现"><a href="#1-Vue-Router-的懒加载如何实现" class="headerlink" title="1. Vue-Router 的懒加载如何实现"></a>1. Vue-Router 的懒加载如何实现</h3><ul>
<li><p>非懒加载：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">&#x27;@/components/list.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: List &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>懒加载</p>
<ol>
<li><p>方案一(常用)：使用箭头函数+import动态加载</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/components/list.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: List &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>方案二：使用箭头函数+require动态加载</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/list&#x27;</span>], resolve)</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// r就是resolve</span></span><br><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], <span class="function">() =&gt;</span> r(<span class="built_in">require</span>(<span class="string">&#x27;@/components/list&#x27;</span>)), <span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: List,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="2-路由的-hash-和-history-模式的区别"><a href="#2-路由的-hash-和-history-模式的区别" class="headerlink" title="2. 路由的 hash 和 history 模式的区别"></a>2. 路由的 hash 和 history 模式的区别</h3><p>Vue-Router有两种模式：<strong>hash模式</strong>和<strong>history模式</strong>。默认的路由模式是hash模式。</p>
<ol>
<li><p>hash 模式</p>
<ul>
<li><p>  <strong>简介：</strong> hash模式是开发中默认的模式，它的URL带着一个#，例如：<a href="https://link.juejin.cn/?target=http://www.abc.com/%23/vue">www.abc.com/#/vue</a>，它的hash值就是<code>#/vue</code>。</p>
</li>
<li><p>  <strong>特点</strong>：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。</p>
</li>
<li><p><strong>原理：</strong> hash模式的主要原理就是<strong>onhashchange()事件</strong>：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(event.oldURL, event.newURL);</span><br><span class="line">	<span class="keyword">let</span> hash = location.hash.slice(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</p>
</li>
<li><p><strong>优缺点</strong></p>
<ul>
<li>  兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由</li>
<li>  只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误</li>
<li>  hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换</li>
<li>  会覆盖锚点定位元素的功能</li>
<li>  不太美观，#后面传输的数据复杂的话会出现问题</li>
</ul>
</li>
</ul>
</li>
<li><p>history 模式</p>
<ul>
<li><p>  <strong>简介：</strong> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。 </p>
</li>
<li><p>  <strong>特点：</strong> 当使用history模式时，URL就像这样：<a href="https://link.juejin.cn/?target=http://abc.com/user/id">abc.com/user/id</a>。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。</p>
</li>
<li><p>   <strong>API：</strong> history api可以分为两大部分，切换历史状态和修改历史状态：</p>
</li>
</ul>
<pre><code> -   **修改历史状态**：包括了 HTML5 History Interface 中新增的 `pushState()` 和 `replaceState()` 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。
 -   **切换历史状态：** 包括`forward()`、`back()`、`go()`三个方法，对应浏览器的前进，后退，跳转操作。

 虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。

 如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：

 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">routes</span>: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li><p><strong>优缺点</strong></p>
<ul>
<li>  使用简单，比较美观</li>
<li>  <code>pushState()</code>设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL</li>
<li>  <code>pushState()</code>设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中</li>
<li>  <code>pushState()</code>可以通过<code>stateObject</code>参数添加任意类型的数据到记录中，而hash只能添加短字符串</li>
<li>  <code>pushState()</code>可额外设置title属性供后续使用</li>
<li>  前端的URL必须和向发送请求后端URL保持一致，否则会报404错误</li>
<li>  由于History API的缘故，低版本浏览器有兼容性问题</li>
</ul>
</li>
</ul>
</li>
<li><p>两种模式对比</p>
<p> 调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p>
<ul>
<li>  pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li>
<li>  pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li>
<li>  pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li>
<li>  pushState() 可额外设置 title 属性供后续使用。</li>
<li>  hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对应的路由处理，将返回404错误。</li>
</ul>
<p> hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</p>
</li>
</ol>
<h3 id="3-如何获取页面的-hash-变化"><a href="#3-如何获取页面的-hash-变化" class="headerlink" title="3. 如何获取页面的 hash 变化"></a>3. 如何获取页面的 hash 变化</h3><ol>
<li><p><strong>监听$route的变化</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听,当路由发生变化的时候执行</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">$route</span>: &#123;</span><br><span class="line">    <span class="attr">handler</span>: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 深度观察监听</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p> <strong>window.location.hash读取#值</strong> window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。</p>
</li>
</ol>
<h3 id="4-route-和-router-的区别"><a href="#4-route-和-router-的区别" class="headerlink" title="4. route 和 router 的区别"></a>4. route 和 router 的区别</h3><ul>
<li>  $route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li>
<li>  $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等</li>
</ul>
<h3 id="5-如何定义动态路由？如何获取传过来的动态参数？"><a href="#5-如何定义动态路由？如何获取传过来的动态参数？" class="headerlink" title="5. 如何定义动态路由？如何获取传过来的动态参数？"></a>5. 如何定义动态路由？如何获取传过来的动态参数？</h3><ol>
<li><p>param 方式</p>
<ul>
<li>  配置路由格式：<code>/router/:id</code></li>
<li>  传递的方式：在path后面跟上对应的值</li>
<li>  传递后形成的路径：<code>/router/123</code></li>
</ul>
<ol>
<li><p>路由定义</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在APP.vue中</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#x27;/user/&#x27;+userId&quot;</span> replace&gt;用户&lt;/router-link&gt;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//在index.js</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/user/:userid&#x27;</span>,</span><br><span class="line">   <span class="attr">component</span>: User,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>路由跳转</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: wade &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>:<span class="string">&#x27;users&#x27;</span>,<span class="attr">params</span>:&#123;<span class="attr">uname</span>:wade&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/user/&#x27;</span> + wade)</span><br></pre></td></tr></table></figure></li>
<li><p> 参数获取 通过 <code>$route.params.userid</code> 获取传递的值</p>
</li>
</ol>
</li>
<li><p>query 方式</p>
<ul>
<li>  配置路由格式：<code>/router</code>，也就是普通配置</li>
<li>  传递的方式：对象中使用query的key作为传递方式</li>
<li>  传递后形成的路径：<code>/route?id=123</code></li>
</ul>
<ol>
<li><p>路由定义</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1：直接在router-link 标签上以对象的形式</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;why&#x27;,age:28,height:188&#125;&#125;&quot;</span>&gt;档案&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：写成按钮以点击事件形式</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;profileClick&#x27;</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">profileClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/profile&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;kobi&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&quot;28&quot;</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="number">198</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>跳转方法</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;users&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>:james &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; path: &#x27;/user&#x27;, query: &#123; uname:james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>:james &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法5：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/user?uname=&#x27;</span> + jsmes)</span><br></pre></td></tr></table></figure></li>
<li><p>获取参数</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">通过$route.query 获取传递的值</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="6-Vue-router-路由钩子在生命周期的体现"><a href="#6-Vue-router-路由钩子在生命周期的体现" class="headerlink" title="6. Vue-router 路由钩子在生命周期的体现"></a>6. Vue-router 路由钩子在生命周期的体现</h3><ol>
<li><p>Vue-Router 导航守卫</p>
<p> 有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p>
<ol>
<li><p>全局路由钩子</p>
<p> vue-router全局有三个路由钩子;</p>
<ul>
<li>  router.beforeEach 全局前置守卫 进入路由之前</li>
<li>  router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li>
<li>  router.afterEach 全局后置钩子 进入路由之后</li>
</ul>
<p> 具体使用∶</p>
<ul>
<li><p>beforeEach（判断是否登录了，没登录就跳转到登录页）</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">let</span> ifInfo = Vue.prototype.$common.getSession(<span class="string">&#x27;userData&#x27;</span>);  <span class="comment">// 判断是否登录的存储信息</span></span><br><span class="line">    <span class="keyword">if</span> (!ifInfo) &#123; </span><br><span class="line">        <span class="comment">// sessionStorage里没有储存user信息    </span></span><br><span class="line">        <span class="keyword">if</span> (to.path == <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//如果是登录页面路径，就直接next()      </span></span><br><span class="line">            next();    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">//不然就跳转到登录      </span></span><br><span class="line">            Message.warning(<span class="string">&quot;请重新登录！&quot;</span>);     </span><br><span class="line">            <span class="built_in">window</span>.location.href = Vue.prototype.$loginUrl;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> next();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>afterEach （跳转之后滚动条回到顶部）</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 跳转之后滚动条回到顶部  </span></span><br><span class="line">    <span class="built_in">window</span>.scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>单个路由独享钩子</p>
<p> <strong>beforeEnter</strong> 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,        </span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,        </span><br><span class="line">        <span class="attr">component</span>: login,        </span><br><span class="line">        <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;          </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;即将进入登录页面&#x27;</span>)          </span><br><span class="line">            next()        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>组件内钩子</p>
<p> beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave</p>
<p> 这三个钩子都有三个参数∶to、from、next</p>
<ul>
<li>  beforeRouteEnter∶ 进入组件前触发</li>
<li>  beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li>
<li>  beforeRouteLeave∶ 离开组件被调用</li>
</ul>
<p> 注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;      </span><br><span class="line">    next(<span class="function"><span class="params">target</span> =&gt;</span> &#123;        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">from</span>.path == <span class="string">&#x27;/classProcess&#x27;</span>) &#123;          </span><br><span class="line">            target.isFromProcess = <span class="literal">true</span>        </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Vue路由钩子在生命周期函数的体现</p>
<ol>
<li><p>完整的路由导航解析流程（不包括其他生命周期）</p>
<ul>
<li>  触发进入其他路由。</li>
<li>  调用要离开路由的组件守卫beforeRouteLeave</li>
<li>  调用局前置守卫∶ beforeEach</li>
<li>  在重用的组件里调用 beforeRouteUpdate</li>
<li>  调用路由独享守卫 beforeEnter。</li>
<li>  解析异步路由组件。</li>
<li>  在将要进入的路由组件中调用 beforeRouteEnter</li>
<li>  调用全局解析守卫 beforeResolve</li>
<li>  导航被确认。</li>
<li>  调用全局后置钩子的 afterEach 钩子。</li>
<li>  触发DOM更新（mounted）。</li>
<li>  执行beforeRouteEnter 守卫中传给 next 的回调函数</li>
</ul>
</li>
<li><p>触发钩子的完整顺序</p>
<p> 路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p>
<ul>
<li>  beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li>
<li>  beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li>
<li>  beforeEnter：路由独享守卫</li>
<li>  beforeRouteEnter：路由组件的组件进入路由前钩子。</li>
<li>  beforeResolve：路由全局解析守卫</li>
<li>  afterEach：路由全局后置钩子</li>
<li>  beforeCreate：组件生命周期，不能访问tAis。</li>
<li>  created;组件生命周期，可以访问tAis，不能访问dom。</li>
<li>  beforeMount：组件生命周期</li>
<li>  deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li>
<li>  mounted：访问/操作dom。</li>
<li>  activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li>
<li>  执行beforeRouteEnter回调函数next。</li>
</ul>
</li>
<li><p>导航行为被触发到导航完成的整个过程</p>
<ul>
<li>  导航行为被触发，此时导航未被确认。</li>
<li>  在失活的组件里调用离开守卫 beforeRouteLeave。</li>
<li>  调用全局的 beforeEach守卫。</li>
<li>  在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li>
<li>  在路由配置里调用 beforeEnteY。</li>
<li>  解析异步路由组件（如果有）。</li>
<li>  在被激活的组件里调用 beforeRouteEnter。</li>
<li>  调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li>
<li>  导航被确认。</li>
<li>  调用全局的 afterEach 钩子。</li>
<li>  非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li>
<li>  触发 DOM 更新。</li>
<li>  用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li>
<li>  导航完成</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="7-Vue-router-跳转和-location-href-有什么区别"><a href="#7-Vue-router-跳转和-location-href-有什么区别" class="headerlink" title="7. Vue-router 跳转和 location.href 有什么区别"></a>7. Vue-router 跳转和 location.href 有什么区别</h3><ul>
<li>  使用 <code>location.href= /url </code>来跳转，简单方便，但是刷新了页面；</li>
<li>  使用 <code>history.pushState( /url )</code> ，无刷新页面，静态跳转；</li>
<li>  引进 router ，然后使用 <code>router.push( /url )</code> 来跳转，使用了 <code>diff</code> 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 <code>history.pushState()</code> 没什么差别的，因为vue-router就是用了 <code>history.pushState()</code> ，尤其是在history模式下。</li>
</ul>
<h3 id="8-params-和-query-的区别"><a href="#8-params-和-query-的区别" class="headerlink" title="8. params 和 query 的区别"></a>8. params 和 query 的区别</h3><p><strong>用法</strong>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 <code>this.$route.query.name</code> 和 <code>this.$route.params.name</code> 。</p>
<p><strong>url地址显示</strong>：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p>
<p><strong>注意</strong>：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。</p>
<h3 id="9-Vue-router-导航守卫有哪些"><a href="#9-Vue-router-导航守卫有哪些" class="headerlink" title="9. Vue-router 导航守卫有哪些"></a>9. Vue-router 导航守卫有哪些</h3><ul>
<li>  全局前置/钩子：beforeEach、beforeResolve、afterEach</li>
<li>  路由独享的守卫：beforeEnter</li>
<li>  组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li>
</ul>
<h3 id="10-对前端路由的理解"><a href="#10-对前端路由的理解" class="headerlink" title="10. 对前端路由的理解"></a>10. 对前端路由的理解</h3><p>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。</p>
<p>后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。</p>
<p>SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：</p>
<ul>
<li>  SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。</li>
<li>  由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息</li>
</ul>
<p>为了解决这个问题，前端路由出现了。</p>
<p>前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。</p>
<p>那么如何实现这个目的呢？首先要解决两个问题：</p>
<ul>
<li>  当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</li>
<li>  单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？</li>
</ul>
<p>从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：</p>
<ul>
<li>  拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li>
<li>  感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</li>
</ul>
<h2 id="五、Vuex"><a href="#五、Vuex" class="headerlink" title="五、Vuex"></a>五、Vuex</h2><h3 id="1-Vuex-的原理"><a href="#1-Vuex-的原理" class="headerlink" title="1. Vuex 的原理"></a>1. Vuex 的原理</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<ul>
<li>  Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>  改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。</li>
</ul>
<p><img src="/2021/12/17/vue/04-5-1.png"></p>
<p>Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。</p>
<ol>
<li><strong>核心流程中的主要功能：</strong><ul>
<li>  Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;</li>
<li>  在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li>
<li>  然后 Mutations 就去改变（Mutate）State 中的数据;</li>
<li>  当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li>
</ul>
</li>
<li><strong>各模块在核心流程中的主要功能：</strong><ul>
<li>  <code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li>
<li>  <code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li>
<li>  <code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li>
<li>  <code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li>
<li>  <code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li>
<li>  <code>state</code>∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li>
<li>  <code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li>
</ul>
</li>
</ol>
<h3 id="2-Vuex-中-action-和-mutation-的区别"><a href="#2-Vuex-中-action-和-mutation-的区别" class="headerlink" title="2. Vuex 中 action 和 mutation 的区别"></a>2. Vuex 中 action 和 mutation 的区别</h3><p>mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++      <span class="comment">// 变更状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当触发一个类型为 increment 的 mutation 时，需要调用此函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>而Action类似于mutation，不同点在于：</p>
<ul>
<li>  Action 可以包含任意异步操作。</li>
<li>  Action 提交的是 mutation，而不是直接变更状态。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 所以，两者的不同点如下：</p>
<ul>
<li>  Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。</li>
<li>  Mutation：必须同步执行；Action：可以异步，但不能直接操作State。</li>
<li>  在视图更新时，先触发actions，actions再触发mutation</li>
<li>  mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters</li>
</ul>
<h3 id="3-Vuex-和-localStorage-的区别"><a href="#3-Vuex-和-localStorage-的区别" class="headerlink" title="3. Vuex 和 localStorage 的区别"></a>3. Vuex 和 localStorage 的区别</h3><ol>
<li><p><strong>最重要的区别</strong></p>
<ul>
<li>  vuex存储在内存中</li>
<li>  localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快</li>
</ul>
</li>
<li><p><strong>应用场景</strong></p>
<ul>
<li>  Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。</li>
<li>  localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。</li>
<li>  Vuex能做到数据的响应式，localstorage不能</li>
</ul>
</li>
<li><p><strong>永久性</strong></p>
<p> 刷新页面时vuex存储的值会丢失，localstorage不会。</p>
</li>
</ol>
<p><strong>注意：</strong> 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。</p>
<h3 id="4-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#4-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="4. Redux 和 Vuex 有什么区别，它们的共同思想"></a>4. Redux 和 Vuex 有什么区别，它们的共同思想</h3><ol>
<li><p><strong>Redux 和 Vuex区别</strong></p>
<ul>
<li>  Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li>
<li>  Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li>
<li>  Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</li>
</ul>
<p> 通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;</p>
</li>
<li><p><strong>共同思想</strong></p>
<ul>
<li>  单—的数据源</li>
<li>  变化可以预测</li>
</ul>
</li>
</ol>
<p>本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案; 形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理</p>
<h3 id="5-为什么要用-Vuex-或者-Redux"><a href="#5-为什么要用-Vuex-或者-Redux" class="headerlink" title="5. 为什么要用 Vuex 或者 Redux"></a>5. 为什么要用 Vuex 或者 Redux</h3><p>由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。</p>
<p>所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p>
<p>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。</p>
<h3 id="6-Vuex-有哪几种属性？"><a href="#6-Vuex-有哪几种属性？" class="headerlink" title="6. Vuex 有哪几种属性？"></a>6. Vuex 有哪几种属性？</h3><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p>
<ul>
<li>  state =&gt; 基本数据(数据源存放地)</li>
<li>  getters =&gt; 从基本数据派生出来的数据</li>
<li>  mutations =&gt; 提交更改数据的方法，同步</li>
<li>  actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。</li>
<li>  modules =&gt; 模块化Vuex</li>
</ul>
<h3 id="7-Vuex-和单纯的全局对象有什么区别？"><a href="#7-Vuex-和单纯的全局对象有什么区别？" class="headerlink" title="7. Vuex 和单纯的全局对象有什么区别？"></a>7. Vuex 和单纯的全局对象有什么区别？</h3><ul>
<li>  Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>  不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li>
</ul>
<h3 id="8-为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#8-为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="8. 为什么 Vuex 的 mutation 中不能做异步操作？"></a>8. 为什么 Vuex 的 mutation 中不能做异步操作？</h3><ul>
<li>  Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li>
<li>  每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li>
</ul>
<h3 id="9-Vuex-的严格模式是什么-有什么作用，如何开启？"><a href="#9-Vuex-的严格模式是什么-有什么作用，如何开启？" class="headerlink" title="9. Vuex 的严格模式是什么,有什么作用，如何开启？"></a>9. Vuex 的严格模式是什么,有什么作用，如何开启？</h3><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>
<p>在Vuex.Store 构造器选项中开启,如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="attr">strict</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="10-如何在组件中批量使用-Vuex-的-getter-属性"><a href="#10-如何在组件中批量使用-Vuex-的-getter-属性" class="headerlink" title="10. 如何在组件中批量使用 Vuex 的 getter 属性"></a>10. 如何在组件中批量使用 Vuex 的 getter 属性</h3><p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        ...mapGetters([<span class="string">&#x27;total&#x27;</span>,<span class="string">&#x27;discountTotal&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-如何在组件中重复使用-Vuex-的-mutation"><a href="#11-如何在组件中重复使用-Vuex-的-mutation" class="headerlink" title="11. 如何在组件中重复使用 Vuex 的 mutation"></a>11. 如何在组件中重复使用 Vuex 的 mutation</h3><p>使用mapMutations辅助函数,在组件中这么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">        <span class="attr">setNumber</span>:<span class="string">&#x27;SET_NUMBER&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p>
<h2 id="六、Vue-3-0"><a href="#六、Vue-3-0" class="headerlink" title="六、Vue 3.0"></a>六、Vue 3.0</h2><h3 id="1-Vue3-0-有什么更新"><a href="#1-Vue3-0-有什么更新" class="headerlink" title="1. Vue3.0 有什么更新"></a>1. Vue3.0 有什么更新</h3><ol>
<li>监测机制的改变<ul>
<li>  3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。</li>
<li>  消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</li>
</ul>
</li>
<li>只能监测属性，不能监测对象<ul>
<li>  检测属性的添加和删除；</li>
<li>  检测数组索引和长度的变更；</li>
<li>  支持 Map、Set、WeakMap 和 WeakSet。</li>
</ul>
</li>
<li>模板<ul>
<li>  作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</li>
<li>  同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</li>
</ul>
</li>
<li>对象式的组件声明方式<ul>
<li>  vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</li>
<li>  3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</li>
</ul>
</li>
<li>其它方面的修改<ul>
<li>  支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li>
<li>  支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li>
<li>  基于 tree shaking 优化，提供了更多的内置功能。</li>
</ul>
</li>
</ol>
<h3 id="2-defineProperty-和-proxy-的区别"><a href="#2-defineProperty-和-proxy-的区别" class="headerlink" title="2. defineProperty 和 proxy 的区别"></a>2. defineProperty 和 proxy 的区别</h3><p>Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。</p>
<p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p>但是这样做有以下问题：</p>
<ol>
<li> 添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过<code>$set</code> 来调用<code>Object.defineProperty()</code>处理。</li>
<li> 无法监控到数组下标和长度的变化。</li>
</ol>
<p>Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于<code>Object.defineProperty()</code>，其有以下特点：</p>
<ol>
<li> Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li>
<li> Proxy 可以监听数组的变化。</li>
</ol>
<h3 id="3-Vue3-0-为什么要用-proxy？"><a href="#3-Vue3-0-为什么要用-proxy？" class="headerlink" title="3. Vue3.0 为什么要用 proxy？"></a>3. Vue3.0 为什么要用 proxy？</h3><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p>
<ul>
<li>  不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li>
<li>  全方位的数组变化检测，消除了Vue2 无效的边界情况。</li>
<li>  支持 Map，Set，WeakMap 和 WeakSet。</li>
</ul>
<p>Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶</p>
<ul>
<li>  get 收集依赖</li>
<li>  Set、delete 等触发依赖</li>
<li>  对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</li>
</ul>
<h3 id="4-Vue-3-0-中的-Vue-Composition-API？"><a href="#4-Vue-3-0-中的-Vue-Composition-API？" class="headerlink" title="4. Vue 3.0 中的 Vue Composition API？"></a>4. Vue 3.0 中的 Vue Composition API？</h3><p>在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：</p>
<ol>
<li> 由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。</li>
<li> Vue 组件过于依赖<code>this</code>上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在<code>methods</code> 中的<code>this</code>竟然指向组件实例来不指向<code>methods</code>所在的对象。这也使得 TypeScript 在Vue2 中很不好用。</li>
</ol>
<p>于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。</p>
<p>如下，是一个使用了 Vue Composition API 的 Vue3 组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    Count: &#123;&#123; count &#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> &#123; ref, computed, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"> </span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> </span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// Vue2中需要在methods option中声明的函数，现在直接声明</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      count.value++</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> <span class="comment">// 对应于Vue2中的mounted声明周期</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    onMounted(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;component mounted!&#x27;</span>))</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> </span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      count,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      increment</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性</p>
<h3 id="5-Composition-API-与-React-Hook-很像，区别是什么"><a href="#5-Composition-API-与-React-Hook-很像，区别是什么" class="headerlink" title="5. Composition API 与 React Hook 很像，区别是什么"></a>5. Composition API 与 React Hook 很像，区别是什么</h3><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p>
<ul>
<li>  不能在循环、条件、嵌套函数中调用Hook</li>
<li>  必须确保总是在你的React函数的顶层调用Hook</li>
<li>  useEffect、useMemo等函数必须手动确定依赖关系</li>
</ul>
<p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p>
<ul>
<li>  声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li>
<li>  Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li>
<li>  响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li>
</ul>
<p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p>
<h2 id="七、虚拟DOM"><a href="#七、虚拟DOM" class="headerlink" title="七、虚拟DOM"></a>七、虚拟DOM</h2><h3 id="1-对虚拟DOM的理解？"><a href="#1-对虚拟DOM的理解？" class="headerlink" title="1. 对虚拟DOM的理解？"></a>1. 对虚拟DOM的理解？</h3><p>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p>
<p>虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p>
<p>另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。</p>
<h3 id="2-虚拟DOM的解析过程"><a href="#2-虚拟DOM的解析过程" class="headerlink" title="2. 虚拟DOM的解析过程"></a>2. 虚拟DOM的解析过程</h3><p>虚拟DOM的解析过程：</p>
<ul>
<li>  首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</li>
<li>  当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</li>
<li>  最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</li>
</ul>
<h3 id="3-为什么要用虚拟DOM"><a href="#3-为什么要用虚拟DOM" class="headerlink" title="3. 为什么要用虚拟DOM"></a>3. 为什么要用虚拟DOM</h3><ol>
<li><p><strong>保证性能下限，在不进行手动优化的情况下，提供过得去的性能</strong> 看一下页面渲染的流程：<strong>解析HTML -&gt; 生成DOM -&gt; 生成 CSSOM -&gt; Layout -&gt; Paint -&gt; Compiler</strong> 下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶</p>
<ul>
<li>  真实DOM∶ 生成HTML字符串＋重建所有的DOM元素</li>
<li>  虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新</li>
</ul>
<p> Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。 </p>
</li>
<li><p> <strong>跨平台</strong> Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</p>
</li>
</ol>
<h3 id="4-虚拟DOM真的比真实DOM性能好吗"><a href="#4-虚拟DOM真的比真实DOM性能好吗" class="headerlink" title="4. 虚拟DOM真的比真实DOM性能好吗"></a>4. 虚拟DOM真的比真实DOM性能好吗</h3><ul>
<li>  首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</li>
<li>  正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。</li>
</ul>
<h3 id="5-DIFF算法的原理"><a href="#5-DIFF算法的原理" class="headerlink" title="5. DIFF算法的原理"></a>5. DIFF算法的原理</h3><p>在新老虚拟DOM对比时：</p>
<ul>
<li>  首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li>
<li>  如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li>
<li>  比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li>
<li>  匹配时，找到相同的子节点，递归比较子节点</li>
</ul>
<p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p>
<h3 id="6-Vue-中-key-的作用"><a href="#6-Vue-中-key-的作用" class="headerlink" title="6. Vue 中 key 的作用"></a>6. Vue 中 key 的作用</h3><p>vue 中 key 值的作用可以分为两种情况来考虑：</p>
<ul>
<li>  第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li>
<li>  第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li>
</ul>
<p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</p>
<ul>
<li>  更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。</li>
<li>  更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li>
</ul>
<h3 id="7-为什么不建议用-index-作为-key"><a href="#7-为什么不建议用-index-作为-key" class="headerlink" title="7. 为什么不建议用 index 作为 key ?"></a>7. 为什么不建议用 index 作为 key ?</h3><p>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript面试题</title>
    <url>/2021/12/06/javascript/</url>
    <content><![CDATA[<p>绝大部分内容来自：<a href="https://juejin.cn/user/3544481220801815">https://juejin.cn/user/3544481220801815</a></p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2021/12/06/javascript/03.JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="03.JavaScript面试题"></p>
<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p>
<p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p>
<ul>
<li>  Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li>  BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li>
</ul>
<p>这些数据可以分为原始数据类型和引用数据类型：</p>
<ul>
<li>  栈：原始数据类型（Undefined、Null、Boolean、Number、String、BigInt）</li>
<li>  堆：引用数据类型（对象、数组和函数）</li>
</ul>
<p>两种类型的区别在于<strong>存储位置的不同：</strong></p>
<ul>
<li>  原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>  引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p>
<ul>
<li>  在数据结构中，栈中数据的存取方式为先进后出。</li>
<li>  堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li>
</ul>
<p>在操作系统中，内存被分为栈区和堆区：</p>
<ul>
<li>  栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li>  堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li>
</ul>
<h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><ol>
<li><p>typeof</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p> 其中数组、对象、null都会被判断为object，其它判断都正确。</p>
</li>
<li><p>instanceof</p>
<p> <code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> 可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p>
</li>
<li><p>constructor</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> <code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>Object.prototype.toString.call()</p>
<p> <code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="number">2</span>));  <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">true</span>));  <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="string">&#x27;str&#x27;</span>));  <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call([]));  <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));  <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(&#123;&#125;));  <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">undefined</span>));  <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">null</span>));  <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<p> 同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p>
<p> 这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p>
</li>
</ol>
<h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><ol>
<li><p>通过Object.prototype.toString.call()做判断</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>通过原型链做判断</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.__proto__ === <span class="built_in">Array</span>.prototype;</span><br></pre></td></tr></table></figure></li>
<li><p>通过ES6的Array.isArray()做判断</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArrray(obj);</span><br></pre></td></tr></table></figure></li>
<li><p>通过instanceof做判断</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过Array.prototype.isPrototypeOf</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(obj)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>参考：<a href="https://juejin.cn/post/6844903777506426893">https://juejin.cn/post/6844903777506426893</a></p>
<p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p>
<p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p>
<p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p>
<p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p>
<h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。<a href="https://juejin.cn/post/6844903895177805837">https://juejin.cn/post/6844903895177805837</a></p>
<p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">000</span>: object   - 当前存储的数据指向一个对象。  <span class="number">1</span>: int      - 当前存储的数据是一个 <span class="number">31</span> 位的有符号整数。<span class="number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。<span class="number">100</span>: string   - 当前存储的数据指向一个字符串。<span class="number">110</span>: boolean  - 当前存储的数据是布尔值。</span><br></pre></td></tr></table></figure>

<p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p>
<p>有两种特殊数据类型：</p>
<ul>
<li>  undefined的值是 $-2^{31}$(一个超出整数范围的数字，即全为1)；</li>
<li>  null 的值是机器码 NULL 指针(null 指针的值全是 0)</li>
</ul>
<p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p>
<h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;  <span class="comment">// 获取对象的原型  let proto = Object.getPrototypeOf(left)  // 获取构造函数的 prototype 对象  let prototype = right.prototype;    // 判断构造函数的 prototype 对象是否在对象的原型链上  while (true) &#123;    if (!proto) return false;    if (proto === prototype) return true;    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型    proto = Object.getPrototypeOf(proto);  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-为什么0-1-0-2-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! == 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! == 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">0.1</span>, n2 = <span class="number">0.</span>2<span class="built_in">console</span>.log(n1 + n2)  <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure>

<p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(n1 + n2).toFixed(<span class="number">2</span>) <span class="comment">// 注意，toFixed为四舍五入</span></span><br></pre></td></tr></table></figure>

<p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p>
<p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p>
<p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p>
<p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p>
<p>下面看一下<strong>双精度数是如何保存</strong>的： <img src="/2021/12/06/javascript/03-1-7.png" alt="img"></p>
<ul>
<li>  第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li>
<li>  第二部分（绿色）：用来存储指数（exponent），占用11位</li>
<li>  第三部分（红色）：用来存储小数（fraction），占用52位</li>
</ul>
<p>对于0.1，它的二进制为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="number">10011.</span>..</span><br></pre></td></tr></table></figure>

<p>转为科学计数法（科学计数法的结果就是浮点数）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="number">2</span>^-<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure>

<p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p>
<p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p>
<ul>
<li>  当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li>
<li>  当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。</li>
<li>  当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。</li>
</ul>
<p>对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.</p>
<p>所以，0.1表示为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1111111011</span> <span class="number">1001100110011001100110011001100110011001100110011001</span></span><br></pre></td></tr></table></figure>

<p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？</p>
<p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为$2^{-52}$，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是$2^{-52}$，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberepsilon</span>(<span class="params">arg1,arg2</span>)</span>&#123;                     <span class="keyword">return</span> <span class="built_in">Math</span>.abs(arg1 - arg2) &lt; <span class="built_in">Number</span>.EPSILON;        &#125;        <span class="built_in">console</span>.log(numberepsilon(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p>
<h3 id="9-typeof-NaN-的结果是什么？"><a href="#9-typeof-NaN-的结果是什么？" class="headerlink" title="9. typeof NaN 的结果是什么？"></a>9. typeof NaN 的结果是什么？</h3><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// &quot;number&quot;</span></span><br></pre></td></tr></table></figure>

<p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。</p>
<h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3><ul>
<li>  函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li>
<li>  函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li>
</ul>
<h3 id="11-操作符的强制类型转换规则？"><a href="#11-操作符的强制类型转换规则？" class="headerlink" title="11. == 操作符的强制类型转换规则？"></a>11. == 操作符的强制类型转换规则？</h3><p>参考：<a href="https://juejin.cn/post/6844903793893572622#heading-5">https://juejin.cn/post/6844903793893572622#heading-5</a></p>
<ol>
<li> 如果类型相同，调用 <code>===</code> 操作符</li>
<li>如果类型不同，尝试类型转换<ol>
<li>查看是否是 <code>undefined</code> 和 <code>null</code> 比较<ul>
<li>  ✅ 返回 <code>true</code></li>
<li>  ⬇️ 如果不是继续下一条规则</li>
</ul>
</li>
<li>是否在比较 <code>string</code> 和 <code>number</code><ul>
<li>  ✅ 如果是，那么将 <code>string</code> 转为 <code>number</code> 并回到最初重新比较 ♻️</li>
<li>  ⬇️ 如果不是继续下一条规则</li>
</ul>
</li>
<li>查看我们比较的项中是否有 <code>boolean</code><ul>
<li>  ✅ 如果有，那么将 <code>boolean</code> 转为 <code>number</code> 并回到最初重新比较 ♻️</li>
<li>  ⬇️ 如果不是继续下一条规则</li>
</ul>
</li>
<li>查看是否有一项是 <code>object</code><ul>
<li>  ✅ 如果有，那么将 <code>object</code> 转为其原始值 <code>primitive</code> 并回到最初重新比较 ♻️</li>
<li>  ❌ 如果还不是，只能返回 <code>false</code> 了</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><img src="/2021/12/06/javascript/03-1-11.webp"></p>
<p>那么怎么获取对象原始值的呢：</p>
<blockquote>
<p>  我们需要知道转换类型的这个方法在 JS 源代码中是 <code>ToPrimitive</code> 这个方法，该方法有一个可选参数 <code>PreferredType</code>，这个参数的作用是指定期望类型；如果第一个参数对应的对象可以被转换为不止一种类型，那么后者可以作为一种暗示，表示该对象应该转换为那种类型</p>
</blockquote>
<ol>
<li>默认情况下（期望类型默认为 <code>number</code>）<ul>
<li>调用 <code>valueOf</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ⬇️ 如果返回的不是原始值，那么跳到下一步</li>
</ul>
</li>
<li>调用 <code>toString</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ❌ 否则报错💩</li>
</ul>
</li>
</ul>
</li>
<li>如果期望类型为 <code>string</code>：<ol>
<li>调用 <code>toString</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ⬇️ 如果返回的不是原始值，那么跳到下一步</li>
</ul>
</li>
<li>调用 <code>valueOf</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ❌ 否则报错💩</li>
</ul>
</li>
</ol>
</li>
<li>如果对象是 Date 类型（期望类型为 <code>string</code>）：<ol>
<li>调用 <code>toString</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ⬇️ 如果返回的不是原始值，那么跳到下一步</li>
</ul>
</li>
<li>调用 <code>valueOf</code> 方法：<ul>
<li>  ✅ 如果返回的是原始值，那么就用这个</li>
<li>  ❌ 否则报错💩</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>例子：</p>
<ol>
<li> 普通的对象，首先调用 valueOf 方法，返回的结果并非原始值，那么会调用 toString 方法<img src="/2021/12/06/javascript/03--1-11-2.webp"></li>
<li> 假设我们重写 valueOf 方法，valueOf 和 toString 同时返回 string 原始值。使用 == 操作符可以看出，对象还是优先使用了 valueOf 方法返回的值<img src="/2021/12/06/javascript/03--1-11-3.webp"></li>
<li> 数组同理，首先默认调用 valueOf 方法，如不是原始值，则调用 toString 方法<img src="/2021/12/06/javascript/03--1-11-4.webp"></li>
<li> 再看看 Date 类型，他的期望类型是 string 因此首先调用的是 toString 方法，该方法返回一个原始值，那么就是用这个原始值<img src="/2021/12/06/javascript/03--1-11-5.webp"></li>
</ol>
<h3 id="12-其他值到字符串的转换规则？"><a href="#12-其他值到字符串的转换规则？" class="headerlink" title="12. 其他值到字符串的转换规则？"></a>12. 其他值到字符串的转换规则？</h3><ul>
<li>  Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li>
<li>  Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li>
<li>  Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li>
<li>  Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li>
<li>  对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li>
</ul>
<h3 id="13-其他值到数字值的转换规则？"><a href="#13-其他值到数字值的转换规则？" class="headerlink" title="13. 其他值到数字值的转换规则？"></a>13. 其他值到数字值的转换规则？</h3><ul>
<li>  Undefined 类型的值转换为 NaN。</li>
<li>  Null 类型的值转换为 0。</li>
<li>  Boolean 类型的值，true 转换为 1，false 转换为 0。</li>
<li>  String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li>
<li>  Symbol 类型的值不能转换为数字，会报错。</li>
<li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。<ul>
<li>  为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</li>
<li>  如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</li>
</ul>
</li>
</ul>
<h3 id="14-其他值到布尔类型的值的转换规则？"><a href="#14-其他值到布尔类型的值的转换规则？" class="headerlink" title="14. 其他值到布尔类型的值的转换规则？"></a>14. 其他值到布尔类型的值的转换规则？</h3><p>以下这些是假值：</p>
<ul>
<li>  undefined</li>
<li>  null</li>
<li>  false</li>
<li>  +0、-0 </li>
<li>  NaN </li>
<li>  “”</li>
</ul>
<p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p>
<h3 id="15-和-amp-amp-操作符的返回值？"><a href="#15-和-amp-amp-操作符的返回值？" class="headerlink" title="15. || 和 &amp;&amp; 操作符的返回值？"></a>15. || 和 &amp;&amp; 操作符的返回值？</h3><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p>
<ul>
<li>  对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li>
<li>  &amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li>
</ul>
<p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p>
<h3 id="16-Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#16-Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="16. Object.is() 与比较操作符 “===”、“==” 的区别？"></a>16. Object.is() 与比较操作符 “===”、“==” 的区别？</h3><ul>
<li><p>  使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</p>
</li>
<li><p>  使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</p>
</li>
<li><p>  使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</p>
</li>
</ul>
<p>参考MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness</a></p>
<table>
<thead>
<tr>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">==</th>
<th align="center">===</th>
<th align="center">Object.is</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>undefined</code></td>
<td align="center"><code>undefined</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>null</code></td>
<td align="center"><code>null</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>true</code></td>
<td align="center"><code>true</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>&quot;foo&quot;</code></td>
<td align="center"><code>&quot;foo&quot;</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center"><code>0</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center"><code>+0</code></td>
<td align="center"><code>-0</code></td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center"><code>false</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&quot;&quot;</code></td>
<td align="center"><code>false</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&quot;&quot;</code></td>
<td align="center"><code>0</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&quot;0&quot;</code></td>
<td align="center"><code>0</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&quot;17&quot;</code></td>
<td align="center"><code>17</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>[1,2]</code></td>
<td align="center"><code>&quot;1,2&quot;</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>new String(&quot;foo&quot;)</code></td>
<td align="center"><code>&quot;foo&quot;</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>null</code></td>
<td align="center"><code>undefined</code></td>
<td align="center">true</td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>null</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>undefined</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&#123; foo: &quot;bar&quot; &#125;</code></td>
<td align="center"><code>&#123; foo: &quot;bar&quot; &#125;</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>new String(&quot;foo&quot;)</code></td>
<td align="center"><code>new String(&quot;foo&quot;)</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center"><code>null</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center"><code>NaN</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>&quot;foo&quot;</code></td>
<td align="center"><code>NaN</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
</tr>
<tr>
<td align="center"><code>NaN</code></td>
<td align="center"><code>NaN</code></td>
<td align="center"><code>false</code></td>
<td align="center"><code>false</code></td>
<td align="center">true</td>
</tr>
</tbody></table>
<h3 id="17-什么是-JavaScript-中的包装类型？"><a href="#17-什么是-JavaScript-中的包装类型？" class="headerlink" title="17. 什么是 JavaScript 中的包装类型？"></a>17. 什么是 JavaScript 中的包装类型？</h3><p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&quot;abc&quot;</span>;a.length; <span class="comment">// 3a.toUpperCase(); // &quot;ABC&quot;复制代码</span></span><br></pre></td></tr></table></figure>

<p>在访问<code>&#39;abc&#39;.length</code>时，JavaScript 将<code>&#39;abc&#39;</code>在后台转换成<code>String(&#39;abc&#39;)</code>，然后再访问其<code>length</code>属性。</p>
<p>JavaScript也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span><span class="built_in">Object</span>(a) <span class="comment">// String &#123;&quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span><span class="keyword">var</span> b = <span class="built_in">Object</span>(a)<span class="keyword">var</span> c = b.valueOf() <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>看看如下代码会打印出什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> );<span class="keyword">if</span> (!a) &#123;	<span class="built_in">console</span>.log( <span class="string">&quot;Oops&quot;</span> ); <span class="comment">// never runs&#125;</span></span><br></pre></td></tr></table></figure>

<p>答案是什么都不会打印，因为虽然包裹的基本类型是<code>false</code>，但是<code>false</code>被包裹成包装类型后就成了对象，所以其非值为<code>false</code>，所以循环体中的内容不会运行。</p>
<h3 id="18-JavaScript-中如何进行隐式类型转换？"><a href="#18-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="18. JavaScript 中如何进行隐式类型转换？"></a>18. JavaScript 中如何进行隐式类型转换？</h3><blockquote>
<p>  [] + {}  // [object Object]</p>
<p>  {} + []  // 0</p>
</blockquote>
<p> 参考：<a href="https://juejin.cn/post/6844903632974905358#heading-1%EF%BC%88%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E3%80%8B%E4%B8%AD%E5%8D%B7%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%89">https://juejin.cn/post/6844903632974905358#heading-1（《你不知道的JS》中卷第四章）</a></p>
<p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** <span class="doctag">@obj </span>需要转换的对象* <span class="doctag">@type </span>期望的结果类型*/</span>ToPrimitive(obj,type)</span><br></pre></td></tr></table></figure>

<p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p>
<ol>
<li><strong>当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong><ul>
<li>  调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li>
<li>  调用<code>obj</code>的<code>toString</code>方法，后续同上；</li>
<li>  抛出<code>TypeError</code> 异常。</li>
</ul>
</li>
<li><strong>当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong><ul>
<li>  调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li>
<li>  调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li>
<li>  抛出<code>TypeError</code> 异常。</li>
</ul>
</li>
</ol>
<p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p>
<ul>
<li>  如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li>
<li>  其他情况下，<code>type</code>默认为<code>number</code>。</li>
</ul>
<p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objToNumber = <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">Number</span>(value.valueOf().toString())objToNumber([]) === 0objToNumber(&#123;&#125;) === <span class="literal">NaN</span></span><br></pre></td></tr></table></figure>

<p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p>
<p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p>
<ol>
<li><p><code>+</code><strong>操作符</strong></p>
<p> <code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;23&#x27;</span> <span class="comment">// &#x27;123&#x27; 1 + false // 1  1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number &#x27;1&#x27; + false // &#x27;1false&#x27; false + true // 1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>-</code>、<code>*</code>、<code>\</code><strong>操作符</strong></p>
<p> <code>NaN</code>也是一个数字</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="string">&#x27;23&#x27;</span> <span class="comment">// 23 1 * false // 0 1 / &#x27;aa&#x27; // NaN</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对于</strong><code>==</code><strong>操作符</strong></p>
<p> 操作符两边的值都尽量转成<code>number</code>：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> == <span class="literal">true</span> <span class="comment">// false, 3 转为number为3，true转为number为1&#x27;0&#x27; == false //true, &#x27;0&#x27;转为number为0，false转为number为0&#x27;0&#x27; == 0 // &#x27;0&#x27;转为number为0</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对于</strong><code>&lt;</code><strong>和</strong><code>&gt;</code><strong>比较符</strong></p>
<p> 如果两边都是字符串，则比较字母表顺序：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;ca&#x27;</span> &lt; <span class="string">&#x27;bd&#x27;</span> <span class="comment">// false&#x27;a&#x27; &lt; &#x27;b&#x27; // true</span></span><br></pre></td></tr></table></figure>

<p> 其他情况下，转换为数字再比较：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span> &lt; <span class="number">13</span> <span class="comment">// truefalse &gt; -1 // true</span></span><br></pre></td></tr></table></figure>

<p> 以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;a &gt; <span class="number">2</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p> 其对比过程如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.valueOf() <span class="comment">// &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步a.toString() // &quot;[object Object]&quot;，现在是一个字符串了Number(a.toString()) // NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字NaN &gt; 2 //false，得出比较结果</span></span><br></pre></td></tr></table></figure>

<p> 又比如：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;<span class="keyword">var</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;a + b <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p> 运算过程如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.valueOf() <span class="comment">// &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步a.toString() // &quot;[object Object]&quot;b.valueOf() // 同理b.toString() // &quot;[object Object]&quot;a + b // &quot;[object Object][object Object]&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="19-操作符什么时候用于字符串的拼接？"><a href="#19-操作符什么时候用于字符串的拼接？" class="headerlink" title="19. +操作符什么时候用于字符串的拼接？"></a>19. +操作符什么时候用于字符串的拼接？</h3><p>参考：<a href="https://juejin.cn/post/6844904038400540680#comment">https://juejin.cn/post/6844904038400540680#comment</a></p>
<p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p>
<p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p>
<p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p>
<h3 id="20-为什么会有BigInt的提案？"><a href="#20-为什么会有BigInt的提案？" class="headerlink" title="20. 为什么会有BigInt的提案？"></a>20. 为什么会有BigInt的提案？</h3><p>参考：<a href="https://juejin.cn/post/6844903902295359502">https://juejin.cn/post/6844903902295359502</a></p>
<p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。</p>
<h3 id="21-object-assign和扩展运算符是深拷贝还是浅拷贝，两者区别"><a href="#21-object-assign和扩展运算符是深拷贝还是浅拷贝，两者区别" class="headerlink" title="21. object.assign和扩展运算符是深拷贝还是浅拷贝，两者区别"></a>21. object.assign和扩展运算符是深拷贝还是浅拷贝，两者区别</h3><p>扩展运算符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> outObj = &#123;  <span class="attr">inObj</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;&#125;<span class="keyword">let</span> newObj = &#123;...outObj&#125;newObj.inObj.a = 2<span class="built_in">console</span>.log(outObj) <span class="comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>Object.assign():</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> outObj = &#123;  <span class="attr">inObj</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;&#125;<span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, outObj)newObj.inObj.a = 2<span class="built_in">console</span>.log(outObj) <span class="comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，两者都是浅拷贝。</p>
<ul>
<li>  Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</li>
<li>  扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</li>
</ul>
<p>深拷贝与浅拷贝的区别：</p>
<ul>
<li>  <code>浅拷贝</code>，只拷贝第一层的原始类型值，和第一层的引用类型地址。</li>
<li>  <code>深拷贝</code>，拷贝所有的属性值，以及属性地址指向的值的内存空间。通过递归调用，或者 JSON 来做深拷贝，都会有一些问题。而 cloneForce 方法倒是目前看来最完美的解决方案了。</li>
</ul>
<h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><p><strong>（1）块级作用域：</strong> 块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p>
<ul>
<li>  内层变量可能覆盖外层变量</li>
<li>  用来计数的循环变量泄露为全局变量</li>
</ul>
<p><strong>（2）变量提升：</strong> var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>
<p><strong>（3）给全局添加属性：</strong> 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p>
<p><strong>（4）重复声明：</strong> var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p>
<p><strong>（5）暂时性死区：</strong> 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p>
<p><strong>（6）初始值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p>
<p><strong>（7）指针指向：</strong> let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p>
<table>
<thead>
<tr>
<th align="center"><strong>区别</strong></th>
<th align="center"><strong>var</strong></th>
<th align="center"><strong>let</strong></th>
<th align="center"><strong>const</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否有块级作用域</td>
<td align="center">×</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">是否存在变量提升</td>
<td align="center">✔</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">是否添加全局属性</td>
<td align="center">✔</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">能否重复声明变量</td>
<td align="center">✔</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">是否存在暂时性死区</td>
<td align="center">×</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">是否必须设置初始值</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="center">能否改变指针指向</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p>
<p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<p>如果不想让内部数据改动，可以使用 Object.freeze() 方法。注：Object.freeze() 会对最近一层的对象进行冻结，并不会对深层对象进行冻结。</p>
<h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p>
<p>new操作符的实现步骤如下：</p>
<ol>
<li> 创建一个对象</li>
<li> 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</li>
<li> 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li>
<li> 返回新的对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">constructor, ...args</span>) </span>&#123;  <span class="keyword">let</span> obj = &#123;&#125;  <span class="built_in">Object</span>.setPrototypeOf(obj, <span class="title">constructor</span>.<span class="title">prototype</span>)  <span class="title">let</span> <span class="title">result</span> = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">obj, args</span>)  <span class="title">return</span> <span class="title">result</span> <span class="title">instanceof</span> <span class="title">Object</span> ? <span class="title">result</span> : <span class="title">obj</span>&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li> 首先函数接受不定量的参数，第一个参数为构造函数，接下来的参数被构造函数使用</li>
<li> 然后内部创建一个空对象 <code>obj</code></li>
<li> 因为 <code>obj</code> 对象需要访问到构造函数原型链上的属性，所以我们通过 <code>setPrototypeOf</code> 将两者联系起来。这段代码等同于 <code>obj.__proto__ = Con.prototype</code></li>
<li> 将 <code>obj</code> 绑定到构造函数上，并且传入剩余的参数</li>
<li> 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 <code>obj</code>，这样就实现了忽略构造函数返回的原始值</li>
</ol>
<h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><ol>
<li><p>箭头函数比普通函数更加简洁</p>
<ul>
<li><p>  如果没有参数，就直接写一个空括号即可</p>
</li>
<li><p>  如果只有一个参数，可以省去参数的括号</p>
</li>
<li><p>  如果有多个参数，用逗号分割</p>
</li>
<li><p>  如果函数体的返回值只有一句，可以省略大括号</p>
</li>
<li><p>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>箭头函数没有自己的this</p>
<p> 箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p>
</li>
<li><p>箭头函数继承来的this指向永远不会改变</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;<span class="keyword">var</span> obj = &#123;  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,  <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);  &#125;,  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);  &#125;&#125;;obj.a();    <span class="comment">// &#x27;OBJ&#x27;obj.b();    // &#x27;GLOBAL&#x27;new obj.a()  // undefinednew obj.b()  // Uncaught TypeError: obj.b is not a constructor</span></span><br></pre></td></tr></table></figure>

<p> 对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>
</li>
<li><p>call()、apply()、bind()等方法不能改变箭头函数中this的指向</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;<span class="keyword">let</span> fun1 = <span class="function">() =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)&#125;;fun1();                     <span class="comment">// &#x27;Global&#x27;fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27;fun1.apply(&#123;id: &#x27;Obj&#x27;&#125;);    // &#x27;Global&#x27;fun1.bind(&#123;id: &#x27;Obj&#x27;&#125;)();   // &#x27;Global&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数不能作为构造函数使用</p>
<p> 构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p>
</li>
<li><p>箭头函数没有自己的arguments</p>
<p> 箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p>
</li>
<li><p> 箭头函数没有prototype</p>
</li>
<li><p> 箭头函数不能用作Generator函数，不能使用yeild关键字</p>
</li>
</ol>
<h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的this指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p>
<p>可以⽤Babel理解⼀下箭头函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 const obj = &#123;   getArrow() &#123;     return () =&gt; &#123;       console.log(this === obj);     &#125;;   &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>转化后：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5，由 Babel 转译var obj = &#123;    getArrow: function getArrow() &#123;      var _this = this;      return function () &#123;         console.log(_this === obj);      &#125;;    &#125; &#125;;</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://juejin.cn/post/6844903746984476686#heading-3">https://juejin.cn/post/6844903746984476686#heading-3</a></p>
<h3 id="6-扩展运算符的作用及使用场景"><a href="#6-扩展运算符的作用及使用场景" class="headerlink" title="6. 扩展运算符的作用及使用场景"></a>6. 扩展运算符的作用及使用场景</h3><ol>
<li><p>对象扩展运算符</p>
<p> 对象的扩展运算符（…）用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;<span class="keyword">let</span> baz = &#123; ...bar &#125;; <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p> 上述方法等价于：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;<span class="keyword">let</span> baz = <span class="built_in">Object</span>.assign(&#123;&#125;, bar); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p> <code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p>
<p> 同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;<span class="keyword">let</span> baz = &#123;...bar, ...&#123;<span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;&#125;;  <span class="comment">// &#123;a: 2, b: 4&#125;</span></span><br></pre></td></tr></table></figure>

<p> 利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p>
<p> 需要注意：<strong>扩展运算符对对象实例的拷贝属于浅拷贝</strong>。</p>
</li>
<li><p>数组扩展运算符</p>
<p> 数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])<span class="comment">// 1 2 3console.log(...[1, [2, 3, 4], 5])// 1 [2, 3, 4] 5</span></span><br></pre></td></tr></table></figure>

<p> 下面是数组的扩展运算符的应用：</p>
<ul>
<li><p>将数组转换为参数序列</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;  <span class="keyword">return</span> x + y;&#125;<span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>];add(...numbers) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li><p>复制数组</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];<span class="keyword">const</span> arr2 = [...arr1];</span><br></pre></td></tr></table></figure>

<p>  要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p>
</li>
<li><p>合并数组</p>
<p>  如果想在数组内合并数组，可以这样：</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];<span class="keyword">const</span> arr2 = [<span class="string">&#x27;one&#x27;</span>, ...arr1, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>];<span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>扩展运算符和解构赋值结合起来，用于生成数组</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];      <span class="comment">// first  1rest  // [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>  需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [...rest, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];         <span class="comment">// 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错</span></span><br></pre></td></tr></table></figure></li>
<li><p>将字符串转为真正的数组</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]    <span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure></li>
<li><p>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</p>
<p>  比较常见的应用是可以将某些数据结构转为数组：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments对象function foo() &#123;  const args = [...arguments];&#125;</span></span><br></pre></td></tr></table></figure>

<p>  用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p>
</li>
<li><p>使用 Math 函数获取数组中特定的值</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>];<span class="built_in">Math</span>.min(...numbers); <span class="comment">// 1Math.max(...numbers); // 9</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="7-Proxy-可以实现什么功能？"><a href="#7-Proxy-可以实现什么功能？" class="headerlink" title="7. Proxy 可以实现什么功能？"></a>7. Proxy 可以实现什么功能？</h3><p>在 Vue3.0 中通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</p>
<p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)复制代码</span><br></pre></td></tr></table></figure>

<p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p>
<p>下面来通过 <code>Proxy</code> 来实现一个数据响应式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;  <span class="keyword">let</span> handler = &#123;    <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;      getLogger(target, property)      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)    &#125;,    <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;      setBind(value, property)      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)    &#125;  &#125;  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)&#125;<span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;<span class="keyword">let</span> p = onWatch(  obj,  <span class="function">(<span class="params">v, property</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">`监听到属性<span class="subst">$&#123;property&#125;</span>改变为<span class="subst">$&#123;v&#125;</span>`</span>)  &#125;,  <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">`&#x27;<span class="subst">$&#123;property&#125;</span>&#x27; = <span class="subst">$&#123;target[property]&#125;</span>`</span>)  &#125;)p.a = <span class="number">2</span> <span class="comment">// 监听到属性a改变p.a // &#x27;a&#x27; = 2</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，通过自定义 <code>set</code> 和 <code>get</code> 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p>
<p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 <code>get</code> 中收集依赖，在 <code>set</code> 派发更新，之所以 Vue3.0 要使用 <code>Proxy</code> 替换原本的 API 原因在于 <code>Proxy</code> 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 <code>Proxy</code> 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p>
<p><strong>常用拦截方法</strong>：</p>
<table>
<thead>
<tr>
<th align="center">拦截器</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get</td>
<td align="center">拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">拦截对象属性的设置，返回一个布尔值，比如 proxy.foo = v 或 proxy[‘foo’] = v</td>
</tr>
<tr>
<td align="center">has</td>
<td align="center">拦截 propKey in proxy 的操作，返回一个布尔值</td>
</tr>
<tr>
<td align="center">ownKeys</td>
<td align="center">拦截 Object.getOwnPropertyNames(proxy) 、Object.getOwnPropertySymbols(proxy) 、Object.keys(proxy) 、for…in 循环，返回一个数组</td>
</tr>
<tr>
<td align="center">deleteProperty</td>
<td align="center">拦截 delete proxy[propKey] 的操作，返回一个布尔值</td>
</tr>
<tr>
<td align="center">apply</td>
<td align="center">拦截函数的调用、call 和 apply 操作</td>
</tr>
<tr>
<td align="center">construct</td>
<td align="center">拦截 new 命令，返回一个对象</td>
</tr>
</tbody></table>
<h3 id="8-对对象与数组的解构的理解"><a href="#8-对对象与数组的解构的理解" class="headerlink" title="8. 对对象与数组的解构的理解"></a>8. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。</p>
<ol>
<li><p>数组的解构：在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p> 最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：  数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p> 通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量</p>
</li>
<li><p>对象的解构：对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stu = &#123;  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,  <span class="attr">age</span>: <span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure>

<p> 假如想要解构它的两个自有属性，可以这样：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = stu</span><br></pre></td></tr></table></figure>

<p> 这样就得到了 name 和 age 两个和 stu 平级的变量</p>
<p> 注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; age, name &#125; = stu</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-如何提取高度嵌套的对象里的指定属性？"><a href="#9-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="9. 如何提取高度嵌套的对象里的指定属性？"></a>9. 如何提取高度嵌套的对象里的指定属性？</h3><p>有时会遇到一些嵌套程度非常深的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;   <span class="attr">classes</span>: &#123;      <span class="attr">stu</span>: &#123;         <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,         <span class="attr">age</span>: <span class="number">24</span>,      &#125;   &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name &#125; = school</span><br></pre></td></tr></table></figure>

<p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; classes &#125; = schoolconst &#123; stu &#125; = classesconst &#123; name &#125; = stuname <span class="comment">// &#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">classes</span>: &#123; <span class="attr">stu</span>: &#123; name &#125; &#125;&#125; = school       <span class="built_in">console</span>.log(name)  <span class="comment">// &#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p>
<h3 id="10-对-rest-参数的理解"><a href="#10-对-rest-参数的理解" class="headerlink" title="10. 对 rest 参数的理解"></a>10. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>(<span class="params">...args</span>) </span>&#123;  <span class="keyword">let</span> result = <span class="number">1</span>;  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> args) &#123;    result *= val;  &#125;  <span class="keyword">return</span> result;&#125;mutiple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>(<span class="params">...args</span>) </span>&#123;  <span class="built_in">console</span>.log(args)&#125;mutiple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p>
<h3 id="11-ES6中模板语法与字符串处理"><a href="#11-ES6中模板语法与字符串处理" class="headerlink" title="11. ES6中模板语法与字符串处理"></a>11. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   <span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> <span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]<span class="keyword">var</span> finalString = <span class="string">&#x27;my name is &#x27;</span> + name + <span class="string">&#x27;, I work as a &#x27;</span> + career + <span class="string">&#x27;, I love &#x27;</span> + hobby[<span class="number">0</span>] + <span class="string">&#x27; and &#x27;</span> + hobby[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   <span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> <span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]<span class="keyword">var</span> finalString = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, I work as a <span class="subst">$&#123;career&#125;</span> I love <span class="subst">$&#123;hobby[<span class="number">0</span>]&#125;</span> and <span class="subst">$&#123;hobby[<span class="number">1</span>]&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p>
<ul>
<li>  在模板字符串中，空格、缩进、换行都会被保留</li>
<li>  模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li>
</ul>
<p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="string">`	&lt;ul&gt;		&lt;li&gt;列表项1&lt;/li&gt;		&lt;li&gt;列表项2&lt;/li&gt;	&lt;/ul&gt;`</span>;<span class="built_in">console</span>.log(message); <span class="comment">// 正确输出，不存在报错</span></span><br></pre></td></tr></table></figure>

<p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;  <span class="keyword">const</span> finalString = <span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a+b&#125;</span>`</span>  <span class="built_in">console</span>.log(finalString)&#125;add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 输出 &#x27;1 + 2 = 3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p>
<ol>
<li><p><strong>存在性判定</strong>：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p>
<ul>
<li>  <strong>includes</strong>：判断字符串与子串的包含关系：</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> son = <span class="string">&#x27;haha&#x27;</span> <span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span>father.includes(son) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>startsWith</strong>：判断字符串是否以某个/某串字符开头：</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span>father.startsWith(<span class="string">&#x27;haha&#x27;</span>) <span class="comment">// falsefather.startsWith(&#x27;xixi&#x27;) // true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>endsWith</strong>：判断字符串是否以某个/某串字符结尾：</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span>  father.endsWith(<span class="string">&#x27;hehe&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceCode = <span class="string">&#x27;repeat for 3 times;&#x27;</span><span class="keyword">const</span> repeated = sourceCode.repeat(<span class="number">3</span>) <span class="built_in">console</span>.log(repeated) <span class="comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p>
<p>（1）首先创建了一个新的空对象</p>
<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p>
<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>
<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<p>具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title">constructor</span> = <span class="title">Array</span>.<span class="title">prototype</span>.<span class="title">shift</span>.<span class="title">call</span>(<span class="params"><span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title">constructor</span> !== &quot;<span class="title">function</span>&quot;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="built_in">Object</span>.create(<span class="title">constructor</span>.<span class="title">prototype</span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">newObject, <span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>

<h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>意外的键</td>
<td>Map 默认情况不包含任何的键</td>
<td>Object 有一个原型，原型链上的键名有可能和自己在对象上设置的键名产生冲突</td>
</tr>
<tr>
<td>键的类型</td>
<td>Map 的键可以是任意值，包括函数、对象或任意基本类型</td>
<td>Object 的键必须是 String 或是 Symbol</td>
</tr>
<tr>
<td>键的顺序</td>
<td>Map 中的 key 是有序的。因此，当迭代的时候，Map 对象以插入的顺序返回键值</td>
<td>Object 的键是无序的</td>
</tr>
<tr>
<td>Size</td>
<td>Map 的键值对个数可以轻易地通过 size 属性获取</td>
<td>Object 的键值对个数只能手动计算</td>
</tr>
<tr>
<td>迭代</td>
<td>Map 是 iterable 的，所以可以直接被迭代</td>
<td>迭代 Object 需要以某种方式获取它的键然后才能迭代</td>
</tr>
<tr>
<td>性能</td>
<td>在频繁增删键值对的场景下表现更好</td>
<td>在频繁添加和删除键值对的场景下未做出优化</td>
</tr>
</tbody></table>
<h3 id="3-map和weakMap的区别"><a href="#3-map和weakMap的区别" class="headerlink" title="3. map和weakMap的区别"></a>3. map和weakMap的区别</h3><ol>
<li><p>Map</p>
<ul>
<li><p>  map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。</p>
</li>
<li><p>Map数据结构有以下操作方法：</p>
<ul>
<li>  <strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li>
<li>  **set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li>
<li>  **get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>  **has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li>
<li>  **delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li>
<li>  **clear()**：map.clear()清除所有成员，没有返回值。</li>
</ul>
</li>
<li><p>Map结构原生提供是三个遍历器生成函数和一个遍历方法</p>
<ul>
<li>  keys()：返回键名的遍历器。</li>
<li>  values()：返回键值的遍历器。</li>
<li>  entries()：返回所有成员的遍历器。</li>
<li>  forEach()：遍历Map的所有成员。</li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">     [<span class="string">&quot;foo&quot;</span>,<span class="number">1</span>],</span><br><span class="line">     [<span class="string">&quot;bar&quot;</span>,<span class="number">2</span>],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> map.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);  <span class="comment">// foo bar</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> map.values())&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(value); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> items <span class="keyword">of</span> map.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(items);  <span class="comment">// [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span></span><br><span class="line">&#125;</span><br><span class="line">map.forEach( <span class="function">(<span class="params">value,key,map</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(key,value); <span class="comment">// foo 1    bar 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>WeakMap</p>
<ul>
<li><p>  WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。</p>
</li>
<li><p>该对象也有以下几种方法：</p>
<ul>
<li>  **set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li>
<li>  **get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>  **has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li>
<li>  **delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li>
</ul>
<p>  其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。</p>
</li>
<li><p>  WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</p>
</li>
<li><p>  而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。</p>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>  Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
<li>  WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
</li>
</ol>
<h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p>
<p><strong>标准内置对象的分类：</strong></p>
<ol>
<li> 值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</li>
<li> 函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</li>
<li> 基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</li>
<li> 数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</li>
<li> 字符串，用来表示和操作字符串的对象。例如 String、RegExp</li>
<li> 可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</li>
<li> 使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet</li>
<li> 矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等</li>
<li> 结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</li>
<li> 控制抽象对象 例如 Promise、Generator 等</li>
<li> 反射。例如 Reflect、Proxy</li>
<li> 国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</li>
<li> WebAssembly</li>
<li> 其他。例如 arguments</li>
</ol>
<p><strong>总结：</strong> js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p>
<h3 id="5-常用的正则表达式有哪些？"><a href="#5-常用的正则表达式有哪些？" class="headerlink" title="5. 常用的正则表达式有哪些？"></a>5. 常用的正则表达式有哪些？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;// （2）匹配日期，如 yyyy-mm-dd 格式var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;// （3）匹配 qq 号var regex = /^[1-9][0-9]&#123;4,10&#125;$/g;// （4）手机号码正则var regex = /^1[34578]\d&#123;9&#125;$/g;// （5）用户名正则var regex = /^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p>
<p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p>
<p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p>
<p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p>
<ul>
<li>  JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li>
<li>  JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li>
</ul>
<h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p>
<p>一般有以下几种方式：</p>
<ul>
<li>  <strong>defer 属性：</strong> 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li>
<li>  <strong>async 属性：</strong> 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li>
<li>  <strong>动态创建 DOM 方式：</strong> 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li>
<li>  <strong>使用 setTimeout 延迟方法：</strong> 设置一个定时器来延迟加载js脚本文件</li>
<li>  <strong>让 JS 最后加载：</strong> 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li>
</ul>
<h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p>
<p>常见的类数组对象转换为数组的方法有这样几种：</p>
<ol>
<li><p>通过 call 调用数组的 slice 方法来实现转换</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 call 调用数组的 splice 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 apply 调用数组的 concat 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 Array.from 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul>
<li>  数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li>
<li>  数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li>
<li>  数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li>
<li>  数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li>
<li>  数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li>
<li>  数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li>
<li>  数组归并方法 reduce() 和 reduceRight() 方法</li>
</ul>
<h3 id="10-Unicode、UTF-8、UTF-16、UTF-32的区别？"><a href="#10-Unicode、UTF-8、UTF-16、UTF-32的区别？" class="headerlink" title="10. Unicode、UTF-8、UTF-16、UTF-32的区别？"></a>10. Unicode、UTF-8、UTF-16、UTF-32的区别？</h3><ol>
<li><p>Unicode</p>
<p> 在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。</p>
<ul>
<li>  它是基于拉丁字母的一套电脑编码系统。</li>
<li>  它定义了一个用于代表常见字符的字典。</li>
<li>  它包含了”A-Z”(包含大小写)，数据”0-9” 以及一些常见的符号。</li>
<li>  它是专门为英语而设计的，有128个编码，对其他语言无能为力</li>
</ul>
<p> <code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。</p>
<p> <code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>
<p> <code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。</p>
</li>
<li><p>UTF-8</p>
<p> <code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。</p>
<p> <strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。</p>
<p> <code>UTF-8</code>的编码规则：</p>
<ul>
<li>  对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li>
<li>  对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li>
</ul>
<p> 具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：</p>
<table>
<thead>
<tr>
<th>编码范围（编号对应的十进制数）</th>
<th>二进制格式</th>
</tr>
</thead>
<tbody><tr>
<td>0x00—0x7F （0-127）</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0x80—0x7FF （128-2047）</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0x800—0xFFFF  （2048-65535）</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0x10000—0x10FFFF  （65536以上）</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p> 那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong></p>
<ul>
<li>  找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li>
<li>  将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li>
<li>  将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li>
</ul>
<p> 来看一个实际的例子： “<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code> </p>
<ol>
<li> 首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code></li>
<li> 39532对应的二进制数为<code>1001 1010 0110 1100</code> </li>
<li> 将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code></li>
</ol>
</li>
<li><p>UTF-16</p>
<ol>
<li><p>平面的概念</p>
<p> 在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念： <code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。</p>
<p> 最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 216-1</strong>，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是<strong>辅助平面</strong>，码点范围是 <code>U+10000—U+10FFFF</code>。</p>
</li>
<li><p>UTF-16 概念</p>
<p> <code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。</p>
</li>
<li><p>UTF-16 编码规则</p>
<ul>
<li>  编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li>
<li>  编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li>
</ul>
</li>
<li><p>编码识别</p>
<p> 那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？</p>
<p> <code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。</p>
<p> 辅助平面共有 <strong>220</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。</p>
<p> 因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。</p>
</li>
<li><p>举例说明</p>
<p> 以 “<strong>𡠀</strong>“ 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：</p>
<ul>
<li>  首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li>
<li>  将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li>
<li>  将得到的两个10位二进制数分别对应到两个区间中</li>
<li>  <code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li>
</ul>
</li>
</ol>
</li>
<li><p>UTF-32</p>
<p> <code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。</p>
<p> 比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。</p>
</li>
<li><p>总结</p>
<p> <strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong></p>
<ul>
<li>  <code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li>
<li>  <code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li>
<li>  <code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li>
<li>  如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间</li>
</ul>
</li>
</ol>
<h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>或</td>
</tr>
<tr>
<td><code>^</code></td>
<td>异或</td>
<td>两个位相同为0，相异为1</td>
</tr>
<tr>
<td><code>~</code></td>
<td>取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td>各二进制位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td>
</tr>
</tbody></table>
<ol>
<li><p>按位与运算符（&amp;）</p>
<p> <strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。 <strong>运算规则：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span>  <span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span>  <span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span>  <span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> 总结：两位同时为1，结果才为1，否则结果为0。 例如：3&amp;5 即：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span>    <span class="number">0000</span> <span class="number">0101</span>  = <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>

<p> 因此 3&amp;5 的值为1。 注意：负数按补码形式参加按位与运算。</p>
<p> <strong>用途：</strong></p>
<ol>
<li><p><strong>判断奇偶</strong></p>
<p> 只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p>
</li>
<li><p><strong>清零</strong></p>
<p> 如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p>
</li>
</ol>
</li>
<li><p>按位或运算符（|）</p>
<p> <strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p>
<p> <strong>运算规则：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">00</span> | <span class="number">1</span> = <span class="number">1</span>  <span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span>  <span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> 总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3|5即：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span>  <span class="number">0000</span> <span class="number">0101</span> = <span class="number">0000</span> <span class="number">0111</span></span><br></pre></td></tr></table></figure>

<p> 因此，3|5的值为7。 注意：负数按补码形式参加按位或运算。</p>
</li>
<li><p>异或运算符（^）</p>
<p> <strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p>
<p> <strong>运算规则：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span>  <span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span>  <span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span>  <span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p> 总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 例如：3|5即：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span>  <span class="number">0000</span> <span class="number">0101</span> = <span class="number">0000</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure>

<p> 因此，3^5的值为6。 异或运算的性质:</p>
<ul>
<li>  交换律：<code>(a^b)^c == a^(b^c)</code></li>
<li>  结合律：<code>(a + b)^c == a^b + b^c</code></li>
<li>  对于任何数x，都有 <code>x^x=0，x^0=x</code></li>
<li>  自反性: <code>a^b^b=a^0=a</code>;</li>
</ul>
</li>
<li><p>取反运算符 (~)</p>
<p> <strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p>
<p> <strong>运算规则：</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">~ <span class="number">1</span> = <span class="number">0</span>~ <span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> 总结：对一个二进制数按位取反，即将0变1，1变0。 例如：~6 即：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span>= <span class="number">1111</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<p> 在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。 当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span>   = <span class="number">1111</span> <span class="number">1001</span>反码：<span class="number">1000</span> <span class="number">0110</span>补码：<span class="number">1000</span> <span class="number">0111</span></span><br></pre></td></tr></table></figure>

<p> 因此，~6的值为-7。</p>
</li>
<li><p>左移运算符（&lt;&lt;）</p>
<p> <strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。 设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p>
</li>
<li><p>右移运算符（&gt;&gt;）</p>
<p> <strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 操作数每右移一位，相当于该数除以2。</p>
</li>
<li><p>原码、补码、反码</p>
<p> 上面提到了补码、反码等知识，这里就补充一下。 计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p>
<p> <strong>（1）原码</strong></p>
<p> 原码就是一个数的二进制数。例如：10的原码为0000 1010</p>
<p> <strong>（2）反码</strong></p>
<ul>
<li>  正数的反码与原码相同，如：10 反码为 0000 1010</li>
<li>  负数的反码为除符号位，按位取反，即0变1，1变0。</li>
</ul>
<p> 例如：-10</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span>反码：<span class="number">1111</span> <span class="number">0101</span></span><br></pre></td></tr></table></figure>

<p> <strong>（3）补码</strong></p>
<ul>
<li>  正数的补码与原码相同，如：10 补码为 0000 1010</li>
<li>  负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li>
</ul>
<p> 例如：-10</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span>反码：<span class="number">1111</span> <span class="number">0101</span>补码：<span class="number">1111</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p>
<p>要遍历类数组，有三个方法：</p>
<ol>
<li><p>将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用Array.from方法将类数组转化成数组：‌</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">const</span> arrArgs = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>) </span><br><span class="line">  arrArgs.forEach(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用展开运算符将类数组转化成数组</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">const</span> arrArgs = [...arguments] </span><br><span class="line">    arrArgs.forEach(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul>
<li>  DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li>
<li>  BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li>
</ul>
<h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p>
<p>常见的类数组对象转换为数组的方法有这样几种：</p>
<ol>
<li><p>通过 call 调用数组的 slice 方法来实现转换</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 call 调用数组的 splice 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 apply 调用数组的 concat 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 Array.from 方法来实现转换</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="15-escape、encodeURI、encodeURIComponent-的区别"><a href="#15-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="15. escape、encodeURI、encodeURIComponent 的区别"></a>15. escape、encodeURI、encodeURIComponent 的区别</h3><ol>
<li><p>escape</p>
<p>  从名字来判断就知道，escape和后面的不是一伙的，因此不容易和后两者混淆，单独记住它就行了。</p>
<p>  简单来说，escape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。其中 ASCII字母  数字  @*/+   这几个字符不会被编码，其余的都会。最关键的是，当你需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。</p>
<p>  用MDN的话说就是：</p>
<blockquote>
<p>  escape 函数是全局对象的属性。特色字符如: @*_+-./ 被排除在外。字符的16进制格式值,当该值小于等于0xFF时,用一个2位转移序列: %xx 表示. 大于的话则使用4位序列:%uxxxx 表示.</p>
</blockquote>
</li>
<li><p>encodeURI和encodeURIComponent</p>
<p>  如果需要对整个uri编码则用encodeURI,如果对uri的部分编码则用encodeURIComponent</p>
<p>  下面来解释一下：</p>
<p>  它们都是编码URI，唯一区别就是编码的字符范围，其中encodeURI方法不会对下列字符编码：  ASCII字母，数字，~!@#$&amp;<em>()=:/,;?+’ ，encodeURIComponent方法不会对下列字符编码 ASCII字母，数字， ~!</em>()’，所以encodeURIComponent比encodeURI编码的范围更大。实际例子来说：</p>
<blockquote>
<p>  encodeURIComponent会把 http://  编码成  http%3A%2F%2F 而encodeURI却不会。</p>
</blockquote>
<p>  所以使用了encodeURIComponent编码后的地址都不能被正常访问，所以此时要用encodeURI编码，而上面时候要用到encodeURIComponent呢，知道GET和POST网络请求方法的话就好理解了，当使用GET请求时，后面需要传入parms，这里的parms也是uri的一部分，但uri对字符的输入有要求，因此要用encodeURIComponent编码后再添加到uri里面去，这样就能让浏览器正确解释出屋面想传入的params。</p>
</li>
<li><p>举例</p>
<ol>
<li><p> 如果只是编码字符串，不和URL有半毛钱关系，那么用escape。</p>
</li>
<li><p>如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。</p>
<p> 比如</p>
<p> encodeURI(“<a href="https://link.juejin.cn/?target=http://www.cnblogs.com/season-huang/some">www.cnblogs.com/season-huan…</a> other thing”);编码后会变为</p>
<p> “<a href="https://link.juejin.cn/?target=http://www.cnblogs.com/season-huang/some%20other%20thing">www.cnblogs.com/season-huan…</a>“;</p>
<p> 其中，空格被编码成了%20。但是如果你用了encodeURIComponent，那么结果变为</p>
<p> “http%3A%2F%2F<a href="http://www.cnblogs.com%2Fseason-huang%2Fsome%20other%20thing&quot;">www.cnblogs.com%2Fseason-huang%2Fsome%20other%20thing&quot;</a></p>
<p> 看到了区别吗，连 “/“ 都被编码了，整个URL已经没法用了。</p>
</li>
<li><p>当你需要编码URL中的参数的时候，那么encodeURIComponent是最好方法。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> param = <span class="string">&quot;http://www.cnblogs.com/season-huang/&quot;</span>; <span class="comment">//param为参数param = encodeURIComponent(param);var url = &quot;http://www.cnblogs.com?next=&quot; + param;console.log(url) //&quot;http://www.cnblogs.com?next=http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2F&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>创建AJAX请求的步骤：</p>
<ul>
<li>  <strong>创建一个 XMLHttpRequest 对象。</strong></li>
<li>  在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>  在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li>
<li>  当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_URL = <span class="string">&quot;/server&quot;</span>;<span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();<span class="comment">// 创建 Http 请求xhr.open(&quot;GET&quot;, url, true);// 设置状态监听函数xhr.onreadystatechange = function() &#123;  if (this.readyState !== 4) return;  // 当请求成功时  if (this.status === 200) &#123;    handle(this.response);  &#125; else &#123;    console.error(this.statusText);  &#125;&#125;;// 设置请求失败时的监听函数xhr.onerror = function() &#123;  console.error(this.statusText);&#125;;// 设置请求头信息xhr.responseType = &quot;json&quot;;xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);// 发送 Http 请求xhr.send(null);const SERVER_URL = &quot;/server&quot;;let xhr = new XMLHttpRequest();// 创建 Http 请求xhr.open(&quot;GET&quot;, url, true);// 设置状态监听函数xhr.onreadystatechange = function() &#123;  if (this.readyState !== 4) return;  // 当请求成功时  if (this.status === 200) &#123;    handle(this.response);  &#125; else &#123;    console.error(this.statusText);  &#125;&#125;;// 设置请求失败时的监听函数xhr.onerror = function() &#123;  console.error(this.statusText);&#125;;// 设置请求头信息xhr.responseType = &quot;json&quot;;xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);// 发送 Http 请求xhr.send(null);</span></span><br></pre></td></tr></table></figure>

<p>使用Promise封装AJAX：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise 封装实现：function getJSON(url) &#123;  // 创建一个 promise 对象  let promise = new Promise(function(resolve, reject) &#123;    let xhr = new XMLHttpRequest();    // 新建一个 http 请求    xhr.open(&quot;GET&quot;, url, true);    // 设置状态的监听函数    xhr.onreadystatechange = function() &#123;      if (this.readyState !== 4) return;      // 当请求成功或失败时，改变 promise 的状态      if (this.status === 200) &#123;        resolve(this.response);      &#125; else &#123;        reject(new Error(this.statusText));      &#125;    &#125;;    // 设置错误监听函数    xhr.onerror = function() &#123;      reject(new Error(this.statusText));    &#125;;    // 设置响应的数据类型    xhr.responseType = &quot;json&quot;;    // 设置请求头信息    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);    // 发送 http 请求    xhr.send(null);  &#125;);  return promise;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p>
<p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p>
<p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p>
<ul>
<li><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。<ul>
<li>  全局上下文：变量定义，函数声明</li>
<li>  函数上下文：变量定义，函数声明，this，arguments</li>
</ul>
</li>
<li>  <strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</li>
</ul>
<p>那为什么会进行变量提升呢？主要有以下两个原因：</p>
<ol>
<li><p>提高性能</p>
<p> 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p>
<p> 在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p>
</li>
<li><p>容错性更好</p>
<p> 变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;<span class="keyword">var</span> a;<span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p> 如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p>
<p> 虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>  解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li>
<li>  声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li>
</ul>
<p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;	<span class="built_in">console</span>.log(tmp);	<span class="keyword">if</span>(<span class="literal">false</span>)&#123;		<span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;	&#125;&#125;fn();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;	<span class="built_in">console</span>.log(tmp[i]);&#125;<span class="built_in">console</span>.log(i); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p>
<h3 id="18-什么是尾调用，使用尾调用有什么好处？"><a href="#18-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="18. 什么是尾调用，使用尾调用有什么好处？"></a>18. 什么是尾调用，使用尾调用有什么好处？</h3><p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19. ES6模块与CommonJS模块有什么异同？"></a>19. ES6模块与CommonJS模块有什么异同？</h3><p>参考：<a href="https://juejin.cn/post/6844904145443356680#heading-24">https://juejin.cn/post/6844904145443356680#heading-24</a></p>
<ul>
<li>  CommonJS模块是运行时加载，ES6 Modules是编译时输出接口</li>
<li>  CommonJS输出是值的浅拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li>
<li>  CommonJs导入的模块路径可以是一个表达式，因为它使用的是<code>require()</code>方法；而ES6 Modules只能是字符串</li>
<li>  CommonJS <code>this</code>指向当前模块，ES6 Modules <code>this</code>指向<code>undefined</code></li>
<li>  且ES6 Modules中没有这些顶层变量：<code>arguments</code>、<code>require</code>、<code>module</code>、<code>exports</code>、<code>__filename</code>、<code>__dirname</code></li>
</ul>
<p>关于第一个差异，是因为CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<h3 id="20-常见的DOM操作有哪些"><a href="#20-常见的DOM操作有哪些" class="headerlink" title="20. 常见的DOM操作有哪些"></a>20. 常见的DOM操作有哪些</h3><ol>
<li><p>DOM 节点的获取</p>
<p> DOM 节点的获取的API及使用：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getElementById <span class="comment">// 按照 id 查询</span></span><br><span class="line">getElementsByTagName <span class="comment">// 按照标签名查询</span></span><br><span class="line">getElementsByClassName <span class="comment">// 按照类名查询</span></span><br><span class="line">querySelectorAll <span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照 id 查询</span></span><br><span class="line"><span class="keyword">var</span> imooc = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;imooc&#x27;</span>) <span class="comment">// 查询到 id 为 imooc 的元素</span></span><br><span class="line"><span class="comment">// 按照标签名查询</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)  <span class="comment">// 查询到标签为 p 的集合</span></span><br><span class="line"><span class="built_in">console</span>.log(divList.length)</span><br><span class="line"><span class="built_in">console</span>.log(divList[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 按照类名查询</span></span><br><span class="line"><span class="keyword">var</span> moocList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;mooc&#x27;</span>) <span class="comment">// 查询到类名为 mooc 的集合</span></span><br><span class="line"><span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.mooc&#x27;</span>) <span class="comment">// 查询到类名为 mooc 的集合</span></span><br></pre></td></tr></table></figure></li>
<li><p>DOM 节点的创建</p>
<p> <strong>创建一个新节点，并把它添加到指定节点的后面。</strong> 已知的 HTML 结构如下：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p> 要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先获取父节点</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line"><span class="keyword">var</span> targetSpan = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line"><span class="comment">// 设置 span 节点的内容</span></span><br><span class="line">targetSpan.innerHTML = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment">// 把新创建的元素塞进父节点里去</span></span><br><span class="line">container.appendChild(targetSpan)</span><br></pre></td></tr></table></figure></li>
<li><p>DOM 节点的删除</p>
<p> <strong>删除指定的 DOM 节点，</strong> 已知的 HTML 结构如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;  <span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span>  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span>       <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>     <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span>&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p> 需要删除 id 为 title 的元素，做法是：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素的父元素var container = document.getElementById(&#x27;container&#x27;)// 获取目标元素var targetNode = document.getElementById(&#x27;title&#x27;)// 删除目标元素container.removeChild(targetNode)</span></span><br></pre></td></tr></table></figure>

<p> 或者通过子节点数组来完成删除：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素的父元素var container = document.getElementById(&#x27;container&#x27;)// 获取目标元素var targetNode = container.childNodes[1]// 删除目标元素container.removeChild(targetNode)</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改 DOM 元素</p>
<p> 修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。</p>
<p> <strong>将指定的两个 DOM 元素交换位置，</strong> 已知的 HTML 结构如下：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;  <span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span>  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span>       <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>     <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span>&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p> 现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取父元素var container = document.getElementById(&#x27;container&#x27;)    // 获取两个需要被交换的元素var title = document.getElementById(&#x27;title&#x27;)var content = document.getElementById(&#x27;content&#x27;)// 交换两个元素，把 content 置于 title 前面container.insertBefore(content, title)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="21-use-strict是什么意思-使用它区别是什么？"><a href="#21-use-strict是什么意思-使用它区别是什么？" class="headerlink" title="21. use strict是什么意思 ? 使用它区别是什么？"></a>21. use strict是什么意思 ? 使用它区别是什么？</h3><p>use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：</p>
<ul>
<li>  消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li>
<li>  消除代码运行的不安全之处，保证代码运行的安全；</li>
<li>  提高编译器效率，增加运行速度；</li>
<li>  为未来新版本的 Javascript 做好铺垫。</li>
</ul>
<p>严格模式的规范：<a href="https://juejin.cn/post/6844904120214618120#heading-4">https://juejin.cn/post/6844904120214618120#heading-4</a></p>
<ol>
<li>变量<ul>
<li>  不允许意外创建全局变量</li>
<li>  不能使用 <code>delete</code> 操作符删除声明变量</li>
<li>  不用使用保留字（例如 ：implements、interface、let、package、 private、protected、public、static 和 yield 标识符）作为变量名</li>
</ul>
</li>
<li>对象<ul>
<li>  为只读属性赋值会抛出TypeError</li>
<li>  对不可配置的（nonconfigurable）的属性使用 delete 操作符会抛出TypeError</li>
<li>  为不可扩展的（nonextensible）的对象添加属性会抛出TypeError</li>
<li>  使用对象字面量时, 属性名必须唯一</li>
</ul>
</li>
<li>函数<ul>
<li>  要求命名函数的参数必须唯一</li>
</ul>
</li>
<li>eval 和 arguments<ul>
<li>  eval不在为上下文中创建变量或函数</li>
<li>  eval 和 arguments 不能通过程序语法被绑定(be bound)或赋值</li>
<li>  参数的值不会随 arguments 对象的值的改变而变化</li>
<li>  禁止使用arguments.callee</li>
</ul>
</li>
<li> 禁止在函数内部遍历调用栈</li>
<li>静态绑定<ul>
<li>  禁止使用with语句</li>
<li>  eval()声明变量和函数只能当前eval内部的作用域中有效</li>
</ul>
</li>
<li>this 指向<ul>
<li>  全局作用域的函数中的this不再指向全局而是undefined。</li>
<li>  如果使用构造函数时，如果忘了加new，this不再指向全局对象，而是undefined报错</li>
</ul>
</li>
</ol>
<h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><p>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<p>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p>
<p>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</p>
<h3 id="23-强类型语言和弱类型语言的区别"><a href="#23-强类型语言和弱类型语言的区别" class="headerlink" title="23. 强类型语言和弱类型语言的区别"></a>23. 强类型语言和弱类型语言的区别</h3><ul>
<li>  <strong>强类型语言</strong>：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。</li>
<li>  <strong>弱类型语言</strong>：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串’12’和整数3进行连接得到字符串’123’，在相加的时候会进行强制类型转换。</li>
</ul>
<p>两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。</p>
<h3 id="24-解释性语言和编译型语言的区别"><a href="#24-解释性语言和编译型语言的区别" class="headerlink" title="24. 解释性语言和编译型语言的区别"></a>24. 解释性语言和编译型语言的区别</h3><ol>
<li>解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下<ul>
<li>  解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li>
<li>  只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li>
<li>  JavaScript、Python等属于解释型语言。</li>
</ul>
</li>
<li>编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：<ul>
<li>  一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li>
<li>  与特定平台相关，一般无法移植到其他平台；</li>
<li>  C、C++等属于编译型语言。</li>
</ul>
</li>
</ol>
<p><strong>两者主要区别在于：</strong> 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p>
<h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下：</p>
<ul>
<li>  for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li>
<li>  for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li>
<li>  对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li>
</ul>
<p><strong>总结：</strong> for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p>
<h3 id="26-如何使用for…of遍历对象"><a href="#26-如何使用for…of遍历对象" class="headerlink" title="26. 如何使用for…of遍历对象"></a>26. 如何使用for…of遍历对象</h3><p>for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。</p>
<p>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;    <span class="number">0</span>:<span class="string">&#x27;one&#x27;</span>,    <span class="number">1</span>:<span class="string">&#x27;two&#x27;</span>,    <span class="attr">length</span>: <span class="number">2</span>&#125;;obj = <span class="built_in">Array</span>.from(obj);<span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> obj)&#123;    <span class="built_in">console</span>.log(k)&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：var obj = &#123;    a:1,    b:2,    c:3&#125;;obj[Symbol.iterator] = function()&#123;	var keys = Object.keys(this);	var count = 0;	return &#123;		next()&#123;			if(count&lt;keys.length)&#123;				return &#123;value: obj[keys[count++]],done:false&#125;;			&#125;else&#123;				return &#123;value:undefined,done:true&#125;;			&#125;		&#125;	&#125;&#125;;for(var k of obj)&#123;	console.log(k);&#125;// 方法二var obj = &#123;    a:1,    b:2,    c:3&#125;;obj[Symbol.iterator] = function*()&#123;    var keys = Object.keys(obj);    for(var k of keys)&#123;        yield [k,obj[k]]    &#125;&#125;;for(var [k,v] of obj)&#123;    console.log(k,v);&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="27-ajax、axios、fetch的区别"><a href="#27-ajax、axios、fetch的区别" class="headerlink" title="27. ajax、axios、fetch的区别"></a>27. ajax、axios、fetch的区别</h3><ol>
<li><p><strong>AJAX</strong> Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：</p>
<ul>
<li>  本身是针对MVC编程，不符合前端MVVM的浪潮</li>
<li>  基于原生XHR开发，XHR本身的架构不清晰</li>
<li>  不符合关注分离（Separation of Concerns）的原则</li>
<li>  配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li>
</ul>
</li>
<li><p><strong>Fetch</strong> fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</p>
<p> fetch的优点：</p>
<ul>
<li>  语法简洁，更加语义化</li>
<li>  基于标准 Promise 实现，支持 async/await</li>
<li>  更加底层，提供的API丰富（request, response）</li>
<li>  脱离了XHR，是ES规范里新的实现方式</li>
</ul>
<p> fetch的缺点：</p>
<ul>
<li>  fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li>
<li>  fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li>
<li>  fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li>
<li>  fetch没有办法原生监测请求的进度，而XHR可以</li>
</ul>
</li>
<li><p><strong>Axios</strong> Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</p>
<ul>
<li>  浏览器端发起XMLHttpRequests请求</li>
<li>  node端发起http请求</li>
<li>  支持Promise API</li>
<li>  监听请求和返回</li>
<li>  对请求和返回进行转化</li>
<li>  取消请求</li>
<li>  自动转换json数据</li>
<li>  客户端支持抵御XSRF攻击</li>
</ul>
</li>
</ol>
<h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><p><a href="https://cuggz.blog.csdn.net/article/details/107649549">https://cuggz.blog.csdn.net/article/details/107649549</a></p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>是否改变原数组</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>forEach()</td>
<td>否</td>
<td>数组方法，不改变原数组，没有返回值</td>
</tr>
<tr>
<td>map()</td>
<td>否</td>
<td>数组方法，不改变原数组，有返回值，可链式调用</td>
</tr>
<tr>
<td>filter()</td>
<td>否</td>
<td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td>
</tr>
<tr>
<td>for…of</td>
<td>否</td>
<td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td>
</tr>
<tr>
<td>every() 和 some()</td>
<td>否</td>
<td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td>
</tr>
<tr>
<td>find() 和 findIndex()</td>
<td>否</td>
<td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td>
</tr>
<tr>
<td>reduce() 和 reduceRight()</td>
<td>否</td>
<td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td>
</tr>
</tbody></table>
<h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p>
<ul>
<li>  forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li>
<li>  map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li>
</ul>
<h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p>
<p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p>
<p><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p>
<p>参考：<a href="https://juejin.cn/post/6934498361475072014%EF%BC%8Chttps://juejin.cn/post/6844903989088092174#heading-1">https://juejin.cn/post/6934498361475072014，https://juejin.cn/post/6844903989088092174#heading-1</a></p>
<p><img src="/2021/12/06/javascript/03-4-1.JPG"></p>
<p><img src="/../../../Desktop/%E9%9D%A2%E8%AF%95/pic/03/03-4-1-2.png"></p>
<h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">p.constructor = Person</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.__proto__  <span class="comment">// Person.prototype</span></span><br><span class="line">Person.prototype.__proto__  <span class="comment">// Object.prototype</span></span><br><span class="line">p.__proto__.__proto__ <span class="comment">//Object.prototype</span></span><br><span class="line">p.__proto__.constructor.prototype.__proto__ <span class="comment">// Object.prototype</span></span><br><span class="line">Person.prototype.constructor.prototype.__proto__ <span class="comment">// Object.prototype</span></span><br><span class="line">p1.__proto__.constructor <span class="comment">// Person</span></span><br><span class="line">Person.prototype.constructor  <span class="comment">// Person</span></span><br></pre></td></tr></table></figure>

<h3 id="4-原型链的终点是什么？如何打印出原型链的终点？"><a href="#4-原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="4. 原型链的终点是什么？如何打印出原型链的终点？"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h3><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。</p>
<h3 id="5-如何获得对象非原型链上的属性？"><a href="#5-如何获得对象非原型链上的属性？" class="headerlink" title="5. 如何获得对象非原型链上的属性？"></a>5. 如何获得对象非原型链上的属性？</h3><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> res=[];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))</span><br><span class="line">           res.push(key+<span class="string">&#x27;: &#x27;</span>+obj[key]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="五、执行上下文-作用域链-闭包"><a href="#五、执行上下文-作用域链-闭包" class="headerlink" title="五、执行上下文/作用域链/闭包"></a>五、执行上下文/作用域链/闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p>
<p>闭包有两个常用的用途；</p>
<ul>
<li>  闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li>
<li>  闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li>
</ul>
<p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p>
<ol>
<li><p>第一种是使用闭包的方式</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;      ;(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;            <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;                  <span class="built_in">console</span>.log(j)            &#125;, j * <span class="number">1000</span>)      &#125;)(i)&#125;</span><br></pre></td></tr></table></figure>

<p> 在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p>
</li>
<li><p>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;  <span class="built_in">setTimeout</span>(    <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;      <span class="built_in">console</span>.log(j)    &#125;,    i * <span class="number">1000</span>,    i  )&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(i)  &#125;, i * <span class="number">1000</span>)&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><ol>
<li>全局作用域和函数作用域<ol>
<li>全局作用域<ul>
<li>  最外层函数和最外层函数外面定义的变量拥有全局作用域</li>
<li>  所有未定义直接赋值的变量自动声明为全局作用域</li>
<li>  所有window对象的属性拥有全局作用域</li>
<li>  全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li>
</ul>
</li>
<li>函数作用域<ul>
<li>  函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>
<li>  作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>
</ul>
</li>
</ol>
</li>
<li>块级作用域<ul>
<li>  使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li>
<li>  let和const声明的变量不会有变量提升，也不可以重复声明</li>
<li>  在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>
</ul>
</li>
</ol>
<p><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p>
<p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p>
<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>
<p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p>
<h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><ol>
<li><p>执行上下文类型</p>
<ul>
<li><p>全局执行上下文</p>
<p>  任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p>
</li>
<li><p>函数执行上下文</p>
<p>  当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p>
</li>
<li><p><code>eval</code> 函数执行上下文</p>
<p>  执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p>
</li>
</ul>
</li>
<li><p>执行上下文栈</p>
<ul>
<li>  JavaScript引擎使用执行上下文栈来管理执行上下文</li>
<li>  当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;<span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&#x27;Inside first function&#x27;</span>);  second();  <span class="built_in">console</span>.log(<span class="string">&#x27;Again inside first function&#x27;</span>);&#125;<span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&#x27;Inside second function&#x27;</span>);&#125;first();<span class="comment">//执行顺序//先执行second(),在执行first()</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建执行上下文</p>
<p> 创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p>
<ol>
<li>创建阶段<ol>
<li>this 绑定<ul>
<li>  在全局执行上下文中，this指向全局对象（window对象）</li>
<li>  在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li>
</ul>
</li>
<li>创建词法环境组件<ul>
<li>  词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。</li>
<li>  词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li>
</ul>
</li>
<li>创建变量环境组件<ul>
<li>  变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li>
</ul>
</li>
</ol>
</li>
<li> 执行阶段  此阶段会完成对变量的分配，最后执行完代码。</li>
</ol>
</li>
</ol>
<p><strong>简单来说执行上下文就是指：</strong></p>
<p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p>
<p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p>
<ul>
<li>  全局上下文：变量定义，函数声明</li>
<li>  函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li>
</ul>
<h2 id="六、this-call-apply-bind"><a href="#六、this-call-apply-bind" class="headerlink" title="六、this/call/apply/bind"></a>六、this/call/apply/bind</h2><h3 id="1-对-this-对象的理解"><a href="#1-对-this-对象的理解" class="headerlink" title="1. 对 this 对象的理解"></a>1. 对 this 对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>
<ul>
<li>  第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li>
<li>  第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>
<li>  第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>
<li>  第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>
</ul>
<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>
<h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p>
<ul>
<li>  apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li>
<li>  call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li>
</ul>
<h3 id="3-实现-call、apply-及-bind-函数"><a href="#3-实现-call、apply-及-bind-函数" class="headerlink" title="3. 实现 call、apply 及 bind 函数"></a>3. 实现 call、apply 及 bind 函数</h3><ol>
<li><p>call</p>
<ul>
<li>  判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>  判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>  处理传入的参数，截取第一个参数后的所有参数。</li>
<li>  将函数作为上下文对象的一个属性。</li>
<li>  使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>  删除刚才新增的属性。</li>
<li>  返回结果。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.fn(...args);</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>apply</p>
<ul>
<li>  判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>  判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>  将函数作为上下文对象的一个属性。</li>
<li>  判断参数值是否传入</li>
<li>  使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>  删除刚才新增的属性</li>
<li>  返回结果</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>bind</p>
<ul>
<li>  判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>  保存当前函数的引用，获取其余传入参数值。</li>
<li>  创建一个函数返回</li>
<li>  函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(</span><br><span class="line">      <span class="built_in">this</span> <span class="keyword">instanceof</span> Fn ? <span class="built_in">this</span> : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</p>
<p><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</p>
<p><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</p>
<p><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</p>
<h3 id="2-setTimeout、Promise、Async-Await-的区别"><a href="#2-setTimeout、Promise、Async-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async/Await 的区别"></a>2. setTimeout、Promise、Async/Await 的区别</h3><p>参考：<a href="https://juejin.cn/post/6844903999108284430">https://juejin.cn/post/6844903999108284430</a></p>
<ol>
<li><p>seTimeout</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)	<span class="comment">//1. 打印 script start</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)	<span class="comment">// 4. 打印 settimeout</span></span><br><span class="line">&#125;)	<span class="comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)	<span class="comment">//3. 打印 script start</span></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br></pre></td></tr></table></figure></li>
<li><p>Promise</p>
<p> Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p> 当JS主线程执行到Promise对象时：</p>
<ul>
<li>  promise1.then() 的回调就是一个 task</li>
<li>  promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>  promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li>  setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>
</ul>
</li>
<li><p>async/await</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sync <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p> async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>
<p> await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p>
</li>
</ol>
<h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<ol>
<li><p>Promise的实例有<strong>三个状态</strong>:</p>
<ul>
<li>  Pending（进行中）</li>
<li>  Resolved（已完成）</li>
<li>  Rejected（已拒绝）</li>
</ul>
<p> 当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p>
</li>
<li><p>Promise的实例有<strong>两个过程</strong>：</p>
<ul>
<li>  pending -&gt; fulfilled : Resolved（已完成）</li>
<li>  pending -&gt; rejected：Rejected（已拒绝）</li>
</ul>
<p> 注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p>
</li>
</ol>
<p><strong>Promise的特点：</strong></p>
<ul>
<li>  对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li>
<li>  一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li>
</ul>
<p><strong>Promise的缺点：</strong></p>
<ul>
<li>  无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>  如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>  当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<p><strong>总结：</strong> Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p>
<p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p>
<p><strong>注意：</strong> 在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p>
<h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><ol>
<li><p>创建 Promise 对象</p>
<p> Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p>
<p> Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> <strong>一般情况下都会使用</strong><code>new Promise()</code><strong>来创建promise对象，但是也可以使用</strong><code>promise.resolve</code><strong>和</strong><code>promise.reject</code><strong>这两个方法：</strong></p>
<ul>
<li><p><strong>Promise.resolve</strong></p>
<p>  <code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">11</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 打印出11</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  <code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p>
<p>  创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p>
</li>
<li><p><strong>Promise.reject</strong></p>
<p>  <code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(“我错了，请原谅俺！！”));</span><br></pre></td></tr></table></figure>

<p>  就是下面的代码new Promise的简单形式：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">   reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;我错了！&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  下面是使用resolve方法和reject方法：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testPromise</span>(<span class="params">ready</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">      resolve(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">&quot;No thanks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line">testPromise(<span class="literal">true</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p>
</li>
</ul>
</li>
<li><p>Promise 方法</p>
<p> Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p>
<ol>
<li><p><strong>then()</strong></p>
<p> 当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> <code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。 <code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p>
<p> 当要写有顺序的异步事件时，需要串行时，可以这样写：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    ajax(<span class="string">&#x27;first&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        resolve(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        ajax(<span class="string">&#x27;second&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        ajax(<span class="string">&#x27;second&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> 那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p>
</li>
<li><p><strong>catch()</strong></p>
<p> Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">     &#125;</span><br><span class="line">); </span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>  <strong>all()</strong></p>
</li>
</ol>
<pre><code> `all`方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个`promise`对象。当数组中所有的`promise`的状态都达到`resolved`的时候，`all`方法的状态就会变成`resolved`，如果有一个状态变成了`rejected`，那么`all`方法的状态就会变成`rejected`。

 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">javascript</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="number">1</span>);</span><br><span class="line">	&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="number">2</span>);</span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="number">3</span>);</span><br><span class="line">	&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all([promise1,promise2,promise3]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="comment">//结果为：[1,2,3] </span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

 调用`all`方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象`resolve`执行时的值。
</code></pre>
<ol start="4">
<li><p><strong>race()</strong></p>
<p> <code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       reject(<span class="number">1</span>);</span><br><span class="line">	&#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="number">2</span>);</span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="number">3</span>);</span><br><span class="line">	&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([promise1,promise2,promise3]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">	<span class="comment">//结果：2</span></span><br><span class="line">&#125;,<span class="function"><span class="params">rej</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rej)&#125;;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> 那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([promise1,timeOutPromise(<span class="number">5000</span>)]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>finally()</strong></p>
<p> <code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>

<p> 上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<p> 下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>

<p> <code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> 上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
</li>
</ol>
</li>
</ol>
<h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.readFile(<span class="string">&#x27;./a.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  fs.readFile(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    fs.readFile(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的代码有如下缺点：</p>
<ul>
<li>  后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li>
<li>  如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li>
</ul>
<p><code>Promise</code>出现之后，代码变成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(url,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,data</span>)</span>&#123;</span><br><span class="line">      error &amp;&amp; reject(error)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">read(<span class="string">&#x27;./a.txt&#x27;</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> read(data) </span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> read(data)  </span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://juejin.cn/post/6844903636737196045#comment">https://juejin.cn/post/6844903636737196045#comment</a></p>
<h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><ul>
<li><p>Promise.all</p>
<p>  <code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p>
<p>  Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p>
<p>  需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p>
</li>
<li><p>Promise.race</p>
<p>  顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([promise1,timeOutPromise(<span class="number">5000</span>)]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-对async-await-的理解"><a href="#7-对async-await-的理解" class="headerlink" title="7. 对async/await 的理解"></a>7. 对async/await 的理解</h3><p>async/await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = testAsy(); </span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/06/javascript/03-7-7.png"></p>
<p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>
<p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = testAsy() </span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line">result.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)   <span class="comment">// hello world</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p>
<p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>
<p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>
<h3 id="8-await-到底在等啥？"><a href="#8-await-到底在等啥？" class="headerlink" title="8. await 到底在等啥？"></a>8. await 到底在等啥？</h3><p><strong>await 在等待什么呢？</strong> 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>
<p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;something&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething();</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">    <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>await 表达式的运算结果取决于它等的是什么。</p>
<ul>
<li>  如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li>
<li>  如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li>
</ul>
<p>来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       resolve(x);</span><br><span class="line">     &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAwt</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">  <span class="keyword">let</span> result =  <span class="keyword">await</span> testAsy(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);    <span class="comment">// 3秒钟之后出现hello world</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;cuger&#x27;</span>)   <span class="comment">// 3秒钟之后出现cug</span></span><br><span class="line">&#125;</span><br><span class="line">testAwt();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;cug&#x27;</span>)  <span class="comment">//立即输出cug</span></span><br></pre></td></tr></table></figure>

<p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p>
<h3 id="9-async-await的优势"><a href="#9-async-await的优势" class="headerlink" title="9. async/await的优势"></a>9. async/await的优势</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p>
<p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class="line"><span class="comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在用 Promise 方式来实现这三个步骤的处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br><span class="line"><span class="comment">// c:\var\test&gt;node --harmony_async_await .</span></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 500</span></span><br><span class="line"><span class="comment">// step3 with 700</span></span><br><span class="line"><span class="comment">// result is 900</span></span><br><span class="line"><span class="comment">// doIt: 1507.251ms</span></span><br></pre></td></tr></table></figure>

<p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p>
<p>如果用 async/await 来实现呢，会是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure>

<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>
<h3 id="10-async-await对比Promise的优势"><a href="#10-async-await对比Promise的优势" class="headerlink" title="10. async/await对比Promise的优势"></a>10. async/await对比Promise的优势</h3><ul>
<li>  代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担</li>
<li>  Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅</li>
<li>  错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余</li>
<li>  调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li>
</ul>
<h3 id="11-async-await-如何捕获异常"><a href="#11-async-await-如何捕获异常" class="headerlink" title="11. async/await 如何捕获异常"></a>11. async/await 如何捕获异常</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-并发与并行的区别？"><a href="#12-并发与并行的区别？" class="headerlink" title="12. 并发与并行的区别？"></a>12. 并发与并行的区别？</h3><ul>
<li>  并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</li>
<li>  并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li>
</ul>
<h3 id="13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"><a href="#13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？" class="headerlink" title="13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"></a>13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h3><p>以下代码就是一个回调函数的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url1, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        ajax(url2, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ajax(url1, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    secondAjax()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">secondAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ajax(url2, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理逻辑</span></span><br><span class="line">  firstAjax()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：</p>
<ol>
<li> 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li> 嵌套函数一多，就很难处理错误</li>
</ol>
<p>当然，回调函数还存在着别的几个缺点，比如不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。</p>
<h3 id="14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？"><a href="#14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？" class="headerlink" title="14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？"></a>14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h3><p>异步编程当然少不了定时器了，常见的定时器函数有 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>。最常用的是<code>setTimeout</code>，很多人认为 <code>setTimeout</code> 是延时多久，那就应该是多久后执行。</p>
<p>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 <code>setTimeout</code> 不会按期执行。当然了，可以通过代码去修正 <code>setTimeout</code>，从而使定时器相对准确：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + period</span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span></span><br><span class="line"><span class="keyword">let</span> currentInterval = interval</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * interval);</span><br><span class="line">  <span class="keyword">let</span> diff = end - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  <span class="keyword">let</span> h = <span class="built_in">Math</span>.floor(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">let</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">let</span> m = <span class="built_in">Math</span>.floor(hdiff / (<span class="number">60</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">let</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> s = mdiff / (<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> sCeil = <span class="built_in">Math</span>.ceil(s)</span><br><span class="line">  <span class="keyword">let</span> sFloor = <span class="built_in">Math</span>.floor(s)</span><br><span class="line">  <span class="comment">// 得到下一次循环所消耗的时间</span></span><br><span class="line">  currentInterval = interval - offset </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;时：&#x27;</span>+h, <span class="string">&#x27;分：&#x27;</span>+m, <span class="string">&#x27;毫秒：&#x27;</span>+s, <span class="string">&#x27;秒向上取整：&#x27;</span>+sCeil, <span class="string">&#x27;代码执行时间：&#x27;</span>+offset, <span class="string">&#x27;下次循环间隔&#x27;</span>+currentInterval) </span><br><span class="line">  <span class="built_in">setTimeout</span>(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(loop, currentInterval)</span><br></pre></td></tr></table></figure>

<p>接下来看 <code>setInterval</code>，其实这个函数作用和 <code>setTimeout</code> 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p>
<p>通常来说不建议使用 <code>setInterval</code>。第一，它和 <code>setTimeout</code> 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">  sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>

<p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p>
<p>如果有循环定时器的需求，其实完全可以通过 <code>requestAnimationFrame</code> 来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInterval</span>(<span class="params">callback, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now</span><br><span class="line">  <span class="keyword">let</span> startTime = now()</span><br><span class="line">  <span class="keyword">let</span> endTime = startTime</span><br><span class="line">  <span class="keyword">const</span> loop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">    endTime = now()</span><br><span class="line">    <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = now()</span><br><span class="line">      callback(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">  <span class="keyword">return</span> timer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="params">timer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">3</span>) cancelAnimationFrame(timer)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 <code>setTimeout</code>。</p>
<h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1-对象创建的方式有哪些？"><a href="#1-对象创建的方式有哪些？" class="headerlink" title="1. 对象创建的方式有哪些？"></a>1. 对象创建的方式有哪些？</h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p>
<ol>
<li> 第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</li>
<li> 第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</li>
<li> 第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</li>
<li> 第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</li>
<li> 第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</li>
<li> 第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</li>
</ol>
<h3 id="2-对象继承的方式有哪些？"><a href="#2-对象继承的方式有哪些？" class="headerlink" title="2. 对象继承的方式有哪些？"></a>2. 对象继承的方式有哪些？</h3><ol>
<li> 第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</li>
<li> 第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</li>
<li> 第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</li>
<li> 第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</li>
<li> 第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</li>
<li> 第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</li>
</ol>
<h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><p>参考：<a href="https://juejin.cn/post/6995706341041897486">https://juejin.cn/post/6995706341041897486</a></p>
<ol>
<li><p>垃圾回收的概念</p>
<p> <strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p>
<p> <strong>回收机制</strong>：</p>
<ul>
<li>  Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li>
<li>  JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li>
<li>  不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li>
</ul>
</li>
<li><p>垃圾回收的方式</p>
<p> 浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 </p>
<p> <strong>1）标记清除</strong></p>
<ul>
<li>  标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li>
<li>  垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li>
</ul>
<p> <strong>2）引用计数</strong></p>
<ul>
<li>  另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li>
<li>  这种方法会引起<strong>循环引用</strong>的问题：例如：<code> obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line">    obj1.a = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.a = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这种情况下，就要手动释放变量占用的内存：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj1.a =  <span class="literal">null</span></span><br><span class="line"> obj2.a =  <span class="literal">null</span></span><br></pre></td></tr></table></figure></li>
<li><p>减少垃圾回收</p>
<p> 虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p>
<ul>
<li>  <strong>对数组进行优化：</strong> 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li>
<li>  <strong>对</strong><code>object</code><strong>进行优化：</strong> 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li>
<li>  <strong>对函数进行优化：</strong> 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li>
</ul>
</li>
</ol>
<h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>参考：<a href="https://juejin.cn/post/6996828267068014600#heading-11">https://juejin.cn/post/6996828267068014600#heading-11</a></p>
<p>以下四种情况会造成内存的泄漏：</p>
<ul>
<li>  <strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li>  <strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li>  <strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>  <strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
<h3 id="Object-create-和"><a href="#Object-create-和" class="headerlink" title="Object.create()和{}"></a>Object.create()和{}</h3><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
